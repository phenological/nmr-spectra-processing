(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var IDX=256, HEX=[], BUFFER;
while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);

function v4() {
	var i=0, num, out='';

	if (!BUFFER || ((IDX + 16) > 256)) {
		BUFFER = Array(i=256);
		while (i--) BUFFER[i] = 256 * Math.random() | 0;
		i = IDX = 0;
	}

	for (; i < 16; i++) {
		num = BUFFER[IDX + i];
		if (i==6) out += HEX[num & 15 | 64];
		else if (i==8) out += HEX[num & 63 | 128];
		else out += HEX[num];

		if (i & 1 && i > 1 && i < 11) out += '-';
	}

	IDX++;
	return out;
}

exports.v4 = v4;
},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Implementation of the Hill system for sorting atoms
 * https://en.wikipedia.org/wiki/Chemical_formula#Hill_system
 * @param {string} a - first atom to compare
 * @param {string} b - second atom to compare
 * @returns
 */

function atomSorter(a, b) {
  if (a === b) return 0;
  if (a === 'C') return -1;
  if (b === 'C') return 1;
  if (a === 'H') return -1;
  if (b === 'H') return 1;
  if (a < b) return -1;
  return 1;
}

exports.atomSorter = atomSorter;

},{}],3:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    // The naive `low + high >>> 1` could fail for array lengths > 2**31
    // because `>>>` converts its operands to int32. `low + (high - low >>> 1)`
    // works for array lengths <= 2**32-1 which is also Javascript's max array
    // length.
    mid = low + ((high - low) >>> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    // Too low.
    if(cmp < 0.0)
      low  = mid + 1;

    // Too high.
    else if(cmp > 0.0)
      high = mid - 1;

    // Key found.
    else
      return mid;
  }

  // Key not found.
  return ~low;
}

},{}],4:[function(require,module,exports){
var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports

},{}],5:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3_array = {})));
}(this, function (exports) { 'use strict';

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  function descending(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function number$1(x) {
    return x === null ? NaN : +x;
  }

  function variance(array, f) {
    var n = array.length,
        m = 0,
        a,
        d,
        s = 0,
        i = -1,
        j = 0;

    if (f == null) {
      while (++i < n) {
        if (!isNaN(a = number$1(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(a = number$1(f(array[i], i, array)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }

    if (j > 1) return s / (j - 1);
  }

  function deviation(array, f) {
    var v = variance(array, f);
    return v ? Math.sqrt(v) : v;
  }

  function extent(array, f) {
    var i = -1,
        n = array.length,
        a,
        b,
        c;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }

    return [a, c];
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function identity(x) {
    return x;
  }

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks(start, stop, count) {
    var step = tickStep(start, stop, count);
    return range(
      Math.ceil(start / step) * step,
      Math.floor(stop / step) * step + step / 2, // inclusive
      step
    );
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function sturges(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
  }

  function number(x) {
    return +x;
  }

  function histogram() {
    var value = identity,
        domain = extent,
        threshold = sturges;

    function histogram(data) {
      var i,
          n = data.length,
          x,
          values = new Array(n);

      // Coerce values to numbers.
      for (i = 0; i < n; ++i) {
        values[i] = +value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = +xz[0],
          x1 = +xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) tz = ticks(x0, x1, +tz);

      // Coerce thresholds to numbers, ignoring any outside the domain.
      var m = tz.length;
      for (i = 0; i < m; ++i) tz[i] = +tz[i];
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] >= x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), histogram) : value;
    };

    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), histogram) : domain;
    };

    histogram.thresholds = function(_) {
      if (!arguments.length) return threshold;
      threshold = typeof _ === "function" ? _
          : Array.isArray(_) ? constant(Array.prototype.map.call(_, number))
          : constant(+_);
      return histogram;
    };

    return histogram;
  }

  function quantile(array, p, f) {
    if (f == null) f = number$1;
    if (!(n = array.length)) return;
    if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
    if (p >= 1) return +f(array[n - 1], n - 1, array);
    var n,
        h = (n - 1) * p,
        i = Math.floor(h),
        a = +f(array[i], i, array),
        b = +f(array[i + 1], i + 1, array);
    return a + (b - a) * (h - i);
  }

  function freedmanDiaconis(values, min, max) {
    values.sort(ascending);
    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
  }

  function scott(values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
  }

  function max(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
    }

    return a;
  }

  function mean(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1,
        j = n;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number$1(array[i]))) s += a; else --j;
    }

    else {
      while (++i < n) if (!isNaN(a = number$1(f(array[i], i, array)))) s += a; else --j;
    }

    if (j) return s / j;
  }

  function median(array, f) {
    var numbers = [],
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (!isNaN(a = number$1(array[i]))) numbers.push(a);
    }

    else {
      while (++i < n) if (!isNaN(a = number$1(f(array[i], i, array)))) numbers.push(a);
    }

    return quantile(numbers.sort(ascending), 0.5);
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function min(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
    }

    return a;
  }

  function pairs(array) {
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [p, p = array[++i]];
    return pairs;
  }

  function permute(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  }

  function scan(array, compare) {
    if (!(n = array.length)) return;
    var i = 0,
        n,
        j = 0,
        xi,
        xj = array[j];

    if (!compare) compare = ascending;

    while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

    if (compare(xj, xj) === 0) return j;
  }

  function shuffle(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  }

  function sum(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
    }

    else {
      while (++i < n) if (a = +f(array[i], i, array)) s += a;
    }

    return s;
  }

  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  }

  function length(d) {
    return d.length;
  }

  function zip() {
    return transpose(arguments);
  }

  var version = "0.7.1";

  exports.version = version;
  exports.bisect = bisectRight;
  exports.bisectRight = bisectRight;
  exports.bisectLeft = bisectLeft;
  exports.ascending = ascending;
  exports.bisector = bisector;
  exports.descending = descending;
  exports.deviation = deviation;
  exports.extent = extent;
  exports.histogram = histogram;
  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
  exports.thresholdScott = scott;
  exports.thresholdSturges = sturges;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.merge = merge;
  exports.min = min;
  exports.pairs = pairs;
  exports.permute = permute;
  exports.quantile = quantile;
  exports.range = range;
  exports.scan = scan;
  exports.shuffle = shuffle;
  exports.sum = sum;
  exports.ticks = ticks;
  exports.tickStep = tickStep;
  exports.transpose = transpose;
  exports.variance = variance;
  exports.zip = zip;

}));
},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Dynamically type a string
 * @param {string} value String to dynamically type
 * @returns {boolean|string|number}
 */
function parseString(value) {
  if (value.length === 4 || value.length === 5) {
    let lowercase = value.toLowerCase();

    if (lowercase === 'true') return true;
    if (lowercase === 'false') return false;
  }
  let number = Number(value);
  if (number === 0 && !value.includes('0')) {
    return value;
  }
  if (!Number.isNaN(number)) return number;
  return value;
}

exports.parseString = parseString;

},{}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureString = void 0;
const isutf8_1 = __importDefault(require("isutf8"));
/**
 * Ensure that the data is string. If it is an ArrayBuffer it will be converted to string using TextDecoder.
 * @param blob
 * @param options
 * @returns
 */
function ensureString(blob, options = {}) {
    if (typeof blob === 'string') {
        return blob;
    }
    if (ArrayBuffer.isView(blob) || blob instanceof ArrayBuffer) {
        const { encoding = guessEncoding(blob) } = options;
        const decoder = new TextDecoder(encoding);
        return decoder.decode(blob);
    }
    throw new TypeError(`blob must be a string, ArrayBuffer or ArrayBufferView`);
}
exports.ensureString = ensureString;
function guessEncoding(blob) {
    const uint8 = ArrayBuffer.isView(blob)
        ? new Uint8Array(blob.buffer, blob.byteOffset, blob.byteLength)
        : new Uint8Array(blob);
    if (uint8.length >= 2) {
        if (uint8[0] === 0xfe && uint8[1] === 0xff) {
            return 'utf-16be';
        }
        if (uint8[0] === 0xff && uint8[1] === 0xfe) {
            return 'utf-16le';
        }
    }
    //@ts-expect-error an ArrayBuffer is also ok
    if (!(0, isutf8_1.default)(blob))
        return 'latin1';
    return 'utf-8';
}

},{"isutf8":14}],8:[function(require,module,exports){
'use strict';

function FFT(size) {
  this.size = size | 0;
  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)
    throw new Error('FFT size must be a power of two and bigger than 1');

  this._csize = size << 1;

  // NOTE: Use of `var` is intentional for old V8 versions
  var table = new Array(this.size * 2);
  for (var i = 0; i < table.length; i += 2) {
    const angle = Math.PI * i / this.size;
    table[i] = Math.cos(angle);
    table[i + 1] = -Math.sin(angle);
  }
  this.table = table;

  // Find size's power of two
  var power = 0;
  for (var t = 1; this.size > t; t <<= 1)
    power++;

  // Calculate initial step's width:
  //   * If we are full radix-4 - it is 2x smaller to give inital len=8
  //   * Otherwise it is the same as `power` to give len=4
  this._width = power % 2 === 0 ? power - 1 : power;

  // Pre-compute bit-reversal patterns
  this._bitrev = new Array(1 << this._width);
  for (var j = 0; j < this._bitrev.length; j++) {
    this._bitrev[j] = 0;
    for (var shift = 0; shift < this._width; shift += 2) {
      var revShift = this._width - shift - 2;
      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;
    }
  }

  this._out = null;
  this._data = null;
  this._inv = 0;
}
module.exports = FFT;

FFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
  var res = storage || new Array(complex.length >>> 1);
  for (var i = 0; i < complex.length; i += 2)
    res[i >>> 1] = complex[i];
  return res;
};

FFT.prototype.createComplexArray = function createComplexArray() {
  const res = new Array(this._csize);
  for (var i = 0; i < res.length; i++)
    res[i] = 0;
  return res;
};

FFT.prototype.toComplexArray = function toComplexArray(input, storage) {
  var res = storage || this.createComplexArray();
  for (var i = 0; i < res.length; i += 2) {
    res[i] = input[i >>> 1];
    res[i + 1] = 0;
  }
  return res;
};

FFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {
  var size = this._csize;
  var half = size >>> 1;
  for (var i = 2; i < half; i += 2) {
    spectrum[size - i] = spectrum[i];
    spectrum[size - i + 1] = -spectrum[i + 1];
  }
};

FFT.prototype.transform = function transform(out, data) {
  if (out === data)
    throw new Error('Input and output buffers must be different');

  this._out = out;
  this._data = data;
  this._inv = 0;
  this._transform4();
  this._out = null;
  this._data = null;
};

FFT.prototype.realTransform = function realTransform(out, data) {
  if (out === data)
    throw new Error('Input and output buffers must be different');

  this._out = out;
  this._data = data;
  this._inv = 0;
  this._realTransform4();
  this._out = null;
  this._data = null;
};

FFT.prototype.inverseTransform = function inverseTransform(out, data) {
  if (out === data)
    throw new Error('Input and output buffers must be different');

  this._out = out;
  this._data = data;
  this._inv = 1;
  this._transform4();
  for (var i = 0; i < out.length; i++)
    out[i] /= this.size;
  this._out = null;
  this._data = null;
};

// radix-4 implementation
//
// NOTE: Uses of `var` are intentional for older V8 version that do not
// support both `let compound assignments` and `const phi`
FFT.prototype._transform4 = function _transform4() {
  var out = this._out;
  var size = this._csize;

  // Initial step (permute and transform)
  var width = this._width;
  var step = 1 << width;
  var len = (size / step) << 1;

  var outOff;
  var t;
  var bitrev = this._bitrev;
  if (len === 4) {
    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
      const off = bitrev[t];
      this._singleTransform2(outOff, off, step);
    }
  } else {
    // len === 8
    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
      const off = bitrev[t];
      this._singleTransform4(outOff, off, step);
    }
  }

  // Loop through steps in decreasing order
  var inv = this._inv ? -1 : 1;
  var table = this.table;
  for (step >>= 2; step >= 2; step >>= 2) {
    len = (size / step) << 1;
    var quarterLen = len >>> 2;

    // Loop through offsets in the data
    for (outOff = 0; outOff < size; outOff += len) {
      // Full case
      var limit = outOff + quarterLen;
      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {
        const A = i;
        const B = A + quarterLen;
        const C = B + quarterLen;
        const D = C + quarterLen;

        // Original values
        const Ar = out[A];
        const Ai = out[A + 1];
        const Br = out[B];
        const Bi = out[B + 1];
        const Cr = out[C];
        const Ci = out[C + 1];
        const Dr = out[D];
        const Di = out[D + 1];

        // Middle values
        const MAr = Ar;
        const MAi = Ai;

        const tableBr = table[k];
        const tableBi = inv * table[k + 1];
        const MBr = Br * tableBr - Bi * tableBi;
        const MBi = Br * tableBi + Bi * tableBr;

        const tableCr = table[2 * k];
        const tableCi = inv * table[2 * k + 1];
        const MCr = Cr * tableCr - Ci * tableCi;
        const MCi = Cr * tableCi + Ci * tableCr;

        const tableDr = table[3 * k];
        const tableDi = inv * table[3 * k + 1];
        const MDr = Dr * tableDr - Di * tableDi;
        const MDi = Dr * tableDi + Di * tableDr;

        // Pre-Final values
        const T0r = MAr + MCr;
        const T0i = MAi + MCi;
        const T1r = MAr - MCr;
        const T1i = MAi - MCi;
        const T2r = MBr + MDr;
        const T2i = MBi + MDi;
        const T3r = inv * (MBr - MDr);
        const T3i = inv * (MBi - MDi);

        // Final values
        const FAr = T0r + T2r;
        const FAi = T0i + T2i;

        const FCr = T0r - T2r;
        const FCi = T0i - T2i;

        const FBr = T1r + T3i;
        const FBi = T1i - T3r;

        const FDr = T1r - T3i;
        const FDi = T1i + T3r;

        out[A] = FAr;
        out[A + 1] = FAi;
        out[B] = FBr;
        out[B + 1] = FBi;
        out[C] = FCr;
        out[C + 1] = FCi;
        out[D] = FDr;
        out[D + 1] = FDi;
      }
    }
  }
};

// radix-2 implementation
//
// NOTE: Only called for len=4
FFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,
                                                             step) {
  const out = this._out;
  const data = this._data;

  const evenR = data[off];
  const evenI = data[off + 1];
  const oddR = data[off + step];
  const oddI = data[off + step + 1];

  const leftR = evenR + oddR;
  const leftI = evenI + oddI;
  const rightR = evenR - oddR;
  const rightI = evenI - oddI;

  out[outOff] = leftR;
  out[outOff + 1] = leftI;
  out[outOff + 2] = rightR;
  out[outOff + 3] = rightI;
};

// radix-4
//
// NOTE: Only called for len=8
FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,
                                                             step) {
  const out = this._out;
  const data = this._data;
  const inv = this._inv ? -1 : 1;
  const step2 = step * 2;
  const step3 = step * 3;

  // Original values
  const Ar = data[off];
  const Ai = data[off + 1];
  const Br = data[off + step];
  const Bi = data[off + step + 1];
  const Cr = data[off + step2];
  const Ci = data[off + step2 + 1];
  const Dr = data[off + step3];
  const Di = data[off + step3 + 1];

  // Pre-Final values
  const T0r = Ar + Cr;
  const T0i = Ai + Ci;
  const T1r = Ar - Cr;
  const T1i = Ai - Ci;
  const T2r = Br + Dr;
  const T2i = Bi + Di;
  const T3r = inv * (Br - Dr);
  const T3i = inv * (Bi - Di);

  // Final values
  const FAr = T0r + T2r;
  const FAi = T0i + T2i;

  const FBr = T1r + T3i;
  const FBi = T1i - T3r;

  const FCr = T0r - T2r;
  const FCi = T0i - T2i;

  const FDr = T1r - T3i;
  const FDi = T1i + T3r;

  out[outOff] = FAr;
  out[outOff + 1] = FAi;
  out[outOff + 2] = FBr;
  out[outOff + 3] = FBi;
  out[outOff + 4] = FCr;
  out[outOff + 5] = FCi;
  out[outOff + 6] = FDr;
  out[outOff + 7] = FDi;
};

// Real input radix-4 implementation
FFT.prototype._realTransform4 = function _realTransform4() {
  var out = this._out;
  var size = this._csize;

  // Initial step (permute and transform)
  var width = this._width;
  var step = 1 << width;
  var len = (size / step) << 1;

  var outOff;
  var t;
  var bitrev = this._bitrev;
  if (len === 4) {
    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
      const off = bitrev[t];
      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
    }
  } else {
    // len === 8
    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
      const off = bitrev[t];
      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
    }
  }

  // Loop through steps in decreasing order
  var inv = this._inv ? -1 : 1;
  var table = this.table;
  for (step >>= 2; step >= 2; step >>= 2) {
    len = (size / step) << 1;
    var halfLen = len >>> 1;
    var quarterLen = halfLen >>> 1;
    var hquarterLen = quarterLen >>> 1;

    // Loop through offsets in the data
    for (outOff = 0; outOff < size; outOff += len) {
      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
        var A = outOff + i;
        var B = A + quarterLen;
        var C = B + quarterLen;
        var D = C + quarterLen;

        // Original values
        var Ar = out[A];
        var Ai = out[A + 1];
        var Br = out[B];
        var Bi = out[B + 1];
        var Cr = out[C];
        var Ci = out[C + 1];
        var Dr = out[D];
        var Di = out[D + 1];

        // Middle values
        var MAr = Ar;
        var MAi = Ai;

        var tableBr = table[k];
        var tableBi = inv * table[k + 1];
        var MBr = Br * tableBr - Bi * tableBi;
        var MBi = Br * tableBi + Bi * tableBr;

        var tableCr = table[2 * k];
        var tableCi = inv * table[2 * k + 1];
        var MCr = Cr * tableCr - Ci * tableCi;
        var MCi = Cr * tableCi + Ci * tableCr;

        var tableDr = table[3 * k];
        var tableDi = inv * table[3 * k + 1];
        var MDr = Dr * tableDr - Di * tableDi;
        var MDi = Dr * tableDi + Di * tableDr;

        // Pre-Final values
        var T0r = MAr + MCr;
        var T0i = MAi + MCi;
        var T1r = MAr - MCr;
        var T1i = MAi - MCi;
        var T2r = MBr + MDr;
        var T2i = MBi + MDi;
        var T3r = inv * (MBr - MDr);
        var T3i = inv * (MBi - MDi);

        // Final values
        var FAr = T0r + T2r;
        var FAi = T0i + T2i;

        var FBr = T1r + T3i;
        var FBi = T1i - T3r;

        out[A] = FAr;
        out[A + 1] = FAi;
        out[B] = FBr;
        out[B + 1] = FBi;

        // Output final middle point
        if (i === 0) {
          var FCr = T0r - T2r;
          var FCi = T0i - T2i;
          out[C] = FCr;
          out[C + 1] = FCi;
          continue;
        }

        // Do not overwrite ourselves
        if (i === hquarterLen)
          continue;

        // In the flipped case:
        // MAi = -MAi
        // MBr=-MBi, MBi=-MBr
        // MCr=-MCr
        // MDr=MDi, MDi=MDr
        var ST0r = T1r;
        var ST0i = -T1i;
        var ST1r = T0r;
        var ST1i = -T0i;
        var ST2r = -inv * T3i;
        var ST2i = -inv * T3r;
        var ST3r = -inv * T2i;
        var ST3i = -inv * T2r;

        var SFAr = ST0r + ST2r;
        var SFAi = ST0i + ST2i;

        var SFBr = ST1r + ST3i;
        var SFBi = ST1i - ST3r;

        var SA = outOff + quarterLen - i;
        var SB = outOff + halfLen - i;

        out[SA] = SFAr;
        out[SA + 1] = SFAi;
        out[SB] = SFBr;
        out[SB + 1] = SFBi;
      }
    }
  }
};

// radix-2 implementation
//
// NOTE: Only called for len=4
FFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,
                                                                     off,
                                                                     step) {
  const out = this._out;
  const data = this._data;

  const evenR = data[off];
  const oddR = data[off + step];

  const leftR = evenR + oddR;
  const rightR = evenR - oddR;

  out[outOff] = leftR;
  out[outOff + 1] = 0;
  out[outOff + 2] = rightR;
  out[outOff + 3] = 0;
};

// radix-4
//
// NOTE: Only called for len=8
FFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,
                                                                     off,
                                                                     step) {
  const out = this._out;
  const data = this._data;
  const inv = this._inv ? -1 : 1;
  const step2 = step * 2;
  const step3 = step * 3;

  // Original values
  const Ar = data[off];
  const Br = data[off + step];
  const Cr = data[off + step2];
  const Dr = data[off + step3];

  // Pre-Final values
  const T0r = Ar + Cr;
  const T1r = Ar - Cr;
  const T2r = Br + Dr;
  const T3r = inv * (Br - Dr);

  // Final values
  const FAr = T0r + T2r;

  const FBr = T1r;
  const FBi = -T3r;

  const FCr = T0r - T2r;

  const FDr = T1r;
  const FDi = T3r;

  out[outOff] = FAr;
  out[outOff + 1] = 0;
  out[outOff + 2] = FBr;
  out[outOff + 3] = FBi;
  out[outOff + 4] = FCr;
  out[outOff + 5] = 0;
  out[outOff + 6] = FDr;
  out[outOff + 7] = FDi;
};

},{}],9:[function(require,module,exports){
/* eslint-env browser */
//module.exports = typeof self == 'object' ? self.FormData : window.FormData;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gyromagneticRatio = void 0;
exports.gyromagneticRatio = {
    '1H': 267.52218744e6,
    '2H': 41.065e6,
    '3H': 285.3508e6,
    '3He': -203.789e6,
    '7Li': 103.962e6,
    '13C': 67.28284e6,
    '14N': 19.331e6,
    '15N': -27.116e6,
    '17O': -36.264e6,
    '19F': 251.662e6,
    '23Na': 70.761e6,
    '27Al': 69.763e6,
    '29Si': -53.19e6,
    '31P': 108.291e6,
    '57Fe': 8.681e6,
    '63Cu': 71.118e6,
    '67Zn': 16.767e6,
    '129Xe': -73.997e6,
};

},{}],11:[function(require,module,exports){
module.exports = require('./lib/heap');

},{"./lib/heap":12}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAnyArray = void 0;
const toString = Object.prototype.toString;
/**
 * Checks if an object is an instance of an Array (array or typed array).
 *
 * @param {any} value - Object to check.
 * @returns {boolean} True if the object is an array.
 */
function isAnyArray(value) {
    return toString.call(value).endsWith('Array]');
}
exports.isAnyArray = isAnyArray;

},{}],14:[function(require,module,exports){
'use strict';

/*
    https://tools.ietf.org/html/rfc3629

    UTF8-char = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4

    UTF8-1    = %x00-7F

    UTF8-2    = %xC2-DF UTF8-tail

    UTF8-3    = %xE0 %xA0-BF UTF8-tail
                %xE1-EC 2( UTF8-tail )
                %xED %x80-9F UTF8-tail
                %xEE-EF 2( UTF8-tail )

    UTF8-4    = %xF0 %x90-BF 2( UTF8-tail )
                %xF1-F3 3( UTF8-tail )
                %xF4 %x80-8F 2( UTF8-tail )

    UTF8-tail = %x80-BF
*/
/**
 * Check if a Node.js Buffer or Uint8Array is UTF-8.
 */
function isUtf8(buf) {
    if (!buf) {
        return false;
    }
    var i = 0;
    var len = buf.length;
    while (i < len) {
        // UTF8-1 = %x00-7F
        if (buf[i] <= 0x7F) {
            i++;
            continue;
        }
        // UTF8-2 = %xC2-DF UTF8-tail
        if (buf[i] >= 0xC2 && buf[i] <= 0xDF) {
            // if(buf[i + 1] >= 0x80 && buf[i + 1] <= 0xBF) {
            if (buf[i + 1] >> 6 === 2) {
                i += 2;
                continue;
            }
            else {
                return false;
            }
        }
        // UTF8-3 = %xE0 %xA0-BF UTF8-tail
        // UTF8-3 = %xED %x80-9F UTF8-tail
        if (((buf[i] === 0xE0 && buf[i + 1] >= 0xA0 && buf[i + 1] <= 0xBF) ||
            (buf[i] === 0xED && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x9F)) && buf[i + 2] >> 6 === 2) {
            i += 3;
            continue;
        }
        // UTF8-3 = %xE1-EC 2( UTF8-tail )
        // UTF8-3 = %xEE-EF 2( UTF8-tail )
        if (((buf[i] >= 0xE1 && buf[i] <= 0xEC) ||
            (buf[i] >= 0xEE && buf[i] <= 0xEF)) &&
            buf[i + 1] >> 6 === 2 &&
            buf[i + 2] >> 6 === 2) {
            i += 3;
            continue;
        }
        // UTF8-4 = %xF0 %x90-BF 2( UTF8-tail )
        //          %xF1-F3 3( UTF8-tail )
        //          %xF4 %x80-8F 2( UTF8-tail )
        if (((buf[i] === 0xF0 && buf[i + 1] >= 0x90 && buf[i + 1] <= 0xBF) ||
            (buf[i] >= 0xF1 && buf[i] <= 0xF3 && buf[i + 1] >> 6 === 2) ||
            (buf[i] === 0xF4 && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x8F)) &&
            buf[i + 2] >> 6 === 2 &&
            buf[i + 3] >> 6 === 2) {
            i += 4;
            continue;
        }
        return false;
    }
    return true;
}

module.exports = isUtf8;

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShortestPath = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
function getShortestPath(options) {
    let { currUnAssCol, dualVariableForColumns, dualVariableForRows, rowAssignments, columnAssignments, matrix, } = options;
    let nbRows = matrix.rows;
    let nbColumns = matrix.columns;
    let pred = new Float64Array(nbRows);
    let scannedColumns = new Float64Array(nbColumns);
    let scannedRows = new Float64Array(nbRows);
    let rows2Scan = Array.from((0, ml_spectra_processing_1.xSequentialFill)({ from: 0, to: nbRows - 1 }));
    let numRows2Scan = nbRows;
    let sink = -1;
    let delta = 0;
    let curColumn = currUnAssCol;
    let shortestPathCost = new Array(nbRows).fill(Number.POSITIVE_INFINITY);
    while (sink === -1) {
        scannedColumns[curColumn] = 1;
        let minVal = Number.POSITIVE_INFINITY;
        let closestRowScan = -1;
        for (let curRowScan = 0; curRowScan < numRows2Scan; curRowScan++) {
            let curRow = rows2Scan[curRowScan];
            let reducedCost = delta +
                matrix.get(curRow, curColumn) -
                dualVariableForColumns[curColumn] -
                dualVariableForRows[curRow];
            if (reducedCost < shortestPathCost[curRow]) {
                pred[curRow] = curColumn;
                shortestPathCost[curRow] = reducedCost;
            }
            if (shortestPathCost[curRow] < minVal) {
                minVal = shortestPathCost[curRow];
                closestRowScan = curRowScan;
            }
        }
        if (!Number.isFinite(minVal)) {
            return { dualVariableForColumns, dualVariableForRows, sink, pred };
        }
        let closestRow = rows2Scan[closestRowScan];
        scannedRows[closestRow] = 1;
        numRows2Scan -= 1;
        rows2Scan.splice(closestRowScan, 1);
        delta = shortestPathCost[closestRow];
        if (rowAssignments[closestRow] === -1) {
            sink = closestRow;
        }
        else {
            curColumn = rowAssignments[closestRow];
        }
    }
    dualVariableForColumns[currUnAssCol] += delta;
    for (let sel = 0; sel < nbColumns; sel++) {
        if (scannedColumns[sel] === 0)
            continue;
        if (sel === currUnAssCol)
            continue;
        dualVariableForColumns[sel] +=
            delta - shortestPathCost[columnAssignments[sel]];
    }
    for (let sel = 0; sel < nbRows; sel++) {
        if (scannedRows[sel] === 0)
            continue;
        dualVariableForRows[sel] -= delta - shortestPathCost[sel];
    }
    return {
        sink,
        pred,
        dualVariableForColumns,
        dualVariableForRows,
    };
}
exports.getShortestPath = getShortestPath;

},{"ml-spectra-processing":208}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linearSumAssignment = void 0;
const ml_matrix_1 = require("ml-matrix");
const getShortestPath_1 = require("./getShortestPath");
/**
 * Implementation of Jonker-Volgenant shortest augmenting path algorithm based
 * on the publication [On implementing 2D rectangular assignment algorithms](https://doi.org/10.1109/TAES.2016.140952)
 */
function linearSumAssignment(
/**
 * Cost matrix
 */
input, options = {}) {
    const { maximaze = true } = options;
    let matrix = ml_matrix_1.Matrix.checkMatrix(input);
    let didFlip = false;
    if (matrix.columns > matrix.rows) {
        didFlip = true;
        matrix = matrix.transpose();
    }
    let nbRows = matrix.rows;
    let nbColumns = matrix.columns;
    let matrixDelta = maximaze ? matrix.max() : matrix.min();
    matrix = matrix.subtract(matrixDelta);
    if (maximaze)
        matrix = matrix.mul(-1);
    let rowAssignments = new Float64Array(nbRows).fill(-1);
    let columnAssignments = new Float64Array(nbColumns).fill(-1);
    let dualVariableForColumns = new Float64Array(nbColumns);
    let dualVariableForRows = new Float64Array(nbRows);
    for (let currUnAssCol = 0; currUnAssCol < nbColumns; currUnAssCol++) {
        let currentAugmenting = (0, getShortestPath_1.getShortestPath)({
            matrix,
            currUnAssCol,
            dualVariableForColumns,
            dualVariableForRows,
            rowAssignments,
            columnAssignments,
        });
        let { sink, pred } = currentAugmenting;
        if (sink === -1) {
            return {
                rowAssignments,
                columnAssignments,
                gain: -1,
                dualVariableForColumns,
                dualVariableForRows,
            };
        }
        dualVariableForColumns = currentAugmenting.dualVariableForColumns;
        dualVariableForRows = currentAugmenting.dualVariableForRows;
        let j = sink;
        for (let i = pred[j]; true; i = pred[j]) {
            rowAssignments[j] = i;
            let h = columnAssignments[i];
            columnAssignments[i] = j;
            j = h;
            if (i === currUnAssCol)
                break;
        }
    }
    let gain = 0;
    for (let curCol = 0; curCol < nbColumns; curCol++) {
        gain += matrix.get(columnAssignments[curCol], curCol);
    }
    gain = (maximaze ? -1 : 1) * gain + matrixDelta * nbColumns;
    if (didFlip) {
        [columnAssignments, rowAssignments] = [rowAssignments, columnAssignments];
        [dualVariableForColumns, dualVariableForRows] = [
            dualVariableForRows,
            dualVariableForColumns,
        ];
    }
    return {
        rowAssignments,
        columnAssignments,
        gain,
        dualVariableForColumns,
        dualVariableForRows,
    };
}
exports.linearSumAssignment = linearSumAssignment;

},{"./getShortestPath":15,"ml-matrix":186}],17:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":78,"./_root":116}],18:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":85,"./_hashDelete":86,"./_hashGet":87,"./_hashHas":88,"./_hashSet":89}],19:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":98,"./_listCacheDelete":99,"./_listCacheGet":100,"./_listCacheHas":101,"./_listCacheSet":102}],20:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":78,"./_root":116}],21:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":103,"./_mapCacheDelete":104,"./_mapCacheGet":105,"./_mapCacheHas":106,"./_mapCacheSet":107}],22:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":78,"./_root":116}],23:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":78,"./_root":116}],24:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":21,"./_setCacheAdd":117,"./_setCacheHas":118}],25:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":19,"./_stackClear":120,"./_stackDelete":121,"./_stackGet":122,"./_stackHas":123,"./_stackSet":124}],26:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":116}],27:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":116}],28:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":78,"./_root":116}],29:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],30:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],31:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":54,"./_isIndex":93,"./isArguments":131,"./isArray":132,"./isBuffer":134,"./isTypedArray":143}],32:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],33:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],34:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],35:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":39,"./eq":129}],36:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":129}],37:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":66,"./keys":144}],38:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":66,"./keysIn":145}],39:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":70}],40:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":25,"./_arrayEach":29,"./_assignValue":35,"./_baseAssign":37,"./_baseAssignIn":38,"./_cloneBuffer":60,"./_copyArray":65,"./_copySymbols":67,"./_copySymbolsIn":68,"./_getAllKeys":75,"./_getAllKeysIn":76,"./_getTag":83,"./_initCloneArray":90,"./_initCloneByTag":91,"./_initCloneObject":92,"./isArray":132,"./isBuffer":134,"./isMap":138,"./isObject":139,"./isSet":141,"./keys":144,"./keysIn":145}],41:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":139}],42:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":58,"./_toKey":126}],43:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":33,"./isArray":132}],44:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":26,"./_getRawTag":80,"./_objectToString":114}],45:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":44,"./isObjectLike":140}],46:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":47,"./isObjectLike":140}],47:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":25,"./_equalArrays":71,"./_equalByTag":72,"./_equalObjects":73,"./_getTag":83,"./isArray":132,"./isBuffer":134,"./isTypedArray":143}],48:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":83,"./isObjectLike":140}],49:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":96,"./_toSource":127,"./isFunction":136,"./isObject":139}],50:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":83,"./isObjectLike":140}],51:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":44,"./isLength":137,"./isObjectLike":140}],52:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":97,"./_nativeKeys":111}],53:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":97,"./_nativeKeysIn":112,"./isObject":139}],54:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],55:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":26,"./_arrayMap":32,"./isArray":132,"./isSymbol":142}],56:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],57:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],58:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":94,"./_stringToPath":125,"./isArray":132,"./toString":149}],59:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":27}],60:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":116}],61:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":59}],62:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],63:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":26}],64:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":59}],65:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],66:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":35,"./_baseAssignValue":39}],67:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":66,"./_getSymbols":81}],68:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":66,"./_getSymbolsIn":82}],69:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":116}],70:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":78}],71:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":24,"./_arraySome":34,"./_cacheHas":57}],72:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":26,"./_Uint8Array":27,"./_equalArrays":71,"./_mapToArray":108,"./_setToArray":119,"./eq":129}],73:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":75}],74:[function(require,module,exports){
(function (global){(function (){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],75:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":43,"./_getSymbols":81,"./keys":144}],76:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":43,"./_getSymbolsIn":82,"./keysIn":145}],77:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":95}],78:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":49,"./_getValue":84}],79:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":115}],80:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":26}],81:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":30,"./stubArray":147}],82:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":33,"./_getPrototype":79,"./_getSymbols":81,"./stubArray":147}],83:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":17,"./_Map":20,"./_Promise":22,"./_Set":23,"./_WeakMap":28,"./_baseGetTag":44,"./_toSource":127}],84:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],85:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":110}],86:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],87:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":110}],88:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":110}],89:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":110}],90:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],91:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":59,"./_cloneDataView":61,"./_cloneRegExp":62,"./_cloneSymbol":63,"./_cloneTypedArray":64}],92:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":41,"./_getPrototype":79,"./_isPrototype":97}],93:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],94:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":132,"./isSymbol":142}],95:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],96:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":69}],97:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],98:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],99:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":36}],100:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":36}],101:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":36}],102:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":36}],103:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":18,"./_ListCache":19,"./_Map":20}],104:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":77}],105:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":77}],106:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":77}],107:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":77}],108:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],109:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":146}],110:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":78}],111:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":115}],112:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],113:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":74}],114:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],115:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],116:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":74}],117:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],118:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],119:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],120:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":19}],121:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],122:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],123:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],124:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":19,"./_Map":20,"./_MapCache":21}],125:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":109}],126:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":142}],127:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],128:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":40}],129:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],130:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":42}],131:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":45,"./isObjectLike":140}],132:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],133:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":136,"./isLength":137}],134:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":116,"./stubFalse":148}],135:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":46}],136:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":44,"./isObject":139}],137:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],138:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":48,"./_baseUnary":56,"./_nodeUtil":113}],139:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],140:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],141:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":50,"./_baseUnary":56,"./_nodeUtil":113}],142:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":44,"./isObjectLike":140}],143:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":51,"./_baseUnary":56,"./_nodeUtil":113}],144:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":31,"./_baseKeys":52,"./isArrayLike":133}],145:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":31,"./_baseKeysIn":53,"./isArrayLike":133}],146:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":21}],147:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],148:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],149:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":55}],150:[function(require,module,exports){
'use strict';

var isAnyArray = require('is-any-array');

function max(input, options = {}) {
  if (!isAnyArray.isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  const { fromIndex = 0, toIndex = input.length } = options;

  if (
    fromIndex < 0 ||
    fromIndex >= input.length ||
    !Number.isInteger(fromIndex)
  ) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (
    toIndex <= fromIndex ||
    toIndex > input.length ||
    !Number.isInteger(toIndex)
  ) {
    throw new Error(
      'toIndex must be an integer greater than fromIndex and at most equal to length',
    );
  }

  let maxValue = input[fromIndex];
  for (let i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }
  return maxValue;
}

module.exports = max;

},{"is-any-array":13}],151:[function(require,module,exports){
'use strict';

var sum = require('ml-array-sum');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var sum__default = /*#__PURE__*/_interopDefaultLegacy(sum);

function mean(input) {
  return sum__default['default'](input) / input.length;
}

module.exports = mean;

},{"ml-array-sum":154}],152:[function(require,module,exports){
'use strict';

var isAnyArray = require('is-any-array');

function min(input, options = {}) {
  if (!isAnyArray.isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  const { fromIndex = 0, toIndex = input.length } = options;

  if (
    fromIndex < 0 ||
    fromIndex >= input.length ||
    !Number.isInteger(fromIndex)
  ) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (
    toIndex <= fromIndex ||
    toIndex > input.length ||
    !Number.isInteger(toIndex)
  ) {
    throw new Error(
      'toIndex must be an integer greater than fromIndex and at most equal to length',
    );
  }

  let minValue = input[fromIndex];
  for (let i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] < minValue) minValue = input[i];
  }
  return minValue;
}

module.exports = min;

},{"is-any-array":13}],153:[function(require,module,exports){
'use strict';

var isAnyArray = require('is-any-array');
var max = require('ml-array-max');
var min = require('ml-array-min');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var max__default = /*#__PURE__*/_interopDefaultLegacy(max);
var min__default = /*#__PURE__*/_interopDefaultLegacy(min);

function rescale(input, options = {}) {
  if (!isAnyArray.isAnyArray(input)) {
    throw new TypeError('input must be an array');
  } else if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  let output;
  if (options.output !== undefined) {
    if (!isAnyArray.isAnyArray(options.output)) {
      throw new TypeError('output option must be an array if specified');
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }

  const currentMin = min__default['default'](input);
  const currentMax = max__default['default'](input);

  if (currentMin === currentMax) {
    throw new RangeError(
      'minimum and maximum input values are equal. Cannot rescale a constant array',
    );
  }

  const {
    min: minValue = options.autoMinMax ? currentMin : 0,
    max: maxValue = options.autoMinMax ? currentMax : 1,
  } = options;

  if (minValue >= maxValue) {
    throw new RangeError('min option must be smaller than max option');
  }

  const factor = (maxValue - minValue) / (currentMax - currentMin);
  for (let i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }

  return output;
}

module.exports = rescale;

},{"is-any-array":13,"ml-array-max":150,"ml-array-min":152}],154:[function(require,module,exports){
'use strict';

var isAnyArray = require('is-any-array');

function sum(input) {
  if (!isAnyArray.isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  let sumValue = 0;
  for (let i = 0; i < input.length; i++) {
    sumValue += input[i];
  }
  return sumValue;
}

module.exports = sum;

},{"is-any-array":13}],155:[function(require,module,exports){
'use strict';

var mlSpectraProcessing = require('ml-spectra-processing');

/**
 * Preparata, F. P., & Shamos, M. I. (2012). Computational geometry: an introduction. Springer Science & Business Media.
 * @param {Array} x - The array with x coordinates of the points.
 * @param {Array} y - The array with y coordinates of the points.
 * @return {Array} The indices of the points of anticlockwise lower convex hull
 * @private
 */
function antiLowerConvexHull(x, y) {
  if (x.length !== y.length) {
    throw new RangeError('X and Y vectors has different dimensions');
  }

  const nbPoints = x.length - 1;
  if (nbPoints === 0) return [0];
  if (nbPoints === 1) return [0, 1];

  let currentPoint = 0;
  let result = new Array(x.length).fill(true);
  while (true) {
    const a = currentPoint;
    const b = moveOn(currentPoint, nbPoints, result);
    const c = moveOn(moveOn(currentPoint, nbPoints, result), nbPoints, result);

    const det =
      x[c] * (y[a] - y[b]) + x[a] * (y[b] - y[c]) + x[b] * (y[c] - y[a]);

    const leftTurn = det >= 0;

    if (leftTurn) {
      currentPoint = b;
    } else {
      result[b] = false;
      currentPoint = moveBack(currentPoint, nbPoints, result);
    }
    if (c === nbPoints) break;
  }

  return result
    .map((item, index) => (item === false ? false : index))
    .filter((item) => item !== false);
}

/**
 * @param {number} currentPoint - The index of the current point to make the move
 * @param {number} nbPoints - The total number of points in the array
 * @param {Array} vector - The array with the points
 * @return {number} the index of the point after the move
 * @private
 */

function moveBack(currentPoint, nbPoints, vector) {
  let counter = currentPoint - 1;
  while (vector[counter] === false) counter--;
  return currentPoint === 0 ? nbPoints : counter;
}

function moveOn(currentPoint, nbPoints, vector) {
  let counter = currentPoint + 1;
  while (vector[counter] === false) counter++;
  return currentPoint === nbPoints ? 0 : counter;
}

/**
 * Performs a global optimization of required parameters
 * It will return an object containing:
 * - `minFunctionValue`: The minimum value found for the objetive function
 * - `optima`: Array of Array of values for all the variables where the function reach its minimum value
 * - `iterations`: Number of iterations performed in the process
 * - `finalState`: Internal state allowing to continue optimization (initialState)
 * @param {function} objectiveFunction Function to evaluate. It should accept an array of variables
 * @param {Array} lowerBoundaries Array containing for each variable the lower boundary
 * @param {Array} upperBoundaries Array containing for each variable the higher boundary
 * @param {Object} [options={}]
 * @param {number} [options.iterations] - Number of iterations.
 * @param {number} [options.epsilon] - Tolerance to choose best current value.
 * @param {number} [options.tolerance] - Minimum tollerance of the function.
 * @param {number} [options.tolerance2] - Minimum tollerance of the function.
 * @param {Object} [options.initialState={}}] - finalState of previous optimization.
 * @return {Object} {finalState, iterations, minFunctionValue}
 * */

function direct(
  objectiveFunction,
  lowerBoundaries,
  upperBoundaries,
  options = {},
) {
  const {
    iterations = 50,
    epsilon = 1e-4,
    tolerance = 1e-16,
    tolerance2 = 1e-12,
    initialState = {},
  } = options;

  if (
    objectiveFunction === undefined ||
    lowerBoundaries === undefined ||
    upperBoundaries === undefined
  ) {
    throw new RangeError('There is something undefined');
  }

  lowerBoundaries = new Float64Array(lowerBoundaries);
  upperBoundaries = new Float64Array(upperBoundaries);

  if (lowerBoundaries.length !== upperBoundaries.length) {
    throw new Error(
      'Lower bounds and Upper bounds for x are not of the same length',
    );
  }

  //-------------------------------------------------------------------------
  //                        STEP 1. Initialization
  //-------------------------------------------------------------------------
  let n = lowerBoundaries.length;
  let diffBorders = upperBoundaries.map((x, i) => x - lowerBoundaries[i]);

  let {
    numberOfRectangles = 0,
    totalIterations = 0,
    unitaryCoordinates = [new Float64Array(n).fill(0.5)],
    middlePoint = new Float64Array(n).map((value, index) => {
      return (
        lowerBoundaries[index] +
        unitaryCoordinates[0][index] * diffBorders[index]
      );
    }),
    bestCurrentValue = objectiveFunction(middlePoint),
    fCalls = 1,
    smallerDistance = 0,
    edgeSizes = [new Float64Array(n).fill(0.5)],
    diagonalDistances = [Math.sqrt(n * Math.pow(0.5, 2))],
    functionValues = [bestCurrentValue],
    differentDistances = diagonalDistances,
    smallerValuesByDistance = [bestCurrentValue],
    choiceLimit = undefined,
  } = initialState;
  if (
    initialState.originalCoordinates &&
    initialState.originalCoordinates.length > 0
  ) {
    bestCurrentValue = mlSpectraProcessing.xMinValue(functionValues);
    choiceLimit =
      epsilon * Math.abs(bestCurrentValue) > 1e-8
        ? epsilon * Math.abs(bestCurrentValue)
        : 1e-8;

    smallerDistance = getMinIndex(
      functionValues,
      diagonalDistances,
      choiceLimit,
      bestCurrentValue,
    );

    unitaryCoordinates = initialState.originalCoordinates.slice();
    for (let j = 0; j < unitaryCoordinates.length; j++) {
      for (let i = 0; i < lowerBoundaries.length; i++) {
        unitaryCoordinates[j][i] =
          (unitaryCoordinates[j][i] - lowerBoundaries[i]) / diffBorders[i];
      }
    }
  }

  let iteration = 0;
  //-------------------------------------------------------------------------
  //                          Iteration loop
  //-------------------------------------------------------------------------

  while (iteration < iterations) {
    //----------------------------------------------------------------------
    //  STEP 2. Identify the set S of all potentially optimal rectangles
    //----------------------------------------------------------------------

    let S1 = [];
    let idx = differentDistances.findIndex(
      // eslint-disable-next-line no-loop-func
      (e) => e === diagonalDistances[smallerDistance],
    );
    let counter = 0;
    for (let i = idx; i < differentDistances.length; i++) {
      for (let f = 0; f < functionValues.length; f++) {
        if (
          (functionValues[f] === smallerValuesByDistance[i]) &
          (diagonalDistances[f] === differentDistances[i])
        ) {
          S1[counter++] = f;
        }
      }
    }

    let optimumValuesIndex, S3;
    if (differentDistances.length - idx > 1) {
      let a1 = diagonalDistances[smallerDistance];
      let b1 = functionValues[smallerDistance];
      let a2 = differentDistances[differentDistances.length - 1];
      let b2 = smallerValuesByDistance[differentDistances.length - 1];
      let slope = (b2 - b1) / (a2 - a1);
      let constant = b1 - slope * a1;
      let S2 = new Uint32Array(counter);
      counter = 0;
      for (let i = 0; i < S2.length; i++) {
        let j = S1[i];
        if (
          functionValues[j] <=
          slope * diagonalDistances[j] + constant + tolerance2
        ) {
          S2[counter++] = j;
        }
      }

      let xHull = [];
      let yHull = [];
      for (let i = 0; i < counter; i++) {
        xHull.push(diagonalDistances[S2[i]]);
        yHull.push(functionValues[S2[i]]);
      }

      let lowerIndexHull = antiLowerConvexHull(xHull, yHull);

      S3 = [];
      for (let i = 0; i < lowerIndexHull.length; i++) {
        S3.push(S2[lowerIndexHull[i]]);
      }
    } else {
      S3 = S1.slice(0, counter);
    }
    optimumValuesIndex = S3;
    //--------------------------------------------------------------
    // STEPS 3,5: Select any rectangle j in S
    //--------------------------------------------------------------
    for (let k = 0; k < optimumValuesIndex.length; k++) {
      let j = optimumValuesIndex[k];
      let largerSide = mlSpectraProcessing.xMaxValue(edgeSizes[j]);
      let largeSidesIndex = new Uint32Array(edgeSizes[j].length);
      counter = 0;
      for (let i = 0; i < edgeSizes[j].length; i++) {
        if (Math.abs(edgeSizes[j][i] - largerSide) < tolerance) {
          largeSidesIndex[counter++] = i;
        }
      }
      let delta = (2 * largerSide) / 3;
      let bestFunctionValues = [];
      for (let r = 0; r < counter; r++) {
        let i = largeSidesIndex[r];
        let firstMiddleCenter = unitaryCoordinates[j].slice();
        let secondMiddleCenter = unitaryCoordinates[j].slice();
        firstMiddleCenter[i] += delta;
        secondMiddleCenter[i] -= delta;
        let firstMiddleValue = new Float64Array(firstMiddleCenter.length);
        let secondMiddleValue = new Float64Array(secondMiddleCenter.length);
        for (let i = 0; i < firstMiddleCenter.length; i++) {
          firstMiddleValue[i] =
            lowerBoundaries[i] + firstMiddleCenter[i] * diffBorders[i];
          secondMiddleValue[i] =
            lowerBoundaries[i] + secondMiddleCenter[i] * diffBorders[i];
        }
        let firstMinValue = objectiveFunction(firstMiddleValue);
        let secondMinValue = objectiveFunction(secondMiddleValue);
        fCalls += 2;
        bestFunctionValues.push({
          minValue: Math.min(firstMinValue, secondMinValue),
          index: r,
        });
        // [Math.min(firstMinValue, secondMinValue), r];
        unitaryCoordinates.push(firstMiddleCenter, secondMiddleCenter);
        functionValues.push(firstMinValue, secondMinValue);
      }

      let b = bestFunctionValues.sort((a, b) => a.minValue - b.minValue);
      for (let r = 0; r < counter; r++) {
        let u = largeSidesIndex[b[r].index];
        let ix1 = numberOfRectangles + 2 * (b[r].index + 1) - 1;
        let ix2 = numberOfRectangles + 2 * (b[r].index + 1);
        edgeSizes[j][u] = delta / 2;
        edgeSizes[ix1] = edgeSizes[j].slice();
        edgeSizes[ix2] = edgeSizes[j].slice();
        diagonalDistances[j] = mlSpectraProcessing.xNorm(edgeSizes[j]);
        diagonalDistances[ix1] = diagonalDistances[j];
        diagonalDistances[ix2] = diagonalDistances[j];
      }
      numberOfRectangles += 2 * counter;
    }

    //--------------------------------------------------------------
    //                  Update
    //--------------------------------------------------------------

    bestCurrentValue = mlSpectraProcessing.xMinValue(functionValues);

    choiceLimit =
      epsilon * Math.abs(bestCurrentValue) > 1e-8
        ? epsilon * Math.abs(bestCurrentValue)
        : 1e-8;

    smallerDistance = getMinIndex(
      functionValues,
      diagonalDistances,
      choiceLimit,
      bestCurrentValue);

    differentDistances = Array.from(new Set(diagonalDistances));
    differentDistances = differentDistances.sort((a, b) => a - b);

    smallerValuesByDistance = [];
    for (let i = 0; i < differentDistances.length; i++) {
      let minIndex;
      let minValue = Number.POSITIVE_INFINITY;
      for (let k = 0; k < diagonalDistances.length; k++) {
        if (diagonalDistances[k] === differentDistances[i]) {
          if (functionValues[k] < minValue) {
            minValue = functionValues[k];
            minIndex = k;
          }
        }
      }
      smallerValuesByDistance.push(functionValues[minIndex]);
    }
    for (let j = 0; j < functionValues.length; j++) {
      if (functionValues[j] === bestCurrentValue) {
        let temp = [];
        for (let i = 0; i < lowerBoundaries.length; i++) {
          temp.push(
            lowerBoundaries[i] + unitaryCoordinates[j][i] * diffBorders[i],
          );
        }
      }
    }
    iteration += 1;
  }
  //--------------------------------------------------------------
  //                  Saving results
  //--------------------------------------------------------------

  let result = {};
  result.minFunctionValue = bestCurrentValue;
  result.iterations = iteration;
  let originalCoordinates = [];
  for (let j = 0; j < numberOfRectangles + 1; j++) {
    let pair = [];
    for (let i = 0; i < lowerBoundaries.length; i++) {
      pair.push(lowerBoundaries[i] + unitaryCoordinates[j][i] * diffBorders[i]);
    }
    originalCoordinates.push(pair);
  }

  result.finalState = {
    numberOfRectangles,
    totalIterations: (totalIterations += iterations),
    originalCoordinates,
    middlePoint,
    fCalls,
    smallerDistance,
    edgeSizes,
    diagonalDistances,
    functionValues,
    differentDistances,
    smallerValuesByDistance,
    choiceLimit,
  };

  let minimizer = [];
  for (let i = 0; i < functionValues.length; i++) {
    if (functionValues[i] === bestCurrentValue) {
      minimizer.push(originalCoordinates[i]);
    }
  }

  result.optima = minimizer;
  return result;
}

function getMinIndex(
  functionValues,
  diagonalDistances,
  choiceLimit,
  bestCurrentValue,
) {
  let item = [];
  for (let i = 0; i < functionValues.length; i++) {
    item[i] =
      Math.abs(functionValues[i] - (bestCurrentValue + choiceLimit)) /
      diagonalDistances[i];
  }
  const min = mlSpectraProcessing.xMinValue(item);
  let result = item.findIndex((x) => x === min);
  return result;
}

module.exports = direct;

},{"ml-spectra-processing":208}],156:[function(require,module,exports){
'use strict';

/**
 * @class DisjointSet
 */
class DisjointSet {
    constructor() {
        this.nodes = new Map();
    }

    /**
     * Adds an element as a new set
     * @param {*} value
     * @return {DisjointSetNode} Object holding the element
     */
    add(value) {
        var node = this.nodes.get(value);
        if (!node) {
            node = new DisjointSetNode(value);
            this.nodes.set(value, node);
        }
        return node;
    }

    /**
     * Merges the sets that contain x and y
     * @param {DisjointSetNode} x
     * @param {DisjointSetNode} y
     */
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        if (rootX === rootY) {
            return;
        }
        if (rootX.rank < rootY.rank) {
            rootX.parent = rootY;
        } else if (rootX.rank > rootY.rank) {
            rootY.parent = rootX;
        } else {
            rootY.parent = rootX;
            rootX.rank++;
        }
    }

    /**
     * Finds and returns the root node of the set that contains node
     * @param {DisjointSetNode} node
     * @return {DisjointSetNode}
     */
    find(node) {
        var rootX = node;
        while (rootX.parent !== null) {
            rootX = rootX.parent;
        }
        var toUpdateX = node;
        while (toUpdateX.parent !== null) {
            var toUpdateParent = toUpdateX;
            toUpdateX = toUpdateX.parent;
            toUpdateParent.parent = rootX;
        }
        return rootX;
    }

    /**
     * Returns true if x and y belong to the same set
     * @param {DisjointSetNode} x
     * @param {DisjointSetNode} y
     */
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
}

module.exports = DisjointSet;

function DisjointSetNode(value) {
    this.value = value;
    this.parent = null;
    this.rank = 0;
}

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function squaredEuclidean(p, q) {
    let d = 0;
    for (let i = 0; i < p.length; i++) {
        d += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return d;
}
exports.squaredEuclidean = squaredEuclidean;
function euclidean(p, q) {
    return Math.sqrt(squaredEuclidean(p, q));
}
exports.euclidean = euclidean;

},{}],158:[function(require,module,exports){
'use strict';

/**
 * Computes a distance/similarity matrix given an array of data and a distance/similarity function.
 * @param {Array} data An array of data
 * @param {function} distanceFn  A function that accepts two arguments and computes a distance/similarity between them
 * @return {Array<Array>} The distance/similarity matrix. The matrix is square and has a size equal to the length of
 * the data array
 */
function distanceMatrix(data, distanceFn) {
  const result = getMatrix(data.length);

  // Compute upper distance matrix
  for (let i = 0; i < data.length; i++) {
    for (let j = 0; j <= i; j++) {
      result[i][j] = distanceFn(data[i], data[j]);
      result[j][i] = result[i][j];
    }
  }

  return result;
}

function getMatrix(size) {
  const matrix = [];
  for (let i = 0; i < size; i++) {
    const row = [];
    matrix.push(row);
    for (let j = 0; j < size; j++) {
      row.push(0);
    }
  }
  return matrix;
}

module.exports = distanceMatrix;

},{}],159:[function(require,module,exports){
'use strict'

var FFT = require('./fftlib');

var FFTUtils= {
    DEBUG : false,

    /**
     * Calculates the inverse of a 2D Fourier transform
     *
     * @param ft
     * @param ftRows
     * @param ftCols
     * @return
     */
    ifft2DArray : function(ft, ftRows, ftCols){
        var tempTransform = new Array(ftRows * ftCols);
        var nRows = ftRows / 2;
        var nCols = (ftCols - 1) * 2;
        // reverse transform columns
        FFT.init(nRows);
        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};
        for (var iCol = 0; iCol < ftCols; iCol++) {
            for (var iRow = nRows - 1; iRow >= 0; iRow--) {
                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];
                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];
            }
            //Unnormalized inverse transform
            FFT.bt(tmpCols.re, tmpCols.im);
            for (var iRow = nRows - 1; iRow >= 0; iRow--) {
                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];
                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
            }
        }

        // reverse row transform
        var finalTransform = new Array(nRows * nCols);
        FFT.init(nCols);
        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};
        var scale = nCols * nRows;
        for (var iRow = 0; iRow < ftRows; iRow += 2) {
            tmpRows.re[0] = tempTransform[iRow * ftCols];
            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];
            for (var iCol = 1; iCol < ftCols; iCol++) {
                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];
                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];
                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];
                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];
            }
            //Unnormalized inverse transform
            FFT.bt(tmpRows.re, tmpRows.im);

            var indexB = (iRow / 2) * nCols;
            for (var iCol = nCols - 1; iCol >= 0; iCol--) {
                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;
            }
        }
        return finalTransform;
    },
    /**
     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is
     * assumed that both nRows and nCols are a power of two
     *
     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the
     * even rows contain the real part and the odd rows the imaginary part of the
     * transform
     * @param data
     * @param nRows
     * @param nCols
     * @return
     */
    fft2DArray:function(data, nRows, nCols, opt) {
        var options = Object.assign({},{inplace:true})
        var ftCols = (nCols / 2 + 1);
        var ftRows = nRows * 2;
        var tempTransform = new Array(ftRows * ftCols);
        FFT.init(nCols);
        // transform rows
        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};
        var row1 = {re: new Array(nCols), im: new Array(nCols)}
        var row2 = {re: new Array(nCols), im: new Array(nCols)}
        var index, iRow0, iRow1, iRow2, iRow3;
        for (var iRow = 0; iRow < nRows / 2; iRow++) {
            index = (iRow * 2) * nCols;
            tmpRows.re = data.slice(index, index + nCols);

            index = (iRow * 2 + 1) * nCols;
            tmpRows.im = data.slice(index, index + nCols);

            FFT.fft1d(tmpRows.re, tmpRows.im);

            this.reconstructTwoRealFFT(tmpRows, row1, row2);
            //Now lets put back the result into the output array
            iRow0 = (iRow * 4) * ftCols;
            iRow1 = (iRow * 4 + 1) * ftCols;
            iRow2 = (iRow * 4 + 2) * ftCols;
            iRow3 = (iRow * 4 + 3) * ftCols;
            for (var k = ftCols - 1; k >= 0; k--) {
                tempTransform[iRow0 + k] = row1.re[k];
                tempTransform[iRow1 + k] = row1.im[k];
                tempTransform[iRow2 + k] = row2.re[k];
                tempTransform[iRow3 + k] = row2.im[k];
            }
        }

        //console.log(tempTransform);
        row1 = null;
        row2 = null;
        // transform columns
        var finalTransform = new Array(ftRows * ftCols);

        FFT.init(nRows);
        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};
        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {
            for (var iRow = nRows - 1; iRow >= 0; iRow--) {
                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];
                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];
                //TODO Chech why this happens
                if(isNaN(tmpCols.re[iRow])){
                    tmpCols.re[iRow]=0;
                }
                if(isNaN(tmpCols.im[iRow])){
                    tmpCols.im[iRow]=0;
                }
            }
            FFT.fft1d(tmpCols.re, tmpCols.im);
            for (var iRow = nRows - 1; iRow >= 0; iRow--) {
                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];
                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
            }
        }

        //console.log(finalTransform);
        return finalTransform;

    },
    /**
     *
     * @param fourierTransform
     * @param realTransform1
     * @param realTransform2
     *
     * Reconstructs the individual Fourier transforms of two simultaneously
     * transformed series. Based on the Symmetry relationships (the asterisk
     * denotes the complex conjugate)
     *
     * F_{N-n} = F_n^{*} for a purely real f transformed to F
     *
     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G
     *
     */
    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {
        var length = fourierTransform.re.length;

        // the components n=0 are trivial
        realTransform1.re[0] = fourierTransform.re[0];
        realTransform1.im[0] = 0.0;
        realTransform2.re[0] = fourierTransform.im[0];
        realTransform2.im[0] = 0.0;
        var rm, rp, im, ip, j;
        for (var i = length / 2; i > 0; i--) {
            j = length - i;
            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);
            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);
            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);
            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);
            realTransform1.re[i] = rp;
            realTransform1.im[i] = im;
            realTransform1.re[j] = rp;
            realTransform1.im[j] = -im;
            realTransform2.re[i] = ip;
            realTransform2.im[i] = -rm;
            realTransform2.re[j] = ip;
            realTransform2.im[j] = rm;
        }
    },

    /**
     * In place version of convolute 2D
     *
     * @param ftSignal
     * @param ftFilter
     * @param ftRows
     * @param ftCols
     * @return
     */
    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {
        var re, im;
        for (var iRow = 0; iRow < ftRows / 2; iRow++) {
            for (var iCol = 0; iCol < ftCols; iCol++) {
                //
                re = ftSignal[(iRow * 2) * ftCols + iCol]
                    * ftFilter[(iRow * 2) * ftCols + iCol]
                    - ftSignal[(iRow * 2 + 1) * ftCols + iCol]
                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol];
                im = ftSignal[(iRow * 2) * ftCols + iCol]
                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol]
                    + ftSignal[(iRow * 2 + 1) * ftCols + iCol]
                    * ftFilter[(iRow * 2) * ftCols + iCol];
                //
                ftSignal[(iRow * 2) * ftCols + iCol] = re;
                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;
            }
        }
    },
    /**
     *
     * @param data
     * @param kernel
     * @param nRows
     * @param nCols
     * @returns {*}
     */
    convolute:function(data, kernel, nRows, nCols, opt) {
        var ftSpectrum = new Array(nCols * nRows);
        for (var i = 0; i<nRows * nCols; i++) {
            ftSpectrum[i] = data[i];
        }

        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);


        var dimR = kernel.length;
        var dimC = kernel[0].length;
        var ftFilterData = new Array(nCols * nRows);
        for(var i = 0; i < nCols * nRows; i++) {
            ftFilterData[i] = 0;
        }

        var iRow, iCol;
        var shiftR = Math.floor((dimR - 1) / 2);
        var shiftC = Math.floor((dimC - 1) / 2);
        for (var ir = 0; ir < dimR; ir++) {
            iRow = (ir - shiftR + nRows) % nRows;
            for (var ic = 0; ic < dimC; ic++) {
                iCol = (ic - shiftC + nCols) % nCols;
                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];
            }
        }
        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);

        var ftRows = nRows * 2;
        var ftCols = nCols / 2 + 1;
        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);

        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);
    },


    toRadix2:function(data, nRows, nCols) {
        var i, j, irow, icol;
        var cols = nCols, rows = nRows, prows=0, pcols=0;
        if(!(nCols !== 0 && (nCols & (nCols - 1)) === 0)) {
            //Then we have to make a pading to next radix2
            cols = 0;
            while((nCols>>++cols)!=0);
            cols=1<<cols;
            pcols = cols-nCols;
        }
        if(!(nRows !== 0 && (nRows & (nRows - 1)) === 0)) {
            //Then we have to make a pading to next radix2
            rows = 0;
            while((nRows>>++rows)!=0);
            rows=1<<rows;
            prows = (rows-nRows)*cols;
        }
        if(rows==nRows&&cols==nCols)//Do nothing. Returns the same input!!! Be careful
            return {data:data, rows:nRows, cols:nCols};

        var output = new Array(rows*cols);
        var shiftR = Math.floor((rows-nRows)/2)-nRows;
        var shiftC = Math.floor((cols-nCols)/2)-nCols;

        for( i = 0; i < rows; i++) {
            irow = i*cols;
            icol = ((i-shiftR) % nRows) * nCols;
            for( j = 0; j < cols; j++) {
                output[irow+j] = data[(icol+(j-shiftC) % nCols) ];
            }
        }
        return {data:output, rows:rows, cols:cols};
    },

    /**
     * Crop the given matrix to fit the corresponding number of rows and columns
     */
    crop:function(data, rows, cols, nRows, nCols, opt) {

        if(rows == nRows && cols == nCols)//Do nothing. Returns the same input!!! Be careful
            return data;

        var options = Object.assign({}, opt);

        var output = new Array(nCols*nRows);

        var shiftR = Math.floor((rows-nRows)/2);
        var shiftC = Math.floor((cols-nCols)/2);
        var destinyRow, sourceRow, i, j;
        for( i = 0; i < nRows; i++) {
            destinyRow = i*nCols;
            sourceRow = (i+shiftR)*cols;
            for( j = 0;j < nCols; j++) {
                output[destinyRow+j] = data[sourceRow+(j+shiftC)];
            }
        }

        return output;
    }
}

module.exports = FFTUtils;

},{"./fftlib":160}],160:[function(require,module,exports){
/**
 * Fast Fourier Transform module
 * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)
 */
var FFT = (function(){
  var FFT;  
  
  if(typeof exports !== 'undefined') {
    FFT = exports;   // for CommonJS
  } else {
    FFT = {};
  }
  
  var version = {
    release: '0.3.0',
    date: '2013-03'
  };
  FFT.toString = function() {
    return "version " + version.release + ", released " + version.date;
  };

  // core operations
  var _n = 0,          // order
      _bitrev = null,  // bit reversal table
      _cstb = null;    // sin/cos table

  var core = {
    init : function(n) {
      if(n !== 0 && (n & (n - 1)) === 0) {
        _n = n;
        core._initArray();
        core._makeBitReversalTable();
        core._makeCosSinTable();
      } else {
        throw new Error("init: radix-2 required");
      }
    },
    // 1D-FFT
    fft1d : function(re, im) {
      core.fft(re, im, 1);
    },
    // 1D-IFFT
    ifft1d : function(re, im) {
      var n = 1/_n;
      core.fft(re, im, -1);
      for(var i=0; i<_n; i++) {
        re[i] *= n;
        im[i] *= n;
      }
    },
     // 1D-IFFT
    bt1d : function(re, im) {
      core.fft(re, im, -1);
    },
    // 2D-FFT Not very useful if the number of rows have to be equal to cols
    fft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x1=0; x1<_n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        core.fft1d(tre, tim);
        for(var x2=0; x2<_n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<_n; x++) {
        for(var y1=0; y1<_n; y1++) {
          i = x + y1*_n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        core.fft1d(tre, tim);
        for(var y2=0; y2<_n; y2++) {
          i = x + y2*_n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // 2D-IFFT
    ifft2d : function(re, im) {
      var tre = [],
          tim = [],
          i = 0;
      // x-axis
      for(var y=0; y<_n; y++) {
        i = y*_n;
        for(var x1=0; x1<_n; x1++) {
          tre[x1] = re[x1 + i];
          tim[x1] = im[x1 + i];
        }
        core.ifft1d(tre, tim);
        for(var x2=0; x2<_n; x2++) {
          re[x2 + i] = tre[x2];
          im[x2 + i] = tim[x2];
        }
      }
      // y-axis
      for(var x=0; x<_n; x++) {
        for(var y1=0; y1<_n; y1++) {
          i = x + y1*_n;
          tre[y1] = re[i];
          tim[y1] = im[i];
        }
        core.ifft1d(tre, tim);
        for(var y2=0; y2<_n; y2++) {
          i = x + y2*_n;
          re[i] = tre[y2];
          im[i] = tim[y2];
        }
      }
    },
    // core operation of FFT
    fft : function(re, im, inv) {
      var d, h, ik, m, tmp, wr, wi, xr, xi,
          n4 = _n >> 2;
      // bit reversal
      for(var l=0; l<_n; l++) {
        m = _bitrev[l];
        if(l < m) {
          tmp = re[l];
          re[l] = re[m];
          re[m] = tmp;
          tmp = im[l];
          im[l] = im[m];
          im[m] = tmp;
        }
      }
      // butterfly operation
      for(var k=1; k<_n; k<<=1) {
        h = 0;
        d = _n/(k << 1);
        for(var j=0; j<k; j++) {
          wr = _cstb[h + n4];
          wi = inv*_cstb[h];
          for(var i=j; i<_n; i+=(k<<1)) {
            ik = i + k;
            xr = wr*re[ik] + wi*im[ik];
            xi = wr*im[ik] - wi*re[ik];
            re[ik] = re[i] - xr;
            re[i] += xr;
            im[ik] = im[i] - xi;
            im[i] += xi;
          }
          h += d;
        }
      }
    },
    // initialize the array (supports TypedArray)
    _initArray : function() {
      if(typeof Uint32Array !== 'undefined') {
        _bitrev = new Uint32Array(_n);
      } else {
        _bitrev = [];
      }
      if(typeof Float64Array !== 'undefined') {
        _cstb = new Float64Array(_n*1.25);
      } else {
        _cstb = [];
      }
    },
    // zero padding
    _paddingZero : function() {
      // TODO
    },
    // makes bit reversal table
    _makeBitReversalTable : function() {
      var i = 0,
          j = 0,
          k = 0;
      _bitrev[0] = 0;
      while(++i < _n) {
        k = _n >> 1;
        while(k <= j) {
          j -= k;
          k >>= 1;
        }
        j += k;
        _bitrev[i] = j;
      }
    },
    // makes trigonometiric function table
    _makeCosSinTable : function() {
      var n2 = _n >> 1,
          n4 = _n >> 2,
          n8 = _n >> 3,
          n2p4 = n2 + n4,
          t = Math.sin(Math.PI/_n),
          dc = 2*t*t,
          ds = Math.sqrt(dc*(2 - dc)),
          c = _cstb[n4] = 1,
          s = _cstb[0] = 0;
      t = 2*dc;
      for(var i=1; i<n8; i++) {
        c -= dc;
        dc += t*c;
        s += ds;
        ds -= t*s;
        _cstb[i] = s;
        _cstb[n4 - i] = c;
      }
      if(n8 !== 0) {
        _cstb[n8] = Math.sqrt(0.5);
      }
      for(var j=0; j<n4; j++) {
        _cstb[n2 - j]  = _cstb[j];
      }
      for(var k=0; k<n2p4; k++) {
        _cstb[k + n2] = -_cstb[k];
      }
    }
  };
  // aliases (public APIs)
  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];
  for(var i=0; i<apis.length; i++) {
    FFT[apis[i]] = core[apis[i]];
  }
  FFT.bt = core.bt1d;
  FFT.fft = core.fft1d;
  FFT.ifft = core.ifft1d;
  
  return FFT;
}).call(this);

},{}],161:[function(require,module,exports){
'use strict';

exports.FFTUtils = require("./FFTUtils");
exports.FFT = require('./fftlib');

},{"./FFTUtils":159,"./fftlib":160}],162:[function(require,module,exports){
'use strict';

var mlMatrix = require('ml-matrix');

/**
 * Algorithm that finds the shortest distance from one node to the other
 * @param {Matrix} adjMatrix - A squared adjacency matrix
 * @return {Matrix} - Distance from a node to the other, -1 if the node is unreachable
 */
function floydWarshall(adjMatrix) {
  if (mlMatrix.Matrix.isMatrix(adjMatrix) && adjMatrix.columns !== adjMatrix.rows) {
    throw new TypeError('The adjacency matrix should be squared');
  }
  const numVertices = adjMatrix.columns;
  let distMatrix = new mlMatrix.Matrix(numVertices, numVertices);
  distMatrix.apply((row, column) => {
    // principal diagonal is 0
    if (row === column) {
      distMatrix.set(row, column, 0);
    } else {
      let val = adjMatrix.get(row, column);

      if (val || Object.is(val, -0)) {
        // edges values remain the same
        distMatrix.set(row, column, val);
      } else {
        // 0 values become infinity
        distMatrix.set(row, column, Number.POSITIVE_INFINITY);
      }
    }
  });

  for (let k = 0; k < numVertices; ++k) {
    for (let i = 0; i < numVertices; ++i) {
      for (let j = 0; j < numVertices; ++j) {
        let dist = distMatrix.get(i, k) + distMatrix.get(k, j);
        if (distMatrix.get(i, j) > dist) {
          distMatrix.set(i, j, dist);
        }
      }
    }
  }

  // When there's no connection the value is -1
  distMatrix.apply((row, column) => {
    if (distMatrix.get(row, column) === Number.POSITIVE_INFINITY) {
      distMatrix.set(row, column, -1);
    }
  });
  return distMatrix;
}

exports.floydWarshall = floydWarshall;

},{"ml-matrix":186}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gsd = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_savitzky_golay_generalized_1 = require("ml-savitzky-golay-generalized");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const optimizeTop_1 = require("./utils/optimizeTop");
/**
 * Global spectra deconvolution
 * @param  data - Object data with x and y arrays. Values in x has to be growing
 * @param {number} [options.broadRatio = 0.00] - If `broadRatio` is higher than 0, then all the peaks which second derivative
 * smaller than `broadRatio * maxAbsSecondDerivative` will be marked with the soft mask equal to true.

 */
function gsd(data, options = {}) {
    let { sgOptions = {
        windowSize: 9,
        polynomial: 3,
    }, noiseLevel, smoothY = false, maxCriteria = true, minMaxRatio = 0.00025, realTopDetection = false, } = options;
    let { x, y } = data;
    if ((0, ml_spectra_processing_1.xIsMonotonic)(x) !== 1) {
        throw new Error('GSD only accepts monotone increasing x values');
    }
    //rescale;
    y = y.slice();
    // If the max difference between delta x is less than 5%, then,
    // we can assume it to be equally spaced variable
    let equallySpaced = (0, ml_spectra_processing_1.xIsEquallySpaced)(x);
    if (noiseLevel === undefined) {
        if (equallySpaced) {
            const noiseInfo = (0, ml_spectra_processing_1.xNoiseStandardDeviation)(y);
            if (maxCriteria) {
                noiseLevel = noiseInfo.median + 1.5 * noiseInfo.sd;
            }
            else {
                noiseLevel = -noiseInfo.median + 1.5 * noiseInfo.sd;
            }
        }
        else {
            noiseLevel = 0;
        }
    }
    else if (!maxCriteria) {
        noiseLevel *= -1;
    }
    if (!maxCriteria) {
        for (let i = 0; i < y.length; i++) {
            y[i] *= -1;
        }
    }
    if (noiseLevel !== undefined) {
        for (let i = 0; i < y.length; i++) {
            if (y[i] < noiseLevel) {
                y[i] = noiseLevel;
            }
        }
    }
    let yData = y;
    let dY, ddY;
    const { windowSize, polynomial } = sgOptions;
    if (equallySpaced) {
        if (smoothY) {
            yData = (0, ml_savitzky_golay_generalized_1.sgg)(y, x[1] - x[0], {
                windowSize,
                polynomial,
                derivative: 0,
            });
        }
        dY = (0, ml_savitzky_golay_generalized_1.sgg)(y, x[1] - x[0], {
            windowSize,
            polynomial,
            derivative: 1,
        });
        ddY = (0, ml_savitzky_golay_generalized_1.sgg)(y, x[1] - x[0], {
            windowSize,
            polynomial,
            derivative: 2,
        });
    }
    else {
        if (smoothY) {
            yData = (0, ml_savitzky_golay_generalized_1.sgg)(y, x, {
                windowSize,
                polynomial,
                derivative: 0,
            });
        }
        dY = (0, ml_savitzky_golay_generalized_1.sgg)(y, x, {
            windowSize,
            polynomial,
            derivative: 1,
        });
        ddY = (0, ml_savitzky_golay_generalized_1.sgg)(y, x, {
            windowSize,
            polynomial,
            derivative: 2,
        });
    }
    const minY = (0, ml_spectra_processing_1.xMinValue)(yData);
    const maxY = (0, ml_spectra_processing_1.xMaxValue)(yData);
    if (minY > maxY || minY === maxY)
        return [];
    const yThreshold = minY + (maxY - minY) * minMaxRatio;
    const dX = x[1] - x[0];
    let lastMax = null;
    let lastMin = null;
    let minddY = [];
    let intervalL = [];
    let intervalR = [];
    // By the intermediate value theorem We cannot find 2 consecutive maximum or minimum
    for (let i = 1; i < yData.length - 1; ++i) {
        if ((dY[i] < dY[i - 1] && dY[i] <= dY[i + 1]) ||
            (dY[i] <= dY[i - 1] && dY[i] < dY[i + 1])) {
            lastMin = {
                x: x[i],
                index: i,
            };
            if (dX > 0 && lastMax !== null) {
                intervalL.push(lastMax);
                intervalR.push(lastMin);
            }
        }
        // Maximum in first derivative
        if ((dY[i] >= dY[i - 1] && dY[i] > dY[i + 1]) ||
            (dY[i] > dY[i - 1] && dY[i] >= dY[i + 1])) {
            lastMax = {
                x: x[i],
                index: i,
            };
            if (dX < 0 && lastMin !== null) {
                intervalL.push(lastMax);
                intervalR.push(lastMin);
            }
        }
        // Minimum in second derivative
        if (ddY[i] < ddY[i - 1] && ddY[i] < ddY[i + 1]) {
            minddY.push(i);
        }
    }
    let lastK = -1;
    const peaks = [];
    for (const minddYIndex of minddY) {
        let deltaX = x[minddYIndex];
        let possible = -1;
        let k = lastK + 1;
        let minDistance = Number.POSITIVE_INFINITY;
        let currentDistance = 0;
        while (possible === -1 && k < intervalL.length) {
            currentDistance = Math.abs(deltaX - (intervalL[k].x + intervalR[k].x) / 2);
            if (currentDistance < (intervalR[k].x - intervalL[k].x) / 2) {
                possible = k;
                lastK = k;
            }
            ++k;
            // Not getting closer?
            if (currentDistance >= minDistance) {
                break;
            }
            minDistance = currentDistance;
        }
        if (possible !== -1) {
            if (yData[minddYIndex] > yThreshold) {
                let width = Math.abs(intervalR[possible].x - intervalL[possible].x);
                peaks.push({
                    id: (0, uuid_1.v4)(),
                    x: deltaX,
                    y: yData[minddYIndex],
                    width,
                    index: minddYIndex,
                    ddY: ddY[minddYIndex],
                    inflectionPoints: {
                        from: intervalL[possible],
                        to: intervalR[possible],
                    },
                });
            }
        }
    }
    if (realTopDetection) {
        (0, optimizeTop_1.optimizeTop)({ x, y: yData }, peaks);
    }
    peaks.forEach((peak) => {
        if (!maxCriteria) {
            peak.y *= -1;
            peak.ddY = peak.ddY * -1;
        }
    });
    peaks.sort((a, b) => {
        return a.x - b.x;
    });
    return peaks;
}
exports.gsd = gsd;

},{"./utils/optimizeTop":175,"@lukeed/uuid":1,"ml-savitzky-golay-generalized":198,"ml-spectra-processing":208}],167:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./gsd"), exports);
__exportStar(require("./post/optimizePeaks"), exports);
__exportStar(require("./post/optimizePeaksWithLogs"), exports);
__exportStar(require("./post/joinBroadPeaks"), exports);
__exportStar(require("./post/broadenPeaks"), exports);
__exportStar(require("./utils/setShape"), exports);
__exportStar(require("./utils/addMissingShape"), exports);
__exportStar(require("./GSDBroadenPeak"), exports);
__exportStar(require("./GSDPeak"), exports);
__exportStar(require("./GSDPeakOptimized"), exports);

},{"./GSDBroadenPeak":163,"./GSDPeak":164,"./GSDPeakOptimized":165,"./gsd":166,"./post/broadenPeaks":168,"./post/joinBroadPeaks":169,"./post/optimizePeaks":170,"./post/optimizePeaksWithLogs":171,"./utils/addMissingShape":173,"./utils/setShape":176}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadenPeaks = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
/**
 * This method will allow to enlarge peaks while preventing overlap between peaks
 * A typical application in chromatography peak picking.
 * We should not make the hypothesis that x is equidistant
 * Because peaks may not be symmetric after we add 2 properties, from and to.
 * @return {Array} peakList
 */
function broadenPeaks(peakList, options = {}) {
    const { factor = 2, overlap = false } = options;
    const peaks = mapPeaks(peakList, factor);
    if (!overlap) {
        for (let i = 0; i < peaks.length - 1; i++) {
            let peak = peaks[i];
            let nextPeak = peaks[i + 1];
            if (peak.to.x > nextPeak.from.x) {
                // we do it proportional to the width of the peaks
                peak.to.x =
                    (peak.width / (nextPeak.width + peak.width)) * (nextPeak.x - peak.x) +
                        peak.x;
                nextPeak.from.x = peak.to.x;
            }
        }
    }
    for (const peak of peaks) {
        peak.width = peak.to.x - peak.from.x;
        if (peak.shape) {
            const { shape, width } = peak;
            if (shape.fwhm !== undefined) {
                const shapeFct = (0, ml_peak_shape_generator_1.getShape1D)(shape);
                peak.shape.fwhm = shapeFct.widthToFWHM(width);
            }
        }
    }
    return peaks;
}
exports.broadenPeaks = broadenPeaks;
function mapPeaks(peaks, factor) {
    return peaks.map((peak) => {
        const { id, shape } = peak;
        const xFrom = peak.x - (peak.x - peak.inflectionPoints.from.x) * factor;
        const xTo = peak.x + (peak.inflectionPoints.to.x - peak.x) * factor;
        let result = {
            x: peak.x,
            y: peak.y,
            index: peak.index,
            width: xTo - xFrom,
            from: { x: xFrom },
            to: { x: xTo },
        };
        if (id) {
            result = { ...result, id };
        }
        if (shape) {
            result = { ...result, shape };
        }
        return result;
    });
}

},{"ml-peak-shape-generator":187}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinBroadPeaks = void 0;
const uuid_1 = require("@lukeed/uuid");
const addMissingIDs_1 = require("../utils/addMissingIDs");
const addMissingShape_1 = require("../utils/addMissingShape");
const optimizePeaks_1 = require("./optimizePeaks");
function joinBroadPeaks(peakList, options = {}) {
    let { shape = { kind: 'gaussian' }, optimization = { kind: 'lm', options: { timeout: 10 } }, broadWidth = 0.25, broadRatio = 0.0025, } = options;
    let max = 0;
    let maxI = 0;
    let count = 1;
    const broadLines = [];
    if (peakList.length < 2) {
        return (0, addMissingIDs_1.addMissingIDs)((0, addMissingShape_1.addMissingShape)(peakList.map(getGSDPeakOptimizedStructure), { shape }));
    }
    let maxDdy = peakList[0].ddY;
    for (let i = 1; i < peakList.length; i++) {
        if (Math.abs(peakList[i].ddY) > maxDdy)
            maxDdy = Math.abs(peakList[i].ddY);
    }
    const newPeaks = [];
    for (const peak of peakList) {
        if (Math.abs(peak.ddY) <= broadRatio * maxDdy) {
            broadLines.push(peak);
        }
        else {
            newPeaks.push(getGSDPeakOptimizedStructure(peak));
        }
    }
    //@ts-expect-error Push a feke peak
    broadLines.push({ x: Number.MAX_VALUE, y: 0 });
    let candidates = {
        x: [broadLines[0].x],
        y: [broadLines[0].y],
    };
    let indexes = [0];
    for (let i = 1; i < broadLines.length; i++) {
        if (Math.abs(broadLines[i - 1].x - broadLines[i].x) < broadWidth) {
            candidates.x.push(broadLines[i].x);
            candidates.y.push(broadLines[i].y);
            if (broadLines[i].y > max) {
                max = broadLines[i].y;
                maxI = i;
            }
            indexes.push(i);
            count++;
        }
        else {
            if (count > 2) {
                let fitted = (0, optimizePeaks_1.optimizePeaks)(candidates, [
                    {
                        id: (0, uuid_1.v4)(),
                        x: broadLines[maxI].x,
                        y: max,
                        width: candidates.x[0] - candidates.x[candidates.x.length - 1],
                    },
                ], { shape, optimization });
                newPeaks.push(fitted[0]);
            }
            else {
                // Put back the candidates to the peak list
                for (const index of indexes) {
                    newPeaks.push(getGSDPeakOptimizedStructure(broadLines[index]));
                }
            }
            candidates = { x: [broadLines[i].x], y: [broadLines[i].y] };
            indexes = [i];
            max = broadLines[i].y;
            maxI = i;
            count = 1;
        }
    }
    newPeaks.sort((a, b) => {
        return a.x - b.x;
    });
    return (0, addMissingIDs_1.addMissingIDs)(newPeaks, { output: newPeaks });
}
exports.joinBroadPeaks = joinBroadPeaks;
function getGSDPeakOptimizedStructure(peak) {
    const { id, shape, x, y, width } = peak;
    let newPeak = {
        x,
        y,
        width,
        shape,
    };
    if (id)
        newPeak.id = id;
    return newPeak;
}

},{"../utils/addMissingIDs":172,"../utils/addMissingShape":173,"./optimizePeaks":170,"@lukeed/uuid":1}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizePeaks = void 0;
const optimizePeaksWithLogs_1 = require("./optimizePeaksWithLogs");
/**
 * Optimize the position (x), max intensity (y), full width at half maximum (fwhm)
 * and the ratio of gaussian contribution (mu) if it's required. It currently supports three kind of shapes: gaussian, lorentzian and pseudovoigt
 * @param data - An object containing the x and y data to be fitted.
 * @param peakList - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 */
function optimizePeaks(data, peakList, options = {}) {
    return (0, optimizePeaksWithLogs_1.optimizePeaksWithLogs)(data, peakList, options).optimizedPeaks;
}
exports.optimizePeaks = optimizePeaks;

},{"./optimizePeaksWithLogs":171}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizePeaksWithLogs = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const ml_spectra_fitting_1 = require("ml-spectra-fitting");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const addMissingShape_1 = require("../utils/addMissingShape");
const groupPeaks_1 = require("../utils/groupPeaks");
/**
 * Optimize the position (x), max intensity (y), full width at half maximum (fwhm)
 * and the ratio of gaussian contribution (mu) if it's required. It currently supports three kind of shapes: gaussian, lorentzian and pseudovoigt
 * @param data - An object containing the x and y data to be fitted.
 * @param peakList - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 */
function optimizePeaksWithLogs(data, peakList, options = {}) {
    const { fromTo = {}, baseline, shape = { kind: 'gaussian' }, groupingFactor = 1, factorLimits = 2, optimization = {
        kind: 'lm',
        options: {
            timeout: 10,
        },
    }, } = options;
    /*
    The optimization algorithm will take some group of peaks.
    We can not simply optimize everything because there would be too many variables to optimize
    and it would be too time consuming.
  */
    let groups = (0, groupPeaks_1.groupPeaks)(peakList, { factor: groupingFactor });
    let logs = [];
    let results = [];
    groups.forEach((peakGroup) => {
        const start = Date.now();
        // In order to make optimization we will add fwhm and shape on all the peaks
        const peaks = (0, addMissingShape_1.addMissingShape)(peakGroup, { shape });
        const firstPeak = peaks[0];
        const lastPeak = peaks[peaks.length - 1];
        const { from = firstPeak.x - firstPeak.width * factorLimits, to = lastPeak.x + lastPeak.width * factorLimits, } = fromTo;
        const { fromIndex, toIndex } = (0, ml_spectra_processing_1.xGetFromToIndex)(data.x, { from, to });
        const x = data.x instanceof Float64Array
            ? data.x.subarray(fromIndex, toIndex)
            : data.x.slice(fromIndex, toIndex);
        const y = data.y instanceof Float64Array
            ? data.y.subarray(fromIndex, toIndex)
            : data.y.slice(fromIndex, toIndex);
        const log = {
            range: { from, to },
            parameters: optimization,
            groupSize: peakGroup.length,
            time: Date.now() - start,
        };
        if (x.length > 5) {
            const { iterations, error, peaks: optimizedPeaks, } = (0, ml_spectra_fitting_1.optimize)({ x, y }, peaks, {
                shape,
                baseline,
                optimization,
            });
            for (let i = 0; i < peaks.length; i++) {
                results.push({
                    ...optimizedPeaks[i],
                    width: (0, ml_peak_shape_generator_1.getShape1D)(peaks[i].shape).fwhmToWidth(optimizedPeaks[i].shape.fwhm),
                });
            }
            logs.push({
                ...log,
                iterations,
                error,
                message: 'optimization successful',
            });
        }
        else {
            results.push(...peaks);
            logs.push({
                ...log,
                iterations: 0,
                message: 'x length too small for optimization',
            });
        }
    });
    return { logs, optimizedPeaks: results };
}
exports.optimizePeaksWithLogs = optimizePeaksWithLogs;

},{"../utils/addMissingShape":173,"../utils/groupPeaks":174,"ml-peak-shape-generator":187,"ml-spectra-fitting":201,"ml-spectra-processing":208}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMissingIDs = void 0;
const uuid_1 = require("@lukeed/uuid");
const { parse, stringify } = JSON;
function addMissingIDs(peaks, options = {}) {
    const { output = parse(stringify(peaks)) } = options;
    for (const peak of output) {
        if (!('id' in peak)) {
            peak.id = (0, uuid_1.v4)();
        }
    }
    return output;
}
exports.addMissingIDs = addMissingIDs;

},{"@lukeed/uuid":1}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMissingShape = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const { parse, stringify } = JSON;
/**
 * add missing property if it does not exist in the peak,
 * if shape exists but fwhm doesn't, it will be calculated from peak.width
 */
function addMissingShape(peaks, options = {}) {
    const { shape = { kind: 'gaussian' }, output = parse(stringify(peaks)) } = options;
    let shapeInstance = (0, ml_peak_shape_generator_1.getShape1D)(shape);
    return output.map((peak) => {
        if (hasShape(peak)) {
            if (!('fwhm' in peak.shape)) {
                const shapeInstance = (0, ml_peak_shape_generator_1.getShape1D)(peak.shape);
                peak.shape.fwhm = shapeInstance.widthToFWHM(peak.width);
            }
            return peak;
        }
        return {
            ...peak,
            shape: { fwhm: shapeInstance.widthToFWHM(peak.width), ...shape },
        };
    });
}
exports.addMissingShape = addMissingShape;
function hasShape(peak) {
    return 'shape' in peak;
}

},{"ml-peak-shape-generator":187}],174:[function(require,module,exports){
"use strict";
/**
 * Group peaks based on factor
 * In order to group peaks we only need the x and width value. This means that
 * in the current implementation we don't take into account the asymmetry of peaks
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupPeaks = void 0;
function groupPeaks(peaks, options = {}) {
    if (peaks && peaks.length === 0)
        return [];
    const { factor = 1 } = options;
    peaks = JSON.parse(JSON.stringify(peaks));
    peaks.sort((a, b) => a.x - b.x);
    let previousPeak = peaks[0];
    let currentGroup = [previousPeak];
    let groups = [currentGroup];
    for (let i = 1; i < peaks.length; i++) {
        const peak = peaks[i];
        if ((peak.x - previousPeak.x) / ((peak.width + previousPeak.width) / 2) <=
            factor) {
            currentGroup.push(peak);
        }
        else {
            currentGroup = [peak];
            groups.push(currentGroup);
        }
        previousPeak = peak;
    }
    return groups;
}
exports.groupPeaks = groupPeaks;

},{}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeTop = void 0;
/**
 * Correction of the x and y coordinates using a quadratic optimizations with the peak and its 3 closest neighbors to determine the true x,y values of the peak.
 * This process is done in place and is very fast.
 * @param data
 * @param peaks
 */
function optimizeTop(data, peaks) {
    const { x, y } = data;
    for (const peak of peaks) {
        let currentIndex = peak.index;
        // The detected peak could be moved 1 or 2 units to left or right.
        if (y[currentIndex - 1] >= y[currentIndex - 2] &&
            y[currentIndex - 1] >= y[currentIndex]) {
            currentIndex--;
        }
        else if (y[currentIndex + 1] >= y[currentIndex] &&
            y[currentIndex + 1] >= y[currentIndex + 2]) {
            currentIndex++;
        }
        else if (y[currentIndex - 2] >= y[currentIndex - 3] &&
            y[currentIndex - 2] >= y[currentIndex - 1]) {
            currentIndex -= 2;
        }
        else if (y[currentIndex + 2] >= y[currentIndex + 1] &&
            y[currentIndex + 2] >= y[currentIndex + 3]) {
            currentIndex += 2;
        }
        // interpolation to a sin() function
        if (y[currentIndex - 1] > 0 &&
            y[currentIndex + 1] > 0 &&
            y[currentIndex] >= y[currentIndex - 1] &&
            y[currentIndex] >= y[currentIndex + 1] &&
            (y[currentIndex] !== y[currentIndex - 1] ||
                y[currentIndex] !== y[currentIndex + 1])) {
            let alpha = 20 * Math.log10(y[currentIndex - 1]);
            let beta = 20 * Math.log10(y[currentIndex]);
            let gamma = 20 * Math.log10(y[currentIndex + 1]);
            let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);
            peak.x = x[currentIndex] + (x[currentIndex] - x[currentIndex - 1]) * p;
            peak.y =
                y[currentIndex] -
                    0.25 * (y[currentIndex - 1] - y[currentIndex + 1]) * p;
        }
    }
}
exports.optimizeTop = optimizeTop;

},{}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setShape = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const { parse, stringify } = JSON;
/**
 * Append 2 properties to the peaks, shape and fwhm
 */
function setShape(peaks, options = {}) {
    let { shape = { kind: 'gaussian' }, output = parse(stringify(peaks)), } = options;
    let shapeInstance = (0, ml_peak_shape_generator_1.getShape1D)(shape);
    return output.map((peak) => ({
        ...peak,
        shape: { fwhm: shapeInstance.widthToFWHM(peak.width), ...shape },
    }));
}
exports.setShape = setShape;

},{"ml-peak-shape-generator":187}],177:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var binarySearch = _interopDefault(require('binary-search'));
var numSort = require('num-sort');

const largestPrime = 0x7fffffff;

const primeNumbers = [
  // chunk #0
  largestPrime, // 2^31-1

  // chunk #1
  5,
  11,
  23,
  47,
  97,
  197,
  397,
  797,
  1597,
  3203,
  6421,
  12853,
  25717,
  51437,
  102877,
  205759,
  411527,
  823117,
  1646237,
  3292489,
  6584983,
  13169977,
  26339969,
  52679969,
  105359939,
  210719881,
  421439783,
  842879579,
  1685759167,

  // chunk #2
  433,
  877,
  1759,
  3527,
  7057,
  14143,
  28289,
  56591,
  113189,
  226379,
  452759,
  905551,
  1811107,
  3622219,
  7244441,
  14488931,
  28977863,
  57955739,
  115911563,
  231823147,
  463646329,
  927292699,
  1854585413,

  // chunk #3
  953,
  1907,
  3821,
  7643,
  15287,
  30577,
  61169,
  122347,
  244703,
  489407,
  978821,
  1957651,
  3915341,
  7830701,
  15661423,
  31322867,
  62645741,
  125291483,
  250582987,
  501165979,
  1002331963,
  2004663929,

  // chunk #4
  1039,
  2081,
  4177,
  8363,
  16729,
  33461,
  66923,
  133853,
  267713,
  535481,
  1070981,
  2141977,
  4283963,
  8567929,
  17135863,
  34271747,
  68543509,
  137087021,
  274174111,
  548348231,
  1096696463,

  // chunk #5
  31,
  67,
  137,
  277,
  557,
  1117,
  2237,
  4481,
  8963,
  17929,
  35863,
  71741,
  143483,
  286973,
  573953,
  1147921,
  2295859,
  4591721,
  9183457,
  18366923,
  36733847,
  73467739,
  146935499,
  293871013,
  587742049,
  1175484103,

  // chunk #6
  599,
  1201,
  2411,
  4831,
  9677,
  19373,
  38747,
  77509,
  155027,
  310081,
  620171,
  1240361,
  2480729,
  4961459,
  9922933,
  19845871,
  39691759,
  79383533,
  158767069,
  317534141,
  635068283,
  1270136683,

  // chunk #7
  311,
  631,
  1277,
  2557,
  5119,
  10243,
  20507,
  41017,
  82037,
  164089,
  328213,
  656429,
  1312867,
  2625761,
  5251529,
  10503061,
  21006137,
  42012281,
  84024581,
  168049163,
  336098327,
  672196673,
  1344393353,

  // chunk #8
  3,
  7,
  17,
  37,
  79,
  163,
  331,
  673,
  1361,
  2729,
  5471,
  10949,
  21911,
  43853,
  87719,
  175447,
  350899,
  701819,
  1403641,
  2807303,
  5614657,
  11229331,
  22458671,
  44917381,
  89834777,
  179669557,
  359339171,
  718678369,
  1437356741,

  // chunk #9
  43,
  89,
  179,
  359,
  719,
  1439,
  2879,
  5779,
  11579,
  23159,
  46327,
  92657,
  185323,
  370661,
  741337,
  1482707,
  2965421,
  5930887,
  11861791,
  23723597,
  47447201,
  94894427,
  189788857,
  379577741,
  759155483,
  1518310967,

  // chunk #10
  379,
  761,
  1523,
  3049,
  6101,
  12203,
  24407,
  48817,
  97649,
  195311,
  390647,
  781301,
  1562611,
  3125257,
  6250537,
  12501169,
  25002389,
  50004791,
  100009607,
  200019221,
  400038451,
  800076929,
  1600153859,

  // chunk #11
  13,
  29,
  59,
  127,
  257,
  521,
  1049,
  2099,
  4201,
  8419,
  16843,
  33703,
  67409,
  134837,
  269683,
  539389,
  1078787,
  2157587,
  4315183,
  8630387,
  17260781,
  34521589,
  69043189,
  138086407,
  276172823,
  552345671,
  1104691373,

  // chunk #12
  19,
  41,
  83,
  167,
  337,
  677,
  1361,
  2729,
  5471,
  10949,
  21911,
  43853,
  87719,
  175447,
  350899,
  701819,
  1403641,
  2807303,
  5614657,
  11229331,
  22458671,
  44917381,
  89834777,
  179669557,
  359339171,
  718678369,
  1437356741,

  // chunk #13
  53,
  107,
  223,
  449,
  907,
  1823,
  3659,
  7321,
  14653,
  29311,
  58631,
  117269,
  234539,
  469099,
  938207,
  1876417,
  3752839,
  7505681,
  15011389,
  30022781,
  60045577,
  120091177,
  240182359,
  480364727,
  960729461,
  1921458943
];

primeNumbers.sort(numSort.ascending);

function nextPrime(value) {
  let index = binarySearch(primeNumbers, value, numSort.ascending);
  if (index < 0) {
    index = ~index;
  }
  return primeNumbers[index];
}

const FREE = 0;
const FULL = 1;
const REMOVED = 2;

const defaultInitialCapacity = 150;
const defaultMinLoadFactor = 1 / 6;
const defaultMaxLoadFactor = 2 / 3;

class HashTable {
  constructor(options = {}) {
    if (options instanceof HashTable) {
      this.table = options.table.slice();
      this.values = options.values.slice();
      this.state = options.state.slice();
      this.minLoadFactor = options.minLoadFactor;
      this.maxLoadFactor = options.maxLoadFactor;
      this.distinct = options.distinct;
      this.freeEntries = options.freeEntries;
      this.lowWaterMark = options.lowWaterMark;
      this.highWaterMark = options.maxLoadFactor;
      return;
    }

    const initialCapacity =
      options.initialCapacity === undefined
        ? defaultInitialCapacity
        : options.initialCapacity;
    if (initialCapacity < 0) {
      throw new RangeError(
        `initial capacity must not be less than zero: ${initialCapacity}`
      );
    }

    const minLoadFactor =
      options.minLoadFactor === undefined
        ? defaultMinLoadFactor
        : options.minLoadFactor;
    const maxLoadFactor =
      options.maxLoadFactor === undefined
        ? defaultMaxLoadFactor
        : options.maxLoadFactor;
    if (minLoadFactor < 0 || minLoadFactor >= 1) {
      throw new RangeError(`invalid minLoadFactor: ${minLoadFactor}`);
    }
    if (maxLoadFactor <= 0 || maxLoadFactor >= 1) {
      throw new RangeError(`invalid maxLoadFactor: ${maxLoadFactor}`);
    }
    if (minLoadFactor >= maxLoadFactor) {
      throw new RangeError(
        `minLoadFactor (${minLoadFactor}) must be smaller than maxLoadFactor (${maxLoadFactor})`
      );
    }

    let capacity = initialCapacity;
    // User wants to put at least capacity elements. We need to choose the size based on the maxLoadFactor to
    // avoid the need to rehash before this capacity is reached.
    // actualCapacity * maxLoadFactor >= capacity
    capacity = (capacity / maxLoadFactor) | 0;
    capacity = nextPrime(capacity);
    if (capacity === 0) capacity = 1;

    this.table = newArray(capacity);
    this.values = newArray(capacity);
    this.state = newArray(capacity);

    this.minLoadFactor = minLoadFactor;
    if (capacity === largestPrime) {
      this.maxLoadFactor = 1;
    } else {
      this.maxLoadFactor = maxLoadFactor;
    }

    this.distinct = 0;
    this.freeEntries = capacity;

    this.lowWaterMark = 0;
    this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
  }

  clone() {
    return new HashTable(this);
  }

  get size() {
    return this.distinct;
  }

  get(key) {
    const i = this.indexOfKey(key);
    if (i < 0) return 0;
    return this.values[i];
  }

  set(key, value) {
    let i = this.indexOfInsertion(key);
    if (i < 0) {
      i = -i - 1;
      this.values[i] = value;
      return false;
    }

    if (this.distinct > this.highWaterMark) {
      const newCapacity = chooseGrowCapacity(
        this.distinct + 1,
        this.minLoadFactor,
        this.maxLoadFactor
      );
      this.rehash(newCapacity);
      return this.set(key, value);
    }

    this.table[i] = key;
    this.values[i] = value;
    if (this.state[i] === FREE) this.freeEntries--;
    this.state[i] = FULL;
    this.distinct++;

    if (this.freeEntries < 1) {
      const newCapacity = chooseGrowCapacity(
        this.distinct + 1,
        this.minLoadFactor,
        this.maxLoadFactor
      );
      this.rehash(newCapacity);
    }

    return true;
  }

  remove(key, noRehash) {
    const i = this.indexOfKey(key);
    if (i < 0) return false;

    this.state[i] = REMOVED;
    this.distinct--;

    if (!noRehash) this.maybeShrinkCapacity();

    return true;
  }

  delete(key, noRehash) {
    const i = this.indexOfKey(key);
    if (i < 0) return false;

    this.state[i] = FREE;
    this.distinct--;

    if (!noRehash) this.maybeShrinkCapacity();

    return true;
  }

  maybeShrinkCapacity() {
    if (this.distinct < this.lowWaterMark) {
      const newCapacity = chooseShrinkCapacity(
        this.distinct,
        this.minLoadFactor,
        this.maxLoadFactor
      );
      this.rehash(newCapacity);
    }
  }

  containsKey(key) {
    return this.indexOfKey(key) >= 0;
  }

  indexOfKey(key) {
    const table = this.table;
    const state = this.state;
    const length = this.table.length;

    const hash = key & 0x7fffffff;
    let i = hash % length;
    let decrement = hash % (length - 2);
    if (decrement === 0) decrement = 1;

    while (state[i] !== FREE && (state[i] === REMOVED || table[i] !== key)) {
      i -= decrement;
      if (i < 0) i += length;
    }

    if (state[i] === FREE) return -1;
    return i;
  }

  containsValue(value) {
    return this.indexOfValue(value) >= 0;
  }

  indexOfValue(value) {
    const values = this.values;
    const state = this.state;

    for (var i = 0; i < state.length; i++) {
      if (state[i] === FULL && values[i] === value) {
        return i;
      }
    }

    return -1;
  }

  indexOfInsertion(key) {
    const table = this.table;
    const state = this.state;
    const length = table.length;

    const hash = key & 0x7fffffff;
    let i = hash % length;
    let decrement = hash % (length - 2);
    if (decrement === 0) decrement = 1;

    while (state[i] === FULL && table[i] !== key) {
      i -= decrement;
      if (i < 0) i += length;
    }

    if (state[i] === REMOVED) {
      const j = i;
      while (state[i] !== FREE && (state[i] === REMOVED || table[i] !== key)) {
        i -= decrement;
        if (i < 0) i += length;
      }
      if (state[i] === FREE) i = j;
    }

    if (state[i] === FULL) {
      return -i - 1;
    }

    return i;
  }

  ensureCapacity(minCapacity) {
    if (this.table.length < minCapacity) {
      const newCapacity = nextPrime(minCapacity);
      this.rehash(newCapacity);
    }
  }

  rehash(newCapacity) {
    const oldCapacity = this.table.length;

    if (newCapacity <= this.distinct) throw new Error('Unexpected');

    const oldTable = this.table;
    const oldValues = this.values;
    const oldState = this.state;

    const newTable = newArray(newCapacity);
    const newValues = newArray(newCapacity);
    const newState = newArray(newCapacity);

    this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
    this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);

    this.table = newTable;
    this.values = newValues;
    this.state = newState;
    this.freeEntries = newCapacity - this.distinct;

    for (var i = 0; i < oldCapacity; i++) {
      if (oldState[i] === FULL) {
        var element = oldTable[i];
        var index = this.indexOfInsertion(element);
        newTable[index] = element;
        newValues[index] = oldValues[i];
        newState[index] = FULL;
      }
    }
  }

  forEachKey(callback) {
    for (var i = 0; i < this.state.length; i++) {
      if (this.state[i] === FULL) {
        if (!callback(this.table[i])) return false;
      }
    }
    return true;
  }

  forEachValue(callback) {
    for (var i = 0; i < this.state.length; i++) {
      if (this.state[i] === FULL) {
        if (!callback(this.values[i])) return false;
      }
    }
    return true;
  }

  forEachPair(callback) {
    for (var i = 0; i < this.state.length; i++) {
      if (this.state[i] === FULL) {
        if (!callback(this.table[i], this.values[i])) return false;
      }
    }
    return true;
  }
}

function chooseLowWaterMark(capacity, minLoad) {
  return (capacity * minLoad) | 0;
}

function chooseHighWaterMark(capacity, maxLoad) {
  return Math.min(capacity - 2, (capacity * maxLoad) | 0);
}

function chooseGrowCapacity(size, minLoad, maxLoad) {
  return nextPrime(
    Math.max(size + 1, ((4 * size) / (3 * minLoad + maxLoad)) | 0)
  );
}

function chooseShrinkCapacity(size, minLoad, maxLoad) {
  return nextPrime(
    Math.max(size + 1, ((4 * size) / (minLoad + 3 * maxLoad)) | 0)
  );
}

function newArray(size) {
  return Array(size).fill(0);
}

module.exports = HashTable;

},{"binary-search":3,"num-sort":524}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mlDistanceEuclidean = require('ml-distance-euclidean');
var getDistanceMatrix = require('ml-distance-matrix');
var mlMatrix = require('ml-matrix');
var Heap = require('heap');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var getDistanceMatrix__default = /*#__PURE__*/_interopDefaultLegacy(getDistanceMatrix);
var Heap__default = /*#__PURE__*/_interopDefaultLegacy(Heap);

class Cluster {
  constructor() {
    this.children = [];
    this.height = 0;
    this.size = 1;
    this.index = -1;
    this.isLeaf = false;
  }

  /**
   * Creates an array of clusters where the maximum height is smaller than the threshold
   * @param {number} threshold
   * @return {Array<Cluster>}
   */
  cut(threshold) {
    if (typeof threshold !== 'number') {
      throw new TypeError('threshold must be a number');
    }
    if (threshold < 0) {
      throw new RangeError('threshold must be a positive number');
    }
    let list = [this];
    const ans = [];
    while (list.length > 0) {
      const aux = list.shift();
      if (threshold >= aux.height) {
        ans.push(aux);
      } else {
        list = list.concat(aux.children);
      }
    }
    return ans;
  }

  /**
   * Merge the leaves in the minimum way to have `groups` number of clusters.
   * @param {number} groups - Them number of children the first level of the tree should have.
   * @return {Cluster}
   */
  group(groups) {
    if (!Number.isInteger(groups) || groups < 1) {
      throw new RangeError('groups must be a positive integer');
    }

    const heap = new Heap__default['default']((a, b) => {
      return b.height - a.height;
    });

    heap.push(this);

    while (heap.size() < groups) {
      const first = heap.pop();
      if (first.children.length === 0) {
        break;
      }
      first.children.forEach((child) => heap.push(child));
    }

    const root = new Cluster();
    root.children = heap.toArray();
    root.height = this.height;

    return root;
  }

  /**
   * Traverses the tree depth-first and calls the provided callback with each individual node
   * @param {function} cb - The callback to be called on each node encounter
   */
  traverse(cb) {
    function visit(root, callback) {
      callback(root);
      if (root.children) {
        for (const child of root.children) {
          visit(child, callback);
        }
      }
    }
    visit(this, cb);
  }

  /**
   * Returns a list of indices for all the leaves of this cluster.
   * The list is ordered in such a way that a dendrogram could be drawn without crossing branches.
   * @returns {Array<number>}
   */
  indices() {
    const result = [];
    this.traverse((cluster) => {
      if (cluster.isLeaf) {
        result.push(cluster.index);
      }
    });
    return result;
  }
}

function singleLink(dKI, dKJ) {
  return Math.min(dKI, dKJ);
}

function completeLink(dKI, dKJ) {
  return Math.max(dKI, dKJ);
}

function averageLink(dKI, dKJ, dIJ, ni, nj) {
  const ai = ni / (ni + nj);
  const aj = nj / (ni + nj);
  return ai * dKI + aj * dKJ;
}

function weightedAverageLink(dKI, dKJ) {
  return (dKI + dKJ) / 2;
}

function centroidLink(dKI, dKJ, dIJ, ni, nj) {
  const ai = ni / (ni + nj);
  const aj = nj / (ni + nj);
  const b = -(ni * nj) / (ni + nj) ** 2;
  return ai * dKI + aj * dKJ + b * dIJ;
}

function medianLink(dKI, dKJ, dIJ) {
  return dKI / 2 + dKJ / 2 - dIJ / 4;
}

function wardLink(dKI, dKJ, dIJ, ni, nj, nk) {
  const ai = (ni + nk) / (ni + nj + nk);
  const aj = (nj + nk) / (ni + nj + nk);
  const b = -nk / (ni + nj + nk);
  return ai * dKI + aj * dKJ + b * dIJ;
}

function wardLink2(dKI, dKJ, dIJ, ni, nj, nk) {
  const ai = (ni + nk) / (ni + nj + nk);
  const aj = (nj + nk) / (ni + nj + nk);
  const b = -nk / (ni + nj + nk);
  return Math.sqrt(ai * dKI * dKI + aj * dKJ * dKJ + b * dIJ * dIJ);
}

/**
 * Continuously merge nodes that have the least dissimilarity
 * @param {Array<Array<number>>} data - Array of points to be clustered
 * @param {object} [options]
 * @param {Function} [options.distanceFunction]
 * @param {string} [options.method] - Default: `'complete'`
 * @param {boolean} [options.isDistanceMatrix] - Is the input already a distance matrix?
 * @constructor
 */
function agnes(data, options = {}) {
  const {
    distanceFunction = mlDistanceEuclidean.euclidean,
    method = 'complete',
    isDistanceMatrix = false,
  } = options;

  let updateFunc;
  if (!isDistanceMatrix) {
    data = getDistanceMatrix__default['default'](data, distanceFunction);
  }
  let distanceMatrix = new mlMatrix.Matrix(data);
  const numLeaves = distanceMatrix.rows;

  // allows to use a string or a given function
  if (typeof method === 'string') {
    switch (method.toLowerCase()) {
      case 'single':
        updateFunc = singleLink;
        break;
      case 'complete':
        updateFunc = completeLink;
        break;
      case 'average':
      case 'upgma':
        updateFunc = averageLink;
        break;
      case 'wpgma':
        updateFunc = weightedAverageLink;
        break;
      case 'centroid':
      case 'upgmc':
        updateFunc = centroidLink;
        break;
      case 'median':
      case 'wpgmc':
        updateFunc = medianLink;
        break;
      case 'ward':
        updateFunc = wardLink;
        break;
      case 'ward2':
        updateFunc = wardLink2;
        break;
      default:
        throw new RangeError(`unknown clustering method: ${method}`);
    }
  } else if (typeof method !== 'function') {
    throw new TypeError('method must be a string or function');
  }

  let clusters = [];
  for (let i = 0; i < numLeaves; i++) {
    const cluster = new Cluster();
    cluster.isLeaf = true;
    cluster.index = i;
    clusters.push(cluster);
  }

  for (let n = 0; n < numLeaves - 1; n++) {
    const [row, column, distance] = getSmallestDistance(distanceMatrix);
    const cluster1 = clusters[row];
    const cluster2 = clusters[column];
    const newCluster = new Cluster();
    newCluster.size = cluster1.size + cluster2.size;
    newCluster.children.push(cluster1, cluster2);
    newCluster.height = distance;

    const newClusters = [newCluster];
    const newDistanceMatrix = new mlMatrix.Matrix(
      distanceMatrix.rows - 1,
      distanceMatrix.rows - 1,
    );
    const previous = (newIndex) =>
      getPreviousIndex(newIndex, Math.min(row, column), Math.max(row, column));

    for (let i = 1; i < newDistanceMatrix.rows; i++) {
      const prevI = previous(i);
      const prevICluster = clusters[prevI];
      newClusters.push(prevICluster);
      for (let j = 0; j < i; j++) {
        if (j === 0) {
          const dKI = distanceMatrix.get(row, prevI);
          const dKJ = distanceMatrix.get(prevI, column);
          const val = updateFunc(
            dKI,
            dKJ,
            distance,
            cluster1.size,
            cluster2.size,
            prevICluster.size,
          );
          newDistanceMatrix.set(i, j, val);
          newDistanceMatrix.set(j, i, val);
        } else {
          // Just copy distance from previous matrix
          const val = distanceMatrix.get(prevI, previous(j));
          newDistanceMatrix.set(i, j, val);
          newDistanceMatrix.set(j, i, val);
        }
      }
    }

    clusters = newClusters;
    distanceMatrix = newDistanceMatrix;
  }

  return clusters[0];
}

function getSmallestDistance(distance) {
  let smallest = Infinity;
  let smallestI = 0;
  let smallestJ = 0;
  for (let i = 1; i < distance.rows; i++) {
    for (let j = 0; j < i; j++) {
      if (distance.get(i, j) < smallest) {
        smallest = distance.get(i, j);
        smallestI = i;
        smallestJ = j;
      }
    }
  }
  return [smallestI, smallestJ, smallest];
}

function getPreviousIndex(newIndex, prev1, prev2) {
  newIndex -= 1;
  if (newIndex >= prev1) newIndex++;
  if (newIndex >= prev2) newIndex++;
  return newIndex;
}

exports.Cluster = Cluster;
exports.agnes = agnes;

},{"heap":11,"ml-distance-euclidean":157,"ml-distance-matrix":158,"ml-matrix":186}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const is_any_array_1 = require("is-any-array");
function checkOptions(data, parameterizedFunction, options) {
    let { timeout, minValues, maxValues, initialValues, weights = 1, damping = 1e-2, dampingStepUp = 11, dampingStepDown = 9, maxIterations = 100, errorTolerance = 1e-7, centralDifference = false, gradientDifference = 10e-2, improvementThreshold = 1e-3, } = options;
    if (damping <= 0) {
        throw new Error('The damping option must be a positive number');
    }
    else if (!data.x || !data.y) {
        throw new Error('The data parameter must have x and y elements');
    }
    else if (!(0, is_any_array_1.isAnyArray)(data.x) ||
        data.x.length < 2 ||
        !(0, is_any_array_1.isAnyArray)(data.y) ||
        data.y.length < 2) {
        throw new Error('The data parameter elements must be an array with more than 2 points');
    }
    else if (data.x.length !== data.y.length) {
        throw new Error('The data parameter elements must have the same size');
    }
    let parameters = initialValues || new Array(parameterizedFunction.length).fill(1);
    let nbPoints = data.y.length;
    let parLen = parameters.length;
    maxValues = maxValues || new Array(parLen).fill(Number.MAX_SAFE_INTEGER);
    minValues = minValues || new Array(parLen).fill(Number.MIN_SAFE_INTEGER);
    if (maxValues.length !== minValues.length) {
        throw new Error('minValues and maxValues must be the same size');
    }
    if (!(0, is_any_array_1.isAnyArray)(parameters)) {
        throw new Error('initialValues must be an array');
    }
    if (typeof gradientDifference === 'number') {
        gradientDifference = new Array(parameters.length).fill(gradientDifference);
    }
    else if ((0, is_any_array_1.isAnyArray)(gradientDifference)) {
        if (gradientDifference.length !== parLen) {
            gradientDifference = new Array(parLen).fill(gradientDifference[0]);
        }
    }
    else {
        throw new Error('gradientDifference should be a number or array with length equal to the number of parameters');
    }
    let filler;
    if (typeof weights === 'number') {
        let value = 1 / weights ** 2;
        filler = () => value;
    }
    else if ((0, is_any_array_1.isAnyArray)(weights)) {
        if (weights.length < data.x.length) {
            let value = 1 / weights[0] ** 2;
            filler = () => value;
        }
        else {
            filler = (i) => 1 / weights[i] ** 2;
        }
    }
    else {
        throw new Error('weights should be a number or array with length equal to the number of data points');
    }
    let checkTimeout;
    if (timeout !== undefined) {
        if (typeof timeout !== 'number') {
            throw new Error('timeout should be a number');
        }
        let endTime = Date.now() + timeout * 1000;
        checkTimeout = () => Date.now() > endTime;
    }
    else {
        checkTimeout = () => false;
    }
    let weightSquare = new Array(data.x.length);
    for (let i = 0; i < nbPoints; i++) {
        weightSquare[i] = filler(i);
    }
    return {
        checkTimeout,
        minValues,
        maxValues,
        parameters,
        weightSquare,
        damping,
        dampingStepUp,
        dampingStepDown,
        maxIterations,
        errorTolerance,
        centralDifference,
        gradientDifference,
        improvementThreshold,
    };
}
exports.default = checkOptions;

},{"is-any-array":13}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * the sum of the weighted squares of the errors (or weighted residuals) between the data.y
 * and the curve-fit function.
 * @ignore
 * @param {{x:ArrayLike<number>, y:ArrayLike<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]
 * @param {ArrayLike<number>} parameters - Array of current parameter values
 * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter
 * @param {ArrayLike<number>} weightSquare - Square of weights
 * @return {number}
 */
function errorCalculation(data, parameters, parameterizedFunction, weightSquare) {
    let error = 0;
    const func = parameterizedFunction(parameters);
    for (let i = 0; i < data.x.length; i++) {
        error += Math.pow(data.y[i] - func(data.x[i]), 2) / weightSquare[i];
    }
    return error;
}
exports.default = errorCalculation;

},{}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_matrix_1 = require("ml-matrix");
/**
 * Difference of the matrix function over the parameters
 * @ignore
 * @param {{x:ArrayLike<number>, y:ArrayLike<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]
 * @param {ArrayLike<number>} evaluatedData - Array of previous evaluated function values
 * @param {Array<number>} params - Array of previous parameter values
 * @param {number|array} gradientDifference - The step size to approximate the jacobian matrix
 * @param {boolean} centralDifference - If true the jacobian matrix is approximated by central differences otherwise by forward differences
 * @param {function} paramFunction - The parameters and returns a function with the independent variable as a parameter
 * @return {Matrix}
 */
function gradientFunction(data, evaluatedData, params, gradientDifference, paramFunction, centralDifference) {
    const nbParams = params.length;
    const nbPoints = data.x.length;
    let ans = ml_matrix_1.Matrix.zeros(nbParams, nbPoints);
    let rowIndex = 0;
    for (let param = 0; param < nbParams; param++) {
        if (gradientDifference[param] === 0)
            continue;
        let delta = gradientDifference[param];
        let auxParams = params.slice();
        auxParams[param] += delta;
        let funcParam = paramFunction(auxParams);
        if (!centralDifference) {
            for (let point = 0; point < nbPoints; point++) {
                ans.set(rowIndex, point, (evaluatedData[point] - funcParam(data.x[point])) / delta);
            }
        }
        else {
            auxParams = params.slice();
            auxParams[param] -= delta;
            delta *= 2;
            let funcParam2 = paramFunction(auxParams);
            for (let point = 0; point < nbPoints; point++) {
                ans.set(rowIndex, point, (funcParam2(data.x[point]) - funcParam(data.x[point])) / delta);
            }
        }
        rowIndex++;
    }
    return ans;
}
exports.default = gradientFunction;

},{"ml-matrix":186}],182:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.levenbergMarquardt = void 0;
const checkOptions_1 = __importDefault(require("./checkOptions"));
const errorCalculation_1 = __importDefault(require("./errorCalculation"));
const step_1 = __importDefault(require("./step"));
/**
 * Curve fitting algorithm
 * @param {{x:ArrayLike<number>, y:ArrayLike<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]
 * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter
 * @param {object} [options] - Options object
 * @param {number|ArrayLike<number>} [options.weights = 1] - weighting vector, if the length does not match with the number of data points, the vector is reconstructed with first value.
 * @param {number} [options.damping = 1e-2] - Levenberg-Marquardt parameter, small values of the damping parameter λ result in a Gauss-Newton update and large
values of λ result in a gradient descent update
 * @param {number} [options.dampingStepDown = 9] - factor to reduce the damping (Levenberg-Marquardt parameter) when there is not an improvement when updating parameters.
 * @param {number} [options.dampingStepUp = 11] - factor to increase the damping (Levenberg-Marquardt parameter) when there is an improvement when updating parameters.
 * @param {number} [options.improvementThreshold = 1e-3] - the threshold to define an improvement through an update of parameters
 * @param {number|ArrayLike<number>} [options.gradientDifference = 10e-2] - The step size to approximate the jacobian matrix
 * @param {boolean} [options.centralDifference = false] - If true the jacobian matrix is approximated by central differences otherwise by forward differences
 * @param {ArrayLike<number>} [options.minValues] - Minimum allowed values for parameters
 * @param {ArrayLike<number>} [options.maxValues] - Maximum allowed values for parameters
 * @param {ArrayLike<number>} [options.initialValues] - Array of initial parameter values
 * @param {number} [options.maxIterations = 100] - Maximum of allowed iterations
 * @param {number} [options.errorTolerance = 10e-3] - Minimum uncertainty allowed for each point.
 * @param {number} [options.timeout] - maximum time running before throw in seconds.
 * @return {{parameterValues: Array<number>, parameterError: number, iterations: number}}
 */
function levenbergMarquardt(data, parameterizedFunction, options = {}) {
    let { checkTimeout, minValues, maxValues, parameters, weightSquare, damping, dampingStepUp, dampingStepDown, maxIterations, errorTolerance, centralDifference, gradientDifference, improvementThreshold, } = (0, checkOptions_1.default)(data, parameterizedFunction, options);
    let error = (0, errorCalculation_1.default)(data, parameters, parameterizedFunction, weightSquare);
    let optimalError = error;
    let optimalParameters = parameters.slice();
    let converged = error <= errorTolerance;
    let iteration = 0;
//    let diagnostic = [];
    for (; iteration < maxIterations && !converged; iteration++) {
	//console.log("iteration " + iteration + " error " + error + " params " + parameters);
//	diagnostic.push({err:error,params:parameters})
        let previousError = error;
        let { perturbations, jacobianWeightResidualError } = (0, step_1.default)(data, parameters, damping, gradientDifference, parameterizedFunction, centralDifference, weightSquare);
        for (let k = 0; k < parameters.length; k++) {
            parameters[k] = Math.min(Math.max(minValues[k], parameters[k] - perturbations.get(k, 0)), maxValues[k]);
        }
        error = (0, errorCalculation_1.default)(data, parameters, parameterizedFunction, weightSquare);
        if (isNaN(error))
            break;
        if (error < optimalError - errorTolerance) {
            optimalError = error;
            optimalParameters = parameters.slice();
        }
        let improvementMetric = (previousError - error) /
            perturbations
                .transpose()
                .mmul(perturbations.mul(damping).add(jacobianWeightResidualError))
                .get(0, 0);
        if (improvementMetric > improvementThreshold) {
            damping = Math.max(damping / dampingStepDown, 1e-7);
        }
        else {
            damping = Math.min(damping * dampingStepUp, 1e7);
        }
        if (checkTimeout()) {
            throw new Error(`The execution time is over to ${options.timeout} seconds`);
        }
        converged = error <= errorTolerance;
    }
    return {
        parameterValues: optimalParameters,
        parameterError: optimalError,
        iterations: iteration,
//	diagnostics: diagnostic
    };
}
exports.levenbergMarquardt = levenbergMarquardt;

},{"./checkOptions":179,"./errorCalculation":180,"./step":183}],183:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ml_matrix_1 = require("ml-matrix");
const gradientFunction_1 = __importDefault(require("./gradientFunction"));
/**
 * Matrix function over the samples
 * @ignore
 * @param {{x:ArrayLike<number>, y:ArrayLike<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]
 * @param {ArrayLike<number>} evaluatedData - Array of previous evaluated function values
 * @return {Matrix}
 */
function matrixFunction(data, evaluatedData) {
    const m = data.x.length;
    let ans = new ml_matrix_1.Matrix(m, 1);
    for (let point = 0; point < m; point++) {
        ans.set(point, 0, data.y[point] - evaluatedData[point]);
    }
    return ans;
}
/**
 * Iteration for Levenberg-Marquardt
 * @ignore
 * @param {{x:ArrayLike<number>, y:ArrayLike<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]
 * @param {Array<number>} params - Array of previous parameter values
 * @param {number} damping - Levenberg-Marquardt parameter
 * @param {number|array} gradientDifference - The step size to approximate the jacobian matrix
 * @param {boolean} centralDifference - If true the jacobian matrix is approximated by central differences otherwise by forward differences
 * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter
 */
function step(data, params, damping, gradientDifference, parameterizedFunction, centralDifference, weights) {
    let value = damping;
    let identity = ml_matrix_1.Matrix.eye(params.length, params.length, value);
    const func = parameterizedFunction(params);
    let evaluatedData = new Float64Array(data.x.length);
    for (let i = 0; i < data.x.length; i++) {
        evaluatedData[i] = func(data.x[i]);
    }
    let gradientFunc = (0, gradientFunction_1.default)(data, evaluatedData, params, gradientDifference, parameterizedFunction, centralDifference);
    let residualError = matrixFunction(data, evaluatedData);
    let inverseMatrix = (0, ml_matrix_1.inverse)(identity.add(gradientFunc.mmul(gradientFunc.transpose().scale('row', { scale: weights }))));
    let jacobianWeightResidualError = gradientFunc.mmul(residualError.scale('row', { scale: weights }));
    let perturbations = inverseMatrix.mmul(jacobianWeightResidualError);
    return {
        perturbations,
        jacobianWeightResidualError,
    };
}
exports.default = step;

},{"./gradientFunction":181,"ml-matrix":186}],184:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mlFft = require('ml-fft');

function LoG(sigma, nPoints, options) {
  let factor = 1000;
  if (options && options.factor) {
    factor = options.factor;
  }

  let kernel = new Array(nPoints);
  let tmp, y2;

  factor *= -1; //-1/(Math.PI*Math.pow(sigma,4));
  let center = (nPoints - 1) / 2;
  let sigma2 = 2 * sigma * sigma;
  for (let i = 0; i < nPoints; i++) {
    kernel[i] = new Array(nPoints);
    y2 = (i - center) * (i - center);
    for (let j = 0; j < nPoints; j++) {
      tmp = -((j - center) * (j - center) + y2) / sigma2;
      kernel[i][j] = Math.round(factor * (1 + tmp) * Math.exp(tmp));
    }
  }

  return kernel;
}

function matrix2Array(input) {
  let inputData = input;
  let nRows, nCols;
  if (typeof input[0] !== 'number') {
    nRows = input.length;
    nCols = input[0].length;
    inputData = new Array(nRows * nCols);
    for (let i = 0; i < nRows; i++) {
      for (let j = 0; j < nCols; j++) {
        inputData[i * nCols + j] = input[i][j];
      }
    }
  } else {
    let tmp = Math.sqrt(input.length);
    if (Number.isInteger(tmp)) {
      nRows = tmp;
      nCols = tmp;
    }
  }

  return { data: inputData, rows: nRows, cols: nCols };
}

function convolutionFFT(input, kernel, opt) {
  let tmp = matrix2Array(input);
  let inputData = tmp.data;
  let options = Object.assign(
    { normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols },
    opt,
  );

  let nRows, nCols;
  if (options.rows && options.cols) {
    nRows = options.rows;
    nCols = options.cols;
  } else {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let divisor = options.divisor;
  let kHeight = kernel.length;
  let kWidth = kernel[0].length;
  if (options.normalize) {
    divisor = 0;
    for (let i = 0; i < kHeight; i++) {
      for (let j = 0; j < kWidth; j++) divisor += kernel[i][j];
    }
  }
  if (divisor === 0) {
    throw new RangeError('convolution: The divisor is equal to zero');
  }

  let radix2Sized = mlFft.FFTUtils.toRadix2(inputData, nRows, nCols);
  let conv = mlFft.FFTUtils.convolute(
    radix2Sized.data,
    kernel,
    radix2Sized.rows,
    radix2Sized.cols,
  );
  conv = mlFft.FFTUtils.crop(conv, radix2Sized.rows, radix2Sized.cols, nRows, nCols);

  if (divisor !== 0 && divisor !== 1) {
    for (let i = 0; i < conv.length; i++) {
      conv[i] /= divisor;
    }
  }

  return conv;
}

function convolutionDirect(input, kernel, opt) {
  let tmp = matrix2Array(input);
  let inputData = tmp.data;
  let options = Object.assign(
    { normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols },
    opt,
  );

  let nRows, nCols;
  if (options.rows && options.cols) {
    nRows = options.rows;
    nCols = options.cols;
  } else {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let divisor = options.divisor;
  let kHeight = kernel.length;
  let kWidth = kernel[0].length;
  let index, sum, kVal, row, col;
  if (options.normalize) {
    divisor = 0;
    for (let i = 0; i < kHeight; i++) {
      for (let j = 0; j < kWidth; j++) divisor += kernel[i][j];
    }
  }
  if (divisor === 0) {
    throw new RangeError('convolution: The divisor is equal to zero');
  }

  let output = new Array(nRows * nCols);

  let hHeight = Math.floor(kHeight / 2);
  let hWidth = Math.floor(kWidth / 2);

  for (let y = 0; y < nRows; y++) {
    for (let x = 0; x < nCols; x++) {
      sum = 0;
      for (let j = 0; j < kHeight; j++) {
        for (let i = 0; i < kWidth; i++) {
          kVal = kernel[kHeight - j - 1][kWidth - i - 1];
          row = (y + j - hHeight + nRows) % nRows;
          col = (x + i - hWidth + nCols) % nCols;
          index = row * nCols + col;
          sum += inputData[index] * kVal;
        }
      }
      index = y * nCols + x;
      output[index] = sum / divisor;
    }
  }
  return output;
}

const kernelFactory = {
  LoG: LoG,
};

exports.direct = convolutionDirect;
exports.fft = convolutionFFT;
exports.kernelFactory = kernelFactory;
exports.matrix2Array = matrix2Array;

},{"ml-fft":161}],185:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var convolution = require('ml-matrix-convolution');
var DisjointSet = require('ml-disjoint-set');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var convolution__namespace = /*#__PURE__*/_interopNamespace(convolution);
var DisjointSet__default = /*#__PURE__*/_interopDefaultLegacy(DisjointSet);

const direction8X$1 = [-1, -1, 0, 1, -1, 0, 1, 1];
const direction8Y$1 = [0, -1, -1, -1, 1, 1, 1, 0];
const neighbours8$1 = [null, null, null, null, null, null, null, null];

const direction4X$1 = [-1, 0, 1, 0];
const direction4Y$1 = [0, -1, 0, 1];
const neighbours4$1 = [null, null, null, null];

function drainLabelling(data, mask, options = {}) {
  const { neighbours = 8, width, height } = options;

  let directionX;
  let directionY;
  let neighboursList;
  if (neighbours === 8) {
    directionX = direction8X$1;
    directionY = direction8Y$1;
    neighboursList = neighbours8$1;
  } else if (neighbours === 4) {
    directionX = direction4X$1;
    directionY = direction4Y$1;
    neighboursList = neighbours4$1;
  } else {
    throw new RangeError(`unsupported neighbours count: ${neighbours}`);
  }

  let sorted = new Array(height * width);
  for (let i = 0, index = 0; i < height; i++) {
    for (let j = 0; j < width; j++, index++) {
      sorted[index] = { value: data[index], row: i, col: j, mask: mask[index] };
    }
  }

  sorted.sort((a, b) => a.value - b.value);

  const size = mask.length;
  const labels = new Array(size);
  const pixels = new Int16Array(size);
  const linked = new DisjointSet__default['default']();

  for (let i = 0, currentLabel = 1; i < mask.length; i++) {
    let element = sorted[i];
    if (!element.mask) continue;

    let { row, col, value } = element;
    let index = col + row * width;
    let label = labels[index];
    if (!label) {
      labels[index] = linked.add(currentLabel++);
    }

    for (let k = 0; k < neighboursList.length; k++) {
      let ii = col + directionX[k];
      let jj = row + directionY[k];
      if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
        let neighbor = labels[ii + jj * width];
        if (!neighbor) {
          let neighborValue = data[ii + jj * width];
          if (value < neighborValue) {
            labels[ii + jj * width] = labels[index];
          }
        }
      }
    }
  }

  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      let index = i + j * width;
      if (mask[index]) {
        pixels[index] = linked.find(labels[index]).value;
      }
    }
  }
  return pixels;
}

const direction4X = [-1, 0];
const direction4Y = [0, -1];
const neighbours4 = [null, null];

const direction8X = [-1, -1, 0, 1];
const direction8Y = [0, -1, -1, -1];
const neighbours8 = [null, null, null, null];

function floodFillLabelling(mask, width, height, options) {
  options = options || {};
  const neighbours = options.neighbours || 8;

  let directionX;
  let directionY;
  let neighboursList;
  if (neighbours === 8) {
    directionX = direction8X;
    directionY = direction8Y;
    neighboursList = neighbours8;
  } else if (neighbours === 4) {
    directionX = direction4X;
    directionY = direction4Y;
    neighboursList = neighbours4;
  } else {
    throw new RangeError(`unsupported neighbours count: ${neighbours}`);
  }

  const size = mask.length;
  const labels = new Array(size);
  const pixels = new Int16Array(size);
  const linked = new DisjointSet__default['default']();
  let index;
  let currentLabel = 1;
  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      // true means out of background
      let smallestNeighbor = null;
      index = i + j * width;
      if (mask[index]) {
        for (let k = 0; k < neighboursList.length; k++) {
          let ii = i + directionX[k];
          let jj = j + directionY[k];
          if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
            let neighbor = labels[ii + jj * width];
            if (!neighbor) {
              neighboursList[k] = null;
            } else {
              neighboursList[k] = neighbor;
              if (
                !smallestNeighbor ||
                neighboursList[k].value < smallestNeighbor.value
              ) {
                smallestNeighbor = neighboursList[k];
              }
            }
          }
        }
        if (!smallestNeighbor) {
          labels[index] = linked.add(currentLabel++);
        } else {
          labels[index] = smallestNeighbor;
          for (let k = 0; k < neighboursList.length; k++) {
            if (neighboursList[k] && neighboursList[k] !== smallestNeighbor) {
              linked.union(smallestNeighbor, neighboursList[k]);
            }
          }
        }
      }
    }
  }
  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      index = i + j * width;
      if (mask[index]) {
        pixels[index] = linked.find(labels[index]).value;
      }
    }
  }
  return pixels;
}

const smallFilter = [
  [0, 0, 1, 2, 2, 2, 1, 0, 0],
  [0, 1, 4, 7, 7, 7, 4, 1, 0],
  [1, 4, 5, 3, 0, 3, 5, 4, 1],
  [2, 7, 3, -12, -23, -12, 3, 7, 2],
  [2, 7, 0, -23, -40, -23, 0, 7, 2],
  [2, 7, 3, -12, -23, -12, 3, 7, 2],
  [1, 4, 5, 3, 0, 3, 5, 4, 1],
  [0, 1, 3, 7, 7, 7, 3, 1, 0],
  [0, 0, 1, 2, 2, 2, 1, 0, 0],
];

/**
 * Detects all the 2D-peaks in the given spectrum based on center of mass logic.
 * @param {Array<Array>} input - matrix to get the local maxima
 * @param {Object} [options = {}] - options of the method.
 * @param {Array<Array>} [options.nStdDev = 3] - number of times of the standard deviations for the noise level.Float64Array
 * @param {Array<Array>} [options.kernel] - kernel to the convolution step.
 * @param {string} [options.labelling = 'drain'] - select the labelling algorithm to assign pixels.
 * @param {Array<Array>} [options.originalData] - original data useful when the original matrix has values and the input matrix has absolute ones
 * @param {Array<Array>} [options.filteredData] - convoluted data, if it is defined the convolution step is skipped
 */
function findPeaks2DRegion(input, options = {}) {
  let {
    nStdDev = 3,
    kernel = smallFilter,
    originalData = convolution__namespace.matrix2Array(input).data,
    filteredData,
    rows: nRows,
    cols: nCols,
    labelling = 'drain',
  } = options;

  let flatten = convolution__namespace.matrix2Array(input);
  let data = flatten.data;

  if (!nRows || !nCols) {
    nRows = flatten.rows;
    nCols = flatten.cols;
  }

  if (!nRows || !nCols) {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let cs = filteredData;
  if (!cs) cs = convolution__namespace.fft(data, kernel, options);

  let threshold = 0;
  for (let i = nCols * nRows - 2; i >= 0; i--) {
    threshold += Math.pow(cs[i] - cs[i + 1], 2);
  }
  threshold = (-Math.sqrt(threshold) * nStdDev) / nRows;

  let bitmask = new Uint16Array(nCols * nRows);
  for (let i = cs.length - 1; i >= 0; i--) {
    if (cs[i] < threshold) {
      bitmask[i] = 1;
    }
  }

  let pixels;
  switch (labelling.toLowerCase()) {
    case 'drain':
      pixels = drainLabelling(cs, bitmask, {
        neighbours: 8,
        width: nCols,
        height: nRows,
      });
      break;
    case 'floodfill':
      pixels = floodFillLabelling(bitmask, nCols, nRows, { neighbours: 8 });
      break;
    default:
      throw new Error(`labelling ${labelling} does not support`);
  }

  return extractPeaks(pixels, {
    data,
    nCols,
    originalData,
  });
}
/**
 Detects all the 2D-peaks in the given spectrum based on the Max logic.
 amc
 */
function findPeaks2DMax(input, options) {
  let {
    nStdDev = 3,
    kernel = smallFilter,
    originalData = convolution__namespace.matrix2Array(input).data,
    rows: nRows,
    cols: nCols,
    filteredData,
  } = options;

  let flatten = convolution__namespace.matrix2Array(input);
  let data = flatten.data;

  if (!nRows || !nCols) {
    nRows = flatten.rows;
    nCols = flatten.cols;
  }

  if (!nRows || !nCols) {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let cs = filteredData;
  if (!cs) cs = convolution__namespace.fft(data, kernel, options);

  let threshold = 0;
  for (let i = nCols * nRows - 2; i >= 0; i--) {
    threshold += Math.pow(cs[i] - cs[i + 1], 2);
  }
  threshold = (-Math.sqrt(threshold) * nStdDev) / nRows;

  let rowI, colI;
  let tmpIndex = 0;
  let peakListMax = [];
  for (let i = 0; i < cs.length; i++) {
    if (cs[i] < threshold) {
      //It is a peak?
      rowI = Math.floor(i / nCols);
      colI = i % nCols;
      //Verifies if this point is a peak;
      if (rowI > 0 && rowI + 1 < nRows && colI + 1 < nCols && colI > 0) {
        //It is the minimum in the same row
        if (cs[i] < cs[i + 1] && cs[i] < cs[i - 1]) {
          //It is the minimum in the previous row
          tmpIndex = (rowI - 1) * nCols + colI;
          if (
            cs[i] < cs[tmpIndex - 1] &&
            cs[i] < cs[tmpIndex] &&
            cs[i] < cs[tmpIndex + 1]
          ) {
            //It is the minimum in the next row
            tmpIndex = (rowI + 1) * nCols + colI;
            if (
              cs[i] < cs[tmpIndex - 1] &&
              cs[i] < cs[tmpIndex] &&
              cs[i] < cs[tmpIndex + 1]
            ) {
              peakListMax.push({ x: colI, y: rowI, z: originalData[i] });
            }
          }
        }
      }
    }
  }
  return peakListMax;
}

function extractPeaks(pixels, options) {
  const { data, nCols, originalData } = options;
  //How many different groups we have?
  let labels = {};
  let row, col, tmp;
  for (let i = 0; i < pixels.length; i++) {
    if (pixels[i] !== 0) {
      col = i % nCols;
      row = (i - col) / nCols;
      if (labels[pixels[i]]) {
        tmp = labels[pixels[i]];
        tmp.x += col * data[i];
        tmp.y += row * data[i];
        tmp.z += originalData[i];
        if (col < tmp.minX) tmp.minX = col;
        if (col > tmp.maxX) tmp.maxX = col;
        if (row < tmp.minY) tmp.minY = row;
        if (row > tmp.maxY) tmp.maxY = row;
      } else {
        labels[pixels[i]] = {
          x: col * data[i],
          y: row * data[i],
          z: originalData[i],
          minX: col,
          maxX: col,
          minY: row,
          maxY: row,
        };
      }
    }
  }
  let keys = Object.keys(labels);
  let peakList = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    peakList[i] = labels[keys[i]];
    let zValue = Math.abs(peakList[i].z);
    peakList[i].x /= zValue;
    peakList[i].y /= zValue;
  }

  return peakList;
}

exports.findPeaks2DMax = findPeaks2DMax;
exports.findPeaks2DRegion = findPeaks2DRegion;

},{"ml-disjoint-set":156,"ml-matrix-convolution":184}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isAnyArray = require('is-any-array');
var rescale = require('ml-array-rescale');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var rescale__default = /*#__PURE__*/_interopDefaultLegacy(rescale);

const indent = ' '.repeat(2);
const indentData = ' '.repeat(4);

function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}

function inspectMatrixWithOptions(matrix, options = {}) {
  const {
    maxRows = 15,
    maxColumns = 10,
    maxNumSize = 8,
    padMinus = 'auto',
  } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}

function inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];

  if (padMinus === 'auto') {
    padMinus = false;
    loop: for (let i = 0; i < maxI; i++) {
      for (let j = 0; j < maxJ; j++) {
        if (matrix.get(i, j) < 0) {
          padMinus = true;
          break loop;
        }
      }
    }
  }

  for (let i = 0; i < maxI; i++) {
    let line = [];
    for (let j = 0; j < maxJ; j++) {
      line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));
    }
    result.push(`${line.join(' ')}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`\n${indentData}`);
}

function formatNumber(num, maxNumSize, padMinus) {
  return (
    num >= 0 && padMinus
      ? ` ${formatNumber2(num, maxNumSize - 1)}`
      : formatNumber2(num, maxNumSize)
  ).padEnd(maxNumSize);
}

function formatNumber2(num, len) {
  // small.length numbers should be as is
  let str = num.toString();
  if (str.length <= len) return str;

  // (7)'0.00123' is better then (7)'1.23e-2'
  // (8)'0.000123' is worse then (7)'1.23e-3',
  let fix = num.toFixed(len);
  if (fix.length > len) {
    fix = num.toFixed(Math.max(0, len - (fix.length - len)));
  }
  if (
    fix.length <= len &&
    !fix.startsWith('0.000') &&
    !fix.startsWith('-0.000')
  ) {
    return fix;
  }

  // well, if it's still too long the user should've used longer numbers
  let exp = num.toExponential(len);
  if (exp.length > len) {
    exp = num.toExponential(Math.max(0, len - (exp.length - len)));
  }
  return exp.slice(0);
}

function installMathOperations(AbstractMatrix, Matrix) {
  AbstractMatrix.prototype.add = function add(value) {
    if (typeof value === 'number') return this.addS(value);
    return this.addM(value);
  };

  AbstractMatrix.prototype.addS = function addS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.addM = function addM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.add = function add(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.add(value);
  };

  AbstractMatrix.prototype.sub = function sub(value) {
    if (typeof value === 'number') return this.subS(value);
    return this.subM(value);
  };

  AbstractMatrix.prototype.subS = function subS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.subM = function subM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.sub = function sub(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;
  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;
  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;
  AbstractMatrix.subtract = AbstractMatrix.sub;

  AbstractMatrix.prototype.mul = function mul(value) {
    if (typeof value === 'number') return this.mulS(value);
    return this.mulM(value);
  };

  AbstractMatrix.prototype.mulS = function mulS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.mulM = function mulM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mul = function mul(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;
  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;
  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;
  AbstractMatrix.multiply = AbstractMatrix.mul;

  AbstractMatrix.prototype.div = function div(value) {
    if (typeof value === 'number') return this.divS(value);
    return this.divM(value);
  };

  AbstractMatrix.prototype.divS = function divS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.divM = function divM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.div = function div(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;
  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;
  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;
  AbstractMatrix.divide = AbstractMatrix.div;

  AbstractMatrix.prototype.mod = function mod(value) {
    if (typeof value === 'number') return this.modS(value);
    return this.modM(value);
  };

  AbstractMatrix.prototype.modS = function modS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.modM = function modM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mod = function mod(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;
  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;
  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;
  AbstractMatrix.modulus = AbstractMatrix.mod;

  AbstractMatrix.prototype.and = function and(value) {
    if (typeof value === 'number') return this.andS(value);
    return this.andM(value);
  };

  AbstractMatrix.prototype.andS = function andS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.andM = function andM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.and = function and(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.and(value);
  };

  AbstractMatrix.prototype.or = function or(value) {
    if (typeof value === 'number') return this.orS(value);
    return this.orM(value);
  };

  AbstractMatrix.prototype.orS = function orS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.orM = function orM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.or = function or(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.or(value);
  };

  AbstractMatrix.prototype.xor = function xor(value) {
    if (typeof value === 'number') return this.xorS(value);
    return this.xorM(value);
  };

  AbstractMatrix.prototype.xorS = function xorS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.xorM = function xorM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.xor = function xor(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.xor(value);
  };

  AbstractMatrix.prototype.leftShift = function leftShift(value) {
    if (typeof value === 'number') return this.leftShiftS(value);
    return this.leftShiftM(value);
  };

  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.leftShift(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };

  AbstractMatrix.prototype.rightShift = function rightShift(value) {
    if (typeof value === 'number') return this.rightShiftS(value);
    return this.rightShiftM(value);
  };

  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;
  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;
  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;
  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;

  AbstractMatrix.prototype.not = function not() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, ~(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.not = function not(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.not();
  };

  AbstractMatrix.prototype.abs = function abs() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.abs(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.abs = function abs(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.abs();
  };

  AbstractMatrix.prototype.acos = function acos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acos = function acos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acos();
  };

  AbstractMatrix.prototype.acosh = function acosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acosh = function acosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acosh();
  };

  AbstractMatrix.prototype.asin = function asin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asin = function asin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asin();
  };

  AbstractMatrix.prototype.asinh = function asinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asinh = function asinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asinh();
  };

  AbstractMatrix.prototype.atan = function atan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atan = function atan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atan();
  };

  AbstractMatrix.prototype.atanh = function atanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atanh = function atanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atanh();
  };

  AbstractMatrix.prototype.cbrt = function cbrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cbrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cbrt();
  };

  AbstractMatrix.prototype.ceil = function ceil() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.ceil(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.ceil = function ceil(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.ceil();
  };

  AbstractMatrix.prototype.clz32 = function clz32() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.clz32(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.clz32();
  };

  AbstractMatrix.prototype.cos = function cos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cos = function cos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cos();
  };

  AbstractMatrix.prototype.cosh = function cosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cosh = function cosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cosh();
  };

  AbstractMatrix.prototype.exp = function exp() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.exp(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.exp = function exp(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.exp();
  };

  AbstractMatrix.prototype.expm1 = function expm1() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.expm1(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.expm1();
  };

  AbstractMatrix.prototype.floor = function floor() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.floor(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.floor = function floor(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.floor();
  };

  AbstractMatrix.prototype.fround = function fround() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.fround(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.fround = function fround(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.fround();
  };

  AbstractMatrix.prototype.log = function log() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log = function log(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log();
  };

  AbstractMatrix.prototype.log1p = function log1p() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log1p(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log1p = function log1p(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log1p();
  };

  AbstractMatrix.prototype.log10 = function log10() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log10(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log10 = function log10(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log10();
  };

  AbstractMatrix.prototype.log2 = function log2() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log2(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log2 = function log2(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log2();
  };

  AbstractMatrix.prototype.round = function round() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.round(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.round = function round(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.round();
  };

  AbstractMatrix.prototype.sign = function sign() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sign(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sign = function sign(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sign();
  };

  AbstractMatrix.prototype.sin = function sin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sin = function sin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sin();
  };

  AbstractMatrix.prototype.sinh = function sinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sinh = function sinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sinh();
  };

  AbstractMatrix.prototype.sqrt = function sqrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sqrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sqrt();
  };

  AbstractMatrix.prototype.tan = function tan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tan = function tan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tan();
  };

  AbstractMatrix.prototype.tanh = function tanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tanh = function tanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tanh();
  };

  AbstractMatrix.prototype.trunc = function trunc() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.trunc(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.trunc = function trunc(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.trunc();
  };

  AbstractMatrix.pow = function pow(matrix, arg0) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.pow(arg0);
  };

  AbstractMatrix.prototype.pow = function pow(value) {
    if (typeof value === 'number') return this.powS(value);
    return this.powM(value);
  };

  AbstractMatrix.prototype.powS = function powS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), value));
      }
    }
    return this;
  };

  AbstractMatrix.prototype.powM = function powM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));
      }
    }
    return this;
  };
}

/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  let max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  let max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns',
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkRowIndices(matrix, rowIndices) {
  if (!isAnyArray.isAnyArray(rowIndices)) {
    throw new TypeError('row indices must be an array');
  }

  for (let i = 0; i < rowIndices.length; i++) {
    if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {
      throw new RangeError('row indices are out of range');
    }
  }
}

function checkColumnIndices(matrix, columnIndices) {
  if (!isAnyArray.isAnyArray(columnIndices)) {
    throw new TypeError('column indices must be an array');
  }

  for (let i = 0; i < columnIndices.length; i++) {
    if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {
      throw new RangeError('column indices are out of range');
    }
  }
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function newArray(length, value = 0) {
  let array = [];
  for (let i = 0; i < length; i++) {
    array.push(value);
  }
  return array;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function checkNonEmpty(matrix) {
  if (matrix.isEmpty()) {
    throw new Error('Empty matrix has no elements to index');
  }
}

function sumByRow(matrix) {
  let sum = newArray(matrix.rows);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  let sum = newArray(matrix.columns);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumAll(matrix) {
  let v = 0;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v += matrix.get(i, j);
    }
  }
  return v;
}

function productByRow(matrix) {
  let sum = newArray(matrix.rows, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productByColumn(matrix) {
  let sum = newArray(matrix.columns, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productAll(matrix) {
  let v = 1;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v *= matrix.get(i, j);
    }
  }
  return v;
}

function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let i = 0; i < rows; i++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean[i];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / cols) / cols);
    }
  }
  return variance;
}

function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let j = 0; j < cols; j++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let i = 0; i < rows; i++) {
      x = matrix.get(i, j) - mean[j];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / rows) / rows);
    }
  }
  return variance;
}

function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size = rows * cols;

  let sum1 = 0;
  let sum2 = 0;
  let x = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean;
      sum1 += x;
      sum2 += x * x;
    }
  }
  if (unbiased) {
    return (sum2 - (sum1 * sum1) / size) / (size - 1);
  } else {
    return (sum2 - (sum1 * sum1) / size) / size;
  }
}

function centerByRow(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[i]);
    }
  }
}

function centerByColumn(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[j]);
    }
  }
}

function centerAll(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean);
    }
  }
}

function getScaleByRow(matrix) {
  const scale = [];
  for (let i = 0; i < matrix.rows; i++) {
    let sum = 0;
    for (let j = 0; j < matrix.columns; j++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByRow(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[i]);
    }
  }
}

function getScaleByColumn(matrix) {
  const scale = [];
  for (let j = 0; j < matrix.columns; j++) {
    let sum = 0;
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByColumn(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[j]);
    }
  }
}

function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j = 0; j < matrix.columns; j++) {
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}

function scaleAll(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale);
    }
  }
}

class AbstractMatrix {
  static from1DArray(newRows, newColumns, newData) {
    let length = newRows * newColumns;
    if (length !== newData.length) {
      throw new RangeError('data length does not match given dimensions');
    }
    let newMatrix = new Matrix(newRows, newColumns);
    for (let row = 0; row < newRows; row++) {
      for (let column = 0; column < newColumns; column++) {
        newMatrix.set(row, column, newData[row * newColumns + column]);
      }
    }
    return newMatrix;
  }

  static rowVector(newData) {
    let vector = new Matrix(1, newData.length);
    for (let i = 0; i < newData.length; i++) {
      vector.set(0, i, newData[i]);
    }
    return vector;
  }

  static columnVector(newData) {
    let vector = new Matrix(newData.length, 1);
    for (let i = 0; i < newData.length; i++) {
      vector.set(i, 0, newData[i]);
    }
    return vector;
  }

  static zeros(rows, columns) {
    return new Matrix(rows, columns);
  }

  static ones(rows, columns) {
    return new Matrix(rows, columns).fill(1);
  }

  static rand(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { random = Math.random } = options;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.set(i, j, random());
      }
    }
    return matrix;
  }

  static randInt(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1000, random = Math.random } = options;
    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');
    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let interval = max - min;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        let value = min + Math.round(random() * interval);
        matrix.set(i, j, value);
      }
    }
    return matrix;
  }

  static eye(rows, columns, value) {
    if (columns === undefined) columns = rows;
    if (value === undefined) value = 1;
    let min = Math.min(rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, value);
    }
    return matrix;
  }

  static diag(data, rows, columns) {
    let l = data.length;
    if (rows === undefined) rows = l;
    if (columns === undefined) columns = rows;
    let min = Math.min(l, rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, data[i]);
    }
    return matrix;
  }

  static min(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static max(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new this(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static checkMatrix(value) {
    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
  }

  static isMatrix(value) {
    return value != null && value.klass === 'Matrix';
  }

  get size() {
    return this.rows * this.columns;
  }

  apply(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        callback.call(this, i, j);
      }
    }
    return this;
  }

  to1DArray() {
    let array = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        array.push(this.get(i, j));
      }
    }
    return array;
  }

  to2DArray() {
    let copy = [];
    for (let i = 0; i < this.rows; i++) {
      copy.push([]);
      for (let j = 0; j < this.columns; j++) {
        copy[i].push(this.get(i, j));
      }
    }
    return copy;
  }

  toJSON() {
    return this.to2DArray();
  }

  isRowVector() {
    return this.rows === 1;
  }

  isColumnVector() {
    return this.columns === 1;
  }

  isVector() {
    return this.rows === 1 || this.columns === 1;
  }

  isSquare() {
    return this.rows === this.columns;
  }

  isEmpty() {
    return this.rows === 0 || this.columns === 0;
  }

  isSymmetric() {
    if (this.isSquare()) {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j <= i; j++) {
          if (this.get(i, j) !== this.get(j, i)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  isEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isEchelonForm = true;
    let checked = false;
    while (i < this.rows && isEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isEchelonForm = false;
          checked = true;
        }
      }
      i++;
    }
    return isEchelonForm;
  }

  isReducedEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isReducedEchelonForm = true;
    let checked = false;
    while (i < this.rows && isReducedEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isReducedEchelonForm = false;
          checked = true;
        }
      }
      for (let k = j + 1; k < this.rows; k++) {
        if (this.get(i, k) !== 0) {
          isReducedEchelonForm = false;
        }
      }
      i++;
    }
    return isReducedEchelonForm;
  }

  echelonForm() {
    let result = this.clone();
    let h = 0;
    let k = 0;
    while (h < result.rows && k < result.columns) {
      let iMax = h;
      for (let i = h; i < result.rows; i++) {
        if (result.get(i, k) > result.get(iMax, k)) {
          iMax = i;
        }
      }
      if (result.get(iMax, k) === 0) {
        k++;
      } else {
        result.swapRows(h, iMax);
        let tmp = result.get(h, k);
        for (let j = k; j < result.columns; j++) {
          result.set(h, j, result.get(h, j) / tmp);
        }
        for (let i = h + 1; i < result.rows; i++) {
          let factor = result.get(i, k) / result.get(h, k);
          result.set(i, k, 0);
          for (let j = k + 1; j < result.columns; j++) {
            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
          }
        }
        h++;
        k++;
      }
    }
    return result;
  }

  reducedEchelonForm() {
    let result = this.echelonForm();
    let m = result.columns;
    let n = result.rows;
    let h = n - 1;
    while (h >= 0) {
      if (result.maxRow(h) === 0) {
        h--;
      } else {
        let p = 0;
        let pivot = false;
        while (p < n && pivot === false) {
          if (result.get(h, p) === 1) {
            pivot = true;
          } else {
            p++;
          }
        }
        for (let i = 0; i < h; i++) {
          let factor = result.get(i, p);
          for (let j = p; j < m; j++) {
            let tmp = result.get(i, j) - factor * result.get(h, j);
            result.set(i, j, tmp);
          }
        }
        h--;
      }
    }
    return result;
  }

  set() {
    throw new Error('set method is unimplemented');
  }

  get() {
    throw new Error('get method is unimplemented');
  }

  repeat(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { rows = 1, columns = 1 } = options;
    if (!Number.isInteger(rows) || rows <= 0) {
      throw new TypeError('rows must be a positive integer');
    }
    if (!Number.isInteger(columns) || columns <= 0) {
      throw new TypeError('columns must be a positive integer');
    }
    let matrix = new Matrix(this.rows * rows, this.columns * columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
      }
    }
    return matrix;
  }

  fill(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, value);
      }
    }
    return this;
  }

  neg() {
    return this.mulS(-1);
  }

  getRow(index) {
    checkRowIndex(this, index);
    let row = [];
    for (let i = 0; i < this.columns; i++) {
      row.push(this.get(index, i));
    }
    return row;
  }

  getRowVector(index) {
    return Matrix.rowVector(this.getRow(index));
  }

  setRow(index, array) {
    checkRowIndex(this, index);
    array = checkRowVector(this, array);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, array[i]);
    }
    return this;
  }

  swapRows(row1, row2) {
    checkRowIndex(this, row1);
    checkRowIndex(this, row2);
    for (let i = 0; i < this.columns; i++) {
      let temp = this.get(row1, i);
      this.set(row1, i, this.get(row2, i));
      this.set(row2, i, temp);
    }
    return this;
  }

  getColumn(index) {
    checkColumnIndex(this, index);
    let column = [];
    for (let i = 0; i < this.rows; i++) {
      column.push(this.get(i, index));
    }
    return column;
  }

  getColumnVector(index) {
    return Matrix.columnVector(this.getColumn(index));
  }

  setColumn(index, array) {
    checkColumnIndex(this, index);
    array = checkColumnVector(this, array);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, array[i]);
    }
    return this;
  }

  swapColumns(column1, column2) {
    checkColumnIndex(this, column1);
    checkColumnIndex(this, column2);
    for (let i = 0; i < this.rows; i++) {
      let temp = this.get(i, column1);
      this.set(i, column1, this.get(i, column2));
      this.set(i, column2, temp);
    }
    return this;
  }

  addRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[j]);
      }
    }
    return this;
  }

  subRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[j]);
      }
    }
    return this;
  }

  mulRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[j]);
      }
    }
    return this;
  }

  divRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[j]);
      }
    }
    return this;
  }

  addColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[i]);
      }
    }
    return this;
  }

  subColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[i]);
      }
    }
    return this;
  }

  mulColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[i]);
      }
    }
    return this;
  }

  divColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[i]);
      }
    }
    return this;
  }

  mulRow(index, value) {
    checkRowIndex(this, index);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, this.get(index, i) * value);
    }
    return this;
  }

  mulColumn(index, value) {
    checkColumnIndex(this, index);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, this.get(i, index) * value);
    }
    return this;
  }

  max(by) {
    if (this.isEmpty()) {
      return NaN;
    }
    switch (by) {
      case 'row': {
        const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max[row]) {
              max[row] = this.get(row, column);
            }
          }
        }
        return max;
      }
      case 'column': {
        const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max[column]) {
              max[column] = this.get(row, column);
            }
          }
        }
        return max;
      }
      case undefined: {
        let max = this.get(0, 0);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max) {
              max = this.get(row, column);
            }
          }
        }
        return max;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  maxIndex() {
    checkNonEmpty(this);
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  min(by) {
    if (this.isEmpty()) {
      return NaN;
    }

    switch (by) {
      case 'row': {
        const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min[row]) {
              min[row] = this.get(row, column);
            }
          }
        }
        return min;
      }
      case 'column': {
        const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min[column]) {
              min[column] = this.get(row, column);
            }
          }
        }
        return min;
      }
      case undefined: {
        let min = this.get(0, 0);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min) {
              min = this.get(row, column);
            }
          }
        }
        return min;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  minIndex() {
    checkNonEmpty(this);
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  maxRow(row) {
    checkRowIndex(this, row);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  maxRowIndex(row) {
    checkRowIndex(this, row);
    checkNonEmpty(this);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  minRow(row) {
    checkRowIndex(this, row);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  minRowIndex(row) {
    checkRowIndex(this, row);
    checkNonEmpty(this);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  maxColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  maxColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  minColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  minColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  diag() {
    let min = Math.min(this.rows, this.columns);
    let diag = [];
    for (let i = 0; i < min; i++) {
      diag.push(this.get(i, i));
    }
    return diag;
  }

  norm(type = 'frobenius') {
    let result = 0;
    if (type === 'max') {
      return this.max();
    } else if (type === 'frobenius') {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j < this.columns; j++) {
          result = result + this.get(i, j) * this.get(i, j);
        }
      }
      return Math.sqrt(result);
    } else {
      throw new RangeError(`unknown norm type: ${type}`);
    }
  }

  cumulativeSum() {
    let sum = 0;
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        sum += this.get(i, j);
        this.set(i, j, sum);
      }
    }
    return this;
  }

  dot(vector2) {
    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
    let vector1 = this.to1DArray();
    if (vector1.length !== vector2.length) {
      throw new RangeError('vectors do not have the same size');
    }
    let dot = 0;
    for (let i = 0; i < vector1.length; i++) {
      dot += vector1[i] * vector2[i];
    }
    return dot;
  }

  mmul(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.columns;

    let result = new Matrix(m, p);

    let Bcolj = new Float64Array(n);
    for (let j = 0; j < p; j++) {
      for (let k = 0; k < n; k++) {
        Bcolj[k] = other.get(k, j);
      }

      for (let i = 0; i < m; i++) {
        let s = 0;
        for (let k = 0; k < n; k++) {
          s += this.get(i, k) * Bcolj[k];
        }

        result.set(i, j, s);
      }
    }
    return result;
  }

  strassen2x2(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(2, 2);
    const a11 = this.get(0, 0);
    const b11 = other.get(0, 0);
    const a12 = this.get(0, 1);
    const b12 = other.get(0, 1);
    const a21 = this.get(1, 0);
    const b21 = other.get(1, 0);
    const a22 = this.get(1, 1);
    const b22 = other.get(1, 1);

    // Compute intermediate values.
    const m1 = (a11 + a22) * (b11 + b22);
    const m2 = (a21 + a22) * b11;
    const m3 = a11 * (b12 - b22);
    const m4 = a22 * (b21 - b11);
    const m5 = (a11 + a12) * b22;
    const m6 = (a21 - a11) * (b11 + b12);
    const m7 = (a12 - a22) * (b21 + b22);

    // Combine intermediate values into the output.
    const c00 = m1 + m4 - m5 + m7;
    const c01 = m3 + m5;
    const c10 = m2 + m4;
    const c11 = m1 - m2 + m3 + m6;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    return result;
  }

  strassen3x3(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(3, 3);

    const a00 = this.get(0, 0);
    const a01 = this.get(0, 1);
    const a02 = this.get(0, 2);
    const a10 = this.get(1, 0);
    const a11 = this.get(1, 1);
    const a12 = this.get(1, 2);
    const a20 = this.get(2, 0);
    const a21 = this.get(2, 1);
    const a22 = this.get(2, 2);

    const b00 = other.get(0, 0);
    const b01 = other.get(0, 1);
    const b02 = other.get(0, 2);
    const b10 = other.get(1, 0);
    const b11 = other.get(1, 1);
    const b12 = other.get(1, 2);
    const b20 = other.get(2, 0);
    const b21 = other.get(2, 1);
    const b22 = other.get(2, 2);

    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
    const m2 = (a00 - a10) * (-b01 + b11);
    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
    const m5 = (a10 + a11) * (-b00 + b01);
    const m6 = a00 * b00;
    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
    const m8 = (-a00 + a20) * (b02 - b12);
    const m9 = (a20 + a21) * (-b00 + b02);
    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
    const m13 = (a02 - a22) * (b11 - b21);
    const m14 = a02 * b20;
    const m15 = (a21 + a22) * (-b20 + b21);
    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
    const m17 = (a02 - a12) * (b12 - b22);
    const m18 = (a11 + a12) * (-b20 + b22);
    const m19 = a01 * b10;
    const m20 = a12 * b21;
    const m21 = a10 * b02;
    const m22 = a20 * b01;
    const m23 = a22 * b22;

    const c00 = m6 + m14 + m19;
    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
    const c11 = m2 + m4 + m5 + m6 + m20;
    const c12 = m14 + m16 + m17 + m18 + m21;
    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
    const c21 = m12 + m13 + m14 + m15 + m22;
    const c22 = m6 + m7 + m8 + m9 + m23;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(0, 2, c02);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    result.set(1, 2, c12);
    result.set(2, 0, c20);
    result.set(2, 1, c21);
    result.set(2, 2, c22);
    return result;
  }

  mmulStrassen(y) {
    y = Matrix.checkMatrix(y);
    let x = this.clone();
    let r1 = x.rows;
    let c1 = x.columns;
    let r2 = y.rows;
    let c2 = y.columns;
    if (c1 !== r2) {
      // eslint-disable-next-line no-console
      console.warn(
        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,
      );
    }

    // Put a matrix into the top left of a matrix of zeros.
    // `rows` and `cols` are the dimensions of the output matrix.
    function embed(mat, rows, cols) {
      let r = mat.rows;
      let c = mat.columns;
      if (r === rows && c === cols) {
        return mat;
      } else {
        let resultat = AbstractMatrix.zeros(rows, cols);
        resultat = resultat.setSubMatrix(mat, 0, 0);
        return resultat;
      }
    }

    // Make sure both matrices are the same size.
    // This is exclusively for simplicity:
    // this algorithm can be implemented with matrices of different sizes.

    let r = Math.max(r1, r2);
    let c = Math.max(c1, c2);
    x = embed(x, r, c);
    y = embed(y, r, c);

    // Our recursive multiplication function.
    function blockMult(a, b, rows, cols) {
      // For small matrices, resort to naive multiplication.
      if (rows <= 512 || cols <= 512) {
        return a.mmul(b); // a is equivalent to this
      }

      // Apply dynamic padding.
      if (rows % 2 === 1 && cols % 2 === 1) {
        a = embed(a, rows + 1, cols + 1);
        b = embed(b, rows + 1, cols + 1);
      } else if (rows % 2 === 1) {
        a = embed(a, rows + 1, cols);
        b = embed(b, rows + 1, cols);
      } else if (cols % 2 === 1) {
        a = embed(a, rows, cols + 1);
        b = embed(b, rows, cols + 1);
      }

      let halfRows = parseInt(a.rows / 2, 10);
      let halfCols = parseInt(a.columns / 2, 10);
      // Subdivide input matrices.
      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

      // Compute intermediate values.
      let m1 = blockMult(
        AbstractMatrix.add(a11, a22),
        AbstractMatrix.add(b11, b22),
        halfRows,
        halfCols,
      );
      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
      let m6 = blockMult(
        AbstractMatrix.sub(a21, a11),
        AbstractMatrix.add(b11, b12),
        halfRows,
        halfCols,
      );
      let m7 = blockMult(
        AbstractMatrix.sub(a12, a22),
        AbstractMatrix.add(b21, b22),
        halfRows,
        halfCols,
      );

      // Combine intermediate values into the output.
      let c11 = AbstractMatrix.add(m1, m4);
      c11.sub(m5);
      c11.add(m7);
      let c12 = AbstractMatrix.add(m3, m5);
      let c21 = AbstractMatrix.add(m2, m4);
      let c22 = AbstractMatrix.sub(m1, m2);
      c22.add(m3);
      c22.add(m6);

      // Crop output to the desired size (undo dynamic padding).
      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
      resultat = resultat.setSubMatrix(c11, 0, 0);
      resultat = resultat.setSubMatrix(c12, c11.rows, 0);
      resultat = resultat.setSubMatrix(c21, 0, c11.columns);
      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
      return resultat.subMatrix(0, rows - 1, 0, cols - 1);
    }

    return blockMult(x, y, r, c);
  }

  scaleRows(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.rows; i++) {
      const row = this.getRow(i);
      if (row.length > 0) {
        rescale__default["default"](row, { min, max, output: row });
      }
      newMatrix.setRow(i, row);
    }
    return newMatrix;
  }

  scaleColumns(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.columns; i++) {
      const column = this.getColumn(i);
      if (column.length) {
        rescale__default["default"](column, {
          min: min,
          max: max,
          output: column,
        });
      }
      newMatrix.setColumn(i, column);
    }
    return newMatrix;
  }

  flipRows() {
    const middle = Math.ceil(this.columns / 2);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < middle; j++) {
        let first = this.get(i, j);
        let last = this.get(i, this.columns - 1 - j);
        this.set(i, j, last);
        this.set(i, this.columns - 1 - j, first);
      }
    }
    return this;
  }

  flipColumns() {
    const middle = Math.ceil(this.rows / 2);
    for (let j = 0; j < this.columns; j++) {
      for (let i = 0; i < middle; i++) {
        let first = this.get(i, j);
        let last = this.get(this.rows - 1 - i, j);
        this.set(i, j, last);
        this.set(this.rows - 1 - i, j, first);
      }
    }
    return this;
  }

  kroneckerProduct(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.rows;
    let q = other.columns;

    let result = new Matrix(m * p, n * q);
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < p; k++) {
          for (let l = 0; l < q; l++) {
            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
          }
        }
      }
    }
    return result;
  }

  kroneckerSum(other) {
    other = Matrix.checkMatrix(other);
    if (!this.isSquare() || !other.isSquare()) {
      throw new Error('Kronecker Sum needs two Square Matrices');
    }
    let m = this.rows;
    let n = other.rows;
    let AxI = this.kroneckerProduct(Matrix.eye(n, n));
    let IxB = Matrix.eye(m, m).kroneckerProduct(other);
    return AxI.add(IxB);
  }

  transpose() {
    let result = new Matrix(this.columns, this.rows);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        result.set(j, i, this.get(i, j));
      }
    }
    return result;
  }

  sortRows(compareFunction = compareNumbers) {
    for (let i = 0; i < this.rows; i++) {
      this.setRow(i, this.getRow(i).sort(compareFunction));
    }
    return this;
  }

  sortColumns(compareFunction = compareNumbers) {
    for (let i = 0; i < this.columns; i++) {
      this.setColumn(i, this.getColumn(i).sort(compareFunction));
    }
    return this;
  }

  subMatrix(startRow, endRow, startColumn, endColumn) {
    checkRange(this, startRow, endRow, startColumn, endColumn);
    let newMatrix = new Matrix(
      endRow - startRow + 1,
      endColumn - startColumn + 1,
    );
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
      }
    }
    return newMatrix;
  }

  subMatrixRow(indices, startColumn, endColumn) {
    if (startColumn === undefined) startColumn = 0;
    if (endColumn === undefined) endColumn = this.columns - 1;
    if (
      startColumn > endColumn ||
      startColumn < 0 ||
      startColumn >= this.columns ||
      endColumn < 0 ||
      endColumn >= this.columns
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (indices[i] < 0 || indices[i] >= this.rows) {
          throw new RangeError(`Row index out of range: ${indices[i]}`);
        }
        newMatrix.set(i, j - startColumn, this.get(indices[i], j));
      }
    }
    return newMatrix;
  }

  subMatrixColumn(indices, startRow, endRow) {
    if (startRow === undefined) startRow = 0;
    if (endRow === undefined) endRow = this.rows - 1;
    if (
      startRow > endRow ||
      startRow < 0 ||
      startRow >= this.rows ||
      endRow < 0 ||
      endRow >= this.rows
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startRow; j <= endRow; j++) {
        if (indices[i] < 0 || indices[i] >= this.columns) {
          throw new RangeError(`Column index out of range: ${indices[i]}`);
        }
        newMatrix.set(j - startRow, i, this.get(j, indices[i]));
      }
    }
    return newMatrix;
  }

  setSubMatrix(matrix, startRow, startColumn) {
    matrix = Matrix.checkMatrix(matrix);
    if (matrix.isEmpty()) {
      return this;
    }
    let endRow = startRow + matrix.rows - 1;
    let endColumn = startColumn + matrix.columns - 1;
    checkRange(this, startRow, endRow, startColumn, endColumn);
    for (let i = 0; i < matrix.rows; i++) {
      for (let j = 0; j < matrix.columns; j++) {
        this.set(startRow + i, startColumn + j, matrix.get(i, j));
      }
    }
    return this;
  }

  selection(rowIndices, columnIndices) {
    checkRowIndices(this, rowIndices);
    checkColumnIndices(this, columnIndices);
    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
    for (let i = 0; i < rowIndices.length; i++) {
      let rowIndex = rowIndices[i];
      for (let j = 0; j < columnIndices.length; j++) {
        let columnIndex = columnIndices[j];
        newMatrix.set(i, j, this.get(rowIndex, columnIndex));
      }
    }
    return newMatrix;
  }

  trace() {
    let min = Math.min(this.rows, this.columns);
    let trace = 0;
    for (let i = 0; i < min; i++) {
      trace += this.get(i, i);
    }
    return trace;
  }

  clone() {
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let row = 0; row < this.rows; row++) {
      for (let column = 0; column < this.columns; column++) {
        newMatrix.set(row, column, this.get(row, column));
      }
    }
    return newMatrix;
  }

  sum(by) {
    switch (by) {
      case 'row':
        return sumByRow(this);
      case 'column':
        return sumByColumn(this);
      case undefined:
        return sumAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  product(by) {
    switch (by) {
      case 'row':
        return productByRow(this);
      case 'column':
        return productByColumn(this);
      case undefined:
        return productAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  mean(by) {
    const sum = this.sum(by);
    switch (by) {
      case 'row': {
        for (let i = 0; i < this.rows; i++) {
          sum[i] /= this.columns;
        }
        return sum;
      }
      case 'column': {
        for (let i = 0; i < this.columns; i++) {
          sum[i] /= this.rows;
        }
        return sum;
      }
      case undefined:
        return sum / this.size;
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  variance(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { unbiased = true, mean = this.mean(by) } = options;
    if (typeof unbiased !== 'boolean') {
      throw new TypeError('unbiased must be a boolean');
    }
    switch (by) {
      case 'row': {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return varianceByRow(this, unbiased, mean);
      }
      case 'column': {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return varianceByColumn(this, unbiased, mean);
      }
      case undefined: {
        if (typeof mean !== 'number') {
          throw new TypeError('mean must be a number');
        }
        return varianceAll(this, unbiased, mean);
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  standardDeviation(by, options) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    const variance = this.variance(by, options);
    if (by === undefined) {
      return Math.sqrt(variance);
    } else {
      for (let i = 0; i < variance.length; i++) {
        variance[i] = Math.sqrt(variance[i]);
      }
      return variance;
    }
  }

  center(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { center = this.mean(by) } = options;
    switch (by) {
      case 'row': {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError('center must be an array');
        }
        centerByRow(this, center);
        return this;
      }
      case 'column': {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError('center must be an array');
        }
        centerByColumn(this, center);
        return this;
      }
      case undefined: {
        if (typeof center !== 'number') {
          throw new TypeError('center must be a number');
        }
        centerAll(this, center);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  scale(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    let scale = options.scale;
    switch (by) {
      case 'row': {
        if (scale === undefined) {
          scale = getScaleByRow(this);
        } else if (!isAnyArray.isAnyArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        scaleByRow(this, scale);
        return this;
      }
      case 'column': {
        if (scale === undefined) {
          scale = getScaleByColumn(this);
        } else if (!isAnyArray.isAnyArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        scaleByColumn(this, scale);
        return this;
      }
      case undefined: {
        if (scale === undefined) {
          scale = getScaleAll(this);
        } else if (typeof scale !== 'number') {
          throw new TypeError('scale must be a number');
        }
        scaleAll(this, scale);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  toString(options) {
    return inspectMatrixWithOptions(this, options);
  }
}

AbstractMatrix.prototype.klass = 'Matrix';
if (typeof Symbol !== 'undefined') {
  AbstractMatrix.prototype[Symbol.for('nodejs.util.inspect.custom')] =
    inspectMatrix;
}

function compareNumbers(a, b) {
  return a - b;
}

function isArrayOfNumbers(array) {
  return array.every((element) => {
    return typeof element === 'number';
  });
}

// Synonyms
AbstractMatrix.random = AbstractMatrix.rand;
AbstractMatrix.randomInt = AbstractMatrix.randInt;
AbstractMatrix.diagonal = AbstractMatrix.diag;
AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
AbstractMatrix.identity = AbstractMatrix.eye;
AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
AbstractMatrix.prototype.tensorProduct =
  AbstractMatrix.prototype.kroneckerProduct;

class Matrix extends AbstractMatrix {
  constructor(nRows, nColumns) {
    super();
    if (Matrix.isMatrix(nRows)) {
      // eslint-disable-next-line no-constructor-return
      return nRows.clone();
    } else if (Number.isInteger(nRows) && nRows >= 0) {
      // Create an empty matrix
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns >= 0) {
        for (let i = 0; i < nRows; i++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError('nColumns must be a positive integer');
      }
    } else if (isAnyArray.isAnyArray(nRows)) {
      // Copy the values from the 2D array
      const arrayData = nRows;
      nRows = arrayData.length;
      nColumns = nRows ? arrayData[0].length : 0;
      if (typeof nColumns !== 'number') {
        throw new TypeError(
          'Data must be a 2D array with at least one element',
        );
      }
      this.data = [];
      for (let i = 0; i < nRows; i++) {
        if (arrayData[i].length !== nColumns) {
          throw new RangeError('Inconsistent array dimensions');
        }
        if (!isArrayOfNumbers(arrayData[i])) {
          throw new TypeError('Input data contains non-numeric values');
        }
        this.data.push(Float64Array.from(arrayData[i]));
      }
    } else {
      throw new TypeError(
        'First argument must be a positive number or an array',
      );
    }
    this.rows = nRows;
    this.columns = nColumns;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }

  removeRow(index) {
    checkRowIndex(this, index);
    this.data.splice(index, 1);
    this.rows -= 1;
    return this;
  }

  addRow(index, array) {
    if (array === undefined) {
      array = index;
      index = this.rows;
    }
    checkRowIndex(this, index, true);
    array = Float64Array.from(checkRowVector(this, array));
    this.data.splice(index, 0, array);
    this.rows += 1;
    return this;
  }

  removeColumn(index) {
    checkColumnIndex(this, index);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns - 1);
      for (let j = 0; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      for (let j = index + 1; j < this.columns; j++) {
        newRow[j - 1] = this.data[i][j];
      }
      this.data[i] = newRow;
    }
    this.columns -= 1;
    return this;
  }

  addColumn(index, array) {
    if (typeof array === 'undefined') {
      array = index;
      index = this.columns;
    }
    checkColumnIndex(this, index, true);
    array = checkColumnVector(this, array);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns + 1);
      let j = 0;
      for (; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      newRow[j++] = array[i];
      for (; j < this.columns + 1; j++) {
        newRow[j] = this.data[i][j - 1];
      }
      this.data[i] = newRow;
    }
    this.columns += 1;
    return this;
  }
}

installMathOperations(AbstractMatrix, Matrix);

class BaseView extends AbstractMatrix {
  constructor(matrix, rows, columns) {
    super();
    this.matrix = matrix;
    this.rows = rows;
    this.columns = columns;
  }
}

class MatrixColumnView extends BaseView {
  constructor(matrix, column) {
    checkColumnIndex(matrix, column);
    super(matrix, matrix.rows, 1);
    this.column = column;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.column, value);
    return this;
  }

  get(rowIndex) {
    return this.matrix.get(rowIndex, this.column);
  }
}

class MatrixColumnSelectionView extends BaseView {
  constructor(matrix, columnIndices) {
    checkColumnIndices(matrix, columnIndices);
    super(matrix, matrix.rows, columnIndices.length);
    this.columnIndices = columnIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
  }
}

class MatrixFlipColumnView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
  }
}

class MatrixFlipRowView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
  }
}

class MatrixRowView extends BaseView {
  constructor(matrix, row) {
    checkRowIndex(matrix, row);
    super(matrix, 1, matrix.columns);
    this.row = row;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.row, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.row, columnIndex);
  }
}

class MatrixRowSelectionView extends BaseView {
  constructor(matrix, rowIndices) {
    checkRowIndices(matrix, rowIndices);
    super(matrix, rowIndices.length, matrix.columns);
    this.rowIndices = rowIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
  }
}

class MatrixSelectionView extends BaseView {
  constructor(matrix, rowIndices, columnIndices) {
    checkRowIndices(matrix, rowIndices);
    checkColumnIndices(matrix, columnIndices);
    super(matrix, rowIndices.length, columnIndices.length);
    this.rowIndices = rowIndices;
    this.columnIndices = columnIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
    );
  }
}

class MatrixSubView extends BaseView {
  constructor(matrix, startRow, endRow, startColumn, endColumn) {
    checkRange(matrix, startRow, endRow, startColumn, endColumn);
    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
    this.startRow = startRow;
    this.startColumn = startColumn;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
    );
  }
}

class MatrixTransposeView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.columns, matrix.rows);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(columnIndex, rowIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(columnIndex, rowIndex);
  }
}

class WrapperMatrix1D extends AbstractMatrix {
  constructor(data, options = {}) {
    const { rows = 1 } = options;

    if (data.length % rows !== 0) {
      throw new Error('the data length is not divisible by the number of rows');
    }
    super();
    this.rows = rows;
    this.columns = data.length / rows;
    this.data = data;
  }

  set(rowIndex, columnIndex, value) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    this.data[index] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    return this.data[index];
  }

  _calculateIndex(row, column) {
    return row * this.columns + column;
  }
}

class WrapperMatrix2D extends AbstractMatrix {
  constructor(data) {
    super();
    this.data = data;
    this.rows = data.length;
    this.columns = data[0].length;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
}

function wrap(array, options) {
  if (isAnyArray.isAnyArray(array)) {
    if (array[0] && isAnyArray.isAnyArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error('the argument is not an array');
  }
}

class LuDecomposition {
  constructor(matrix) {
    matrix = WrapperMatrix2D.checkMatrix(matrix);

    let lu = matrix.clone();
    let rows = lu.rows;
    let columns = lu.columns;
    let pivotVector = new Float64Array(rows);
    let pivotSign = 1;
    let i, j, k, p, s, t, v;
    let LUcolj, kmax;

    for (i = 0; i < rows; i++) {
      pivotVector[i] = i;
    }

    LUcolj = new Float64Array(rows);

    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        LUcolj[i] = lu.get(i, j);
      }

      for (i = 0; i < rows; i++) {
        kmax = Math.min(i, j);
        s = 0;
        for (k = 0; k < kmax; k++) {
          s += lu.get(i, k) * LUcolj[k];
        }
        LUcolj[i] -= s;
        lu.set(i, j, LUcolj[i]);
      }

      p = j;
      for (i = j + 1; i < rows; i++) {
        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
          p = i;
        }
      }

      if (p !== j) {
        for (k = 0; k < columns; k++) {
          t = lu.get(p, k);
          lu.set(p, k, lu.get(j, k));
          lu.set(j, k, t);
        }

        v = pivotVector[p];
        pivotVector[p] = pivotVector[j];
        pivotVector[j] = v;

        pivotSign = -pivotSign;
      }

      if (j < rows && lu.get(j, j) !== 0) {
        for (i = j + 1; i < rows; i++) {
          lu.set(i, j, lu.get(i, j) / lu.get(j, j));
        }
      }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
  }

  isSingular() {
    let data = this.LU;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      if (data.get(j, j) === 0) {
        return true;
      }
    }
    return false;
  }

  solve(value) {
    value = Matrix.checkMatrix(value);

    let lu = this.LU;
    let rows = lu.rows;

    if (rows !== value.rows) {
      throw new Error('Invalid matrix dimensions');
    }
    if (this.isSingular()) {
      throw new Error('LU matrix is singular');
    }

    let count = value.columns;
    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
    let columns = lu.columns;
    let i, j, k;

    for (k = 0; k < columns; k++) {
      for (i = k + 1; i < columns; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    for (k = columns - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / lu.get(k, k));
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    return X;
  }

  get determinant() {
    let data = this.LU;
    if (!data.isSquare()) {
      throw new Error('Matrix must be square');
    }
    let determinant = this.pivotSign;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      determinant *= data.get(j, j);
    }
    return determinant;
  }

  get lowerTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i > j) {
          X.set(i, j, data.get(i, j));
        } else if (i === j) {
          X.set(i, j, 1);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get upperTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i <= j) {
          X.set(i, j, data.get(i, j));
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get pivotPermutationVector() {
    return Array.from(this.pivotVector);
  }
}

function hypotenuse(a, b) {
  let r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

class QrDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);

    let qr = value.clone();
    let m = value.rows;
    let n = value.columns;
    let rdiag = new Float64Array(n);
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      let nrm = 0;
      for (i = k; i < m; i++) {
        nrm = hypotenuse(nrm, qr.get(i, k));
      }
      if (nrm !== 0) {
        if (qr.get(k, k) < 0) {
          nrm = -nrm;
        }
        for (i = k; i < m; i++) {
          qr.set(i, k, qr.get(i, k) / nrm);
        }
        qr.set(k, k, qr.get(k, k) + 1);
        for (j = k + 1; j < n; j++) {
          s = 0;
          for (i = k; i < m; i++) {
            s += qr.get(i, k) * qr.get(i, j);
          }
          s = -s / qr.get(k, k);
          for (i = k; i < m; i++) {
            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
          }
        }
      }
      rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
  }

  solve(value) {
    value = Matrix.checkMatrix(value);

    let qr = this.QR;
    let m = qr.rows;

    if (value.rows !== m) {
      throw new Error('Matrix row dimensions must agree');
    }
    if (!this.isFullRank()) {
      throw new Error('Matrix is rank deficient');
    }

    let count = value.columns;
    let X = value.clone();
    let n = qr.columns;
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      for (j = 0; j < count; j++) {
        s = 0;
        for (i = k; i < m; i++) {
          s += qr.get(i, k) * X.get(i, j);
        }
        s = -s / qr.get(k, k);
        for (i = k; i < m; i++) {
          X.set(i, j, X.get(i, j) + s * qr.get(i, k));
        }
      }
    }
    for (k = n - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / this.Rdiag[k]);
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
        }
      }
    }

    return X.subMatrix(0, n - 1, 0, count - 1);
  }

  isFullRank() {
    let columns = this.QR.columns;
    for (let i = 0; i < columns; i++) {
      if (this.Rdiag[i] === 0) {
        return false;
      }
    }
    return true;
  }

  get upperTriangularMatrix() {
    let qr = this.QR;
    let n = qr.columns;
    let X = new Matrix(n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        if (i < j) {
          X.set(i, j, qr.get(i, j));
        } else if (i === j) {
          X.set(i, j, this.Rdiag[i]);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get orthogonalMatrix() {
    let qr = this.QR;
    let rows = qr.rows;
    let columns = qr.columns;
    let X = new Matrix(rows, columns);
    let i, j, k, s;

    for (k = columns - 1; k >= 0; k--) {
      for (i = 0; i < rows; i++) {
        X.set(i, k, 0);
      }
      X.set(k, k, 1);
      for (j = k; j < columns; j++) {
        if (qr.get(k, k) !== 0) {
          s = 0;
          for (i = k; i < rows; i++) {
            s += qr.get(i, k) * X.get(i, j);
          }

          s = -s / qr.get(k, k);

          for (i = k; i < rows; i++) {
            X.set(i, j, X.get(i, j) + s * qr.get(i, k));
          }
        }
      }
    }
    return X;
  }
}

class SingularValueDecomposition {
  constructor(value, options = {}) {
    value = WrapperMatrix2D.checkMatrix(value);

    if (value.isEmpty()) {
      throw new Error('Matrix must be non-empty');
    }

    let m = value.rows;
    let n = value.columns;

    const {
      computeLeftSingularVectors = true,
      computeRightSingularVectors = true,
      autoTranspose = false,
    } = options;

    let wantu = Boolean(computeLeftSingularVectors);
    let wantv = Boolean(computeRightSingularVectors);

    let swapped = false;
    let a;
    if (m < n) {
      if (!autoTranspose) {
        a = value.clone();
        // eslint-disable-next-line no-console
        console.warn(
          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',
        );
      } else {
        a = value.transpose();
        m = a.rows;
        n = a.columns;
        swapped = true;
        let aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a = value.clone();
    }

    let nu = Math.min(m, n);
    let ni = Math.min(m + 1, n);
    let s = new Float64Array(ni);
    let U = new Matrix(m, nu);
    let V = new Matrix(n, n);

    let e = new Float64Array(n);
    let work = new Float64Array(m);

    let si = new Float64Array(ni);
    for (let i = 0; i < ni; i++) si[i] = i;

    let nct = Math.min(m - 1, n);
    let nrt = Math.max(0, Math.min(n - 2, m));
    let mrc = Math.max(nct, nrt);

    for (let k = 0; k < mrc; k++) {
      if (k < nct) {
        s[k] = 0;
        for (let i = k; i < m; i++) {
          s[k] = hypotenuse(s[k], a.get(i, k));
        }
        if (s[k] !== 0) {
          if (a.get(k, k) < 0) {
            s[k] = -s[k];
          }
          for (let i = k; i < m; i++) {
            a.set(i, k, a.get(i, k) / s[k]);
          }
          a.set(k, k, a.get(k, k) + 1);
        }
        s[k] = -s[k];
      }

      for (let j = k + 1; j < n; j++) {
        if (k < nct && s[k] !== 0) {
          let t = 0;
          for (let i = k; i < m; i++) {
            t += a.get(i, k) * a.get(i, j);
          }
          t = -t / a.get(k, k);
          for (let i = k; i < m; i++) {
            a.set(i, j, a.get(i, j) + t * a.get(i, k));
          }
        }
        e[j] = a.get(k, j);
      }

      if (wantu && k < nct) {
        for (let i = k; i < m; i++) {
          U.set(i, k, a.get(i, k));
        }
      }

      if (k < nrt) {
        e[k] = 0;
        for (let i = k + 1; i < n; i++) {
          e[k] = hypotenuse(e[k], e[i]);
        }
        if (e[k] !== 0) {
          if (e[k + 1] < 0) {
            e[k] = 0 - e[k];
          }
          for (let i = k + 1; i < n; i++) {
            e[i] /= e[k];
          }
          e[k + 1] += 1;
        }
        e[k] = -e[k];
        if (k + 1 < m && e[k] !== 0) {
          for (let i = k + 1; i < m; i++) {
            work[i] = 0;
          }
          for (let i = k + 1; i < m; i++) {
            for (let j = k + 1; j < n; j++) {
              work[i] += e[j] * a.get(i, j);
            }
          }
          for (let j = k + 1; j < n; j++) {
            let t = -e[j] / e[k + 1];
            for (let i = k + 1; i < m; i++) {
              a.set(i, j, a.get(i, j) + t * work[i]);
            }
          }
        }
        if (wantv) {
          for (let i = k + 1; i < n; i++) {
            V.set(i, k, e[i]);
          }
        }
      }
    }

    let p = Math.min(n, m + 1);
    if (nct < n) {
      s[nct] = a.get(nct, nct);
    }
    if (m < p) {
      s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
      e[nrt] = a.get(nrt, p - 1);
    }
    e[p - 1] = 0;

    if (wantu) {
      for (let j = nct; j < nu; j++) {
        for (let i = 0; i < m; i++) {
          U.set(i, j, 0);
        }
        U.set(j, j, 1);
      }
      for (let k = nct - 1; k >= 0; k--) {
        if (s[k] !== 0) {
          for (let j = k + 1; j < nu; j++) {
            let t = 0;
            for (let i = k; i < m; i++) {
              t += U.get(i, k) * U.get(i, j);
            }
            t = -t / U.get(k, k);
            for (let i = k; i < m; i++) {
              U.set(i, j, U.get(i, j) + t * U.get(i, k));
            }
          }
          for (let i = k; i < m; i++) {
            U.set(i, k, -U.get(i, k));
          }
          U.set(k, k, 1 + U.get(k, k));
          for (let i = 0; i < k - 1; i++) {
            U.set(i, k, 0);
          }
        } else {
          for (let i = 0; i < m; i++) {
            U.set(i, k, 0);
          }
          U.set(k, k, 1);
        }
      }
    }

    if (wantv) {
      for (let k = n - 1; k >= 0; k--) {
        if (k < nrt && e[k] !== 0) {
          for (let j = k + 1; j < n; j++) {
            let t = 0;
            for (let i = k + 1; i < n; i++) {
              t += V.get(i, k) * V.get(i, j);
            }
            t = -t / V.get(k + 1, k);
            for (let i = k + 1; i < n; i++) {
              V.set(i, j, V.get(i, j) + t * V.get(i, k));
            }
          }
        }
        for (let i = 0; i < n; i++) {
          V.set(i, k, 0);
        }
        V.set(k, k, 1);
      }
    }

    let pp = p - 1;
    let eps = Number.EPSILON;
    while (p > 0) {
      let k, kase;
      for (k = p - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        const alpha =
          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
          e[k] = 0;
          break;
        }
      }
      if (k === p - 2) {
        kase = 4;
      } else {
        let ks;
        for (ks = p - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          let t =
            (ks !== p ? Math.abs(e[ks]) : 0) +
            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
          if (Math.abs(s[ks]) <= eps * t) {
            s[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }

      k++;

      switch (kase) {
        case 1: {
          let f = e[p - 2];
          e[p - 2] = 0;
          for (let j = p - 2; j >= k; j--) {
            let t = hypotenuse(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            if (j !== k) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                V.set(i, j, t);
              }
            }
          }
          break;
        }
        case 2: {
          let f = e[k - 1];
          e[k - 1] = 0;
          for (let j = k; j < p; j++) {
            let t = hypotenuse(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if (wantu) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                U.set(i, j, t);
              }
            }
          }
          break;
        }
        case 3: {
          const scale = Math.max(
            Math.abs(s[p - 1]),
            Math.abs(s[p - 2]),
            Math.abs(e[p - 2]),
            Math.abs(s[k]),
            Math.abs(e[k]),
          );
          const sp = s[p - 1] / scale;
          const spm1 = s[p - 2] / scale;
          const epm1 = e[p - 2] / scale;
          const sk = s[k] / scale;
          const ek = e[k] / scale;
          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
          const c = sp * epm1 * (sp * epm1);
          let shift = 0;
          if (b !== 0 || c !== 0) {
            if (b < 0) {
              shift = 0 - Math.sqrt(b * b + c);
            } else {
              shift = Math.sqrt(b * b + c);
            }
            shift = c / (b + shift);
          }
          let f = (sk + sp) * (sk - sp) + shift;
          let g = sk * ek;
          for (let j = k; j < p - 1; j++) {
            let t = hypotenuse(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            let cs = f / t;
            let sn = g / t;
            if (j !== k) {
              e[j - 1] = t;
            }
            f = cs * s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * s[j];
            g = sn * s[j + 1];
            s[j + 1] = cs * s[j + 1];
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                V.set(i, j, t);
              }
            }
            t = hypotenuse(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            cs = f / t;
            sn = g / t;
            s[j] = t;
            f = cs * e[j] + sn * s[j + 1];
            s[j + 1] = -sn * e[j] + cs * s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if (wantu && j < m - 1) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                U.set(i, j, t);
              }
            }
          }
          e[p - 2] = f;
          break;
        }
        case 4: {
          if (s[k] <= 0) {
            s[k] = s[k] < 0 ? -s[k] : 0;
            if (wantv) {
              for (let i = 0; i <= pp; i++) {
                V.set(i, k, -V.get(i, k));
              }
            }
          }
          while (k < pp) {
            if (s[k] >= s[k + 1]) {
              break;
            }
            let t = s[k];
            s[k] = s[k + 1];
            s[k + 1] = t;
            if (wantv && k < n - 1) {
              for (let i = 0; i < n; i++) {
                t = V.get(i, k + 1);
                V.set(i, k + 1, V.get(i, k));
                V.set(i, k, t);
              }
            }
            if (wantu && k < m - 1) {
              for (let i = 0; i < m; i++) {
                t = U.get(i, k + 1);
                U.set(i, k + 1, U.get(i, k));
                U.set(i, k, t);
              }
            }
            k++;
          }
          p--;
          break;
        }
        // no default
      }
    }

    if (swapped) {
      let tmp = V;
      V = U;
      U = tmp;
    }

    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
  }

  solve(value) {
    let Y = value;
    let e = this.threshold;
    let scols = this.s.length;
    let Ls = Matrix.zeros(scols, scols);

    for (let i = 0; i < scols; i++) {
      if (Math.abs(this.s[i]) <= e) {
        Ls.set(i, i, 0);
      } else {
        Ls.set(i, i, 1 / this.s[i]);
      }
    }

    let U = this.U;
    let V = this.rightSingularVectors;

    let VL = V.mmul(Ls);
    let vrows = V.rows;
    let urows = U.rows;
    let VLU = Matrix.zeros(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < scols; k++) {
          sum += VL.get(i, k) * U.get(j, k);
        }
        VLU.set(i, j, sum);
      }
    }

    return VLU.mmul(Y);
  }

  solveForDiagonal(value) {
    return this.solve(Matrix.diag(value));
  }

  inverse() {
    let V = this.V;
    let e = this.threshold;
    let vrows = V.rows;
    let vcols = V.columns;
    let X = new Matrix(vrows, this.s.length);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < vcols; j++) {
        if (Math.abs(this.s[j]) > e) {
          X.set(i, j, V.get(i, j) / this.s[j]);
        }
      }
    }

    let U = this.U;

    let urows = U.rows;
    let ucols = U.columns;
    let Y = new Matrix(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < ucols; k++) {
          sum += X.get(i, k) * U.get(j, k);
        }
        Y.set(i, j, sum);
      }
    }

    return Y;
  }

  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  }

  get norm2() {
    return this.s[0];
  }

  get rank() {
    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    let r = 0;
    let s = this.s;
    for (let i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  }

  get diagonal() {
    return Array.from(this.s);
  }

  get threshold() {
    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
  }

  get leftSingularVectors() {
    return this.U;
  }

  get rightSingularVectors() {
    return this.V;
  }

  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}

function inverse(matrix, useSVD = false) {
  matrix = WrapperMatrix2D.checkMatrix(matrix);
  if (useSVD) {
    return new SingularValueDecomposition(matrix).inverse();
  } else {
    return solve(matrix, Matrix.eye(matrix.rows));
  }
}

function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare()
      ? new LuDecomposition(leftHandSide).solve(rightHandSide)
      : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}

function determinant(matrix) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isSquare()) {
    if (matrix.columns === 0) {
      return 1;
    }

    let a, b, c, d;
    if (matrix.columns === 2) {
      // 2 x 2 matrix
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(1, 0);
      d = matrix.get(1, 1);

      return a * d - b * c;
    } else if (matrix.columns === 3) {
      // 3 x 3 matrix
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(0, 2);

      return (
        a * determinant(subMatrix0) -
        b * determinant(subMatrix1) +
        c * determinant(subMatrix2)
      );
    } else {
      // general purpose determinant using the LU decomposition
      return new LuDecomposition(matrix).determinant;
    }
  } else {
    throw Error('determinant can only be calculated for a square matrix');
  }
}

function xrange(n, exception) {
  let range = [];
  for (let i = 0; i < n; i++) {
    if (i !== exception) {
      range.push(i);
    }
  }
  return range;
}

function dependenciesOneRow(
  error,
  matrix,
  index,
  thresholdValue = 10e-10,
  thresholdError = 10e-10,
) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index, [0]);
    for (let i = 0; i < returnArray.rows; i++) {
      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
        returnArray.set(i, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}

function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;
  matrix = Matrix.checkMatrix(matrix);

  let n = matrix.rows;
  let results = new Matrix(n, n);

  for (let i = 0; i < n; i++) {
    let b = Matrix.columnVector(matrix.getRow(i));
    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();
    let svd = new SingularValueDecomposition(Abis);
    let x = svd.solve(b);
    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();
    results.setRow(
      i,
      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),
    );
  }
  return results;
}

function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isEmpty()) {
    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular
    // (0xn)*(nx0)*(0xn) = 0xn
    // (nx0)*(0xn)*(nx0) = nx0
    return matrix.transpose();
  }
  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });

  let U = svdSolution.leftSingularVectors;
  let V = svdSolution.rightSingularVectors;
  let s = svdSolution.diagonal;

  for (let i = 0; i < s.length; i++) {
    if (Math.abs(s[i]) > threshold) {
      s[i] = 1.0 / s[i];
    } else {
      s[i] = 0.0;
    }
  }

  return V.mmul(Matrix.diag(s).mmul(U.transpose()));
}

function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !Matrix.isMatrix(yMatrix) &&
    !isAnyArray.isAnyArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center('column');
    if (!yIsSame) {
      yMatrix = yMatrix.center('column');
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < cov.rows; i++) {
    for (let j = 0; j < cov.columns; j++) {
      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}

function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !Matrix.isMatrix(yMatrix) &&
    !isAnyArray.isAnyArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }

  const { center = true, scale = true } = options;
  if (center) {
    xMatrix.center('column');
    if (!yIsSame) {
      yMatrix.center('column');
    }
  }
  if (scale) {
    xMatrix.scale('column');
    if (!yIsSame) {
      yMatrix.scale('column');
    }
  }

  const sdx = xMatrix.standardDeviation('column', { unbiased: true });
  const sdy = yIsSame
    ? sdx
    : yMatrix.standardDeviation('column', { unbiased: true });

  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < corr.rows; i++) {
    for (let j = 0; j < corr.columns; j++) {
      corr.set(
        i,
        j,
        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),
      );
    }
  }
  return corr;
}

class EigenvalueDecomposition {
  constructor(matrix, options = {}) {
    const { assumeSymmetric = false } = options;

    matrix = WrapperMatrix2D.checkMatrix(matrix);
    if (!matrix.isSquare()) {
      throw new Error('Matrix is not a square matrix');
    }

    if (matrix.isEmpty()) {
      throw new Error('Matrix must be non-empty');
    }

    let n = matrix.columns;
    let V = new Matrix(n, n);
    let d = new Float64Array(n);
    let e = new Float64Array(n);
    let value = matrix;
    let i, j;

    let isSymmetric = false;
    if (assumeSymmetric) {
      isSymmetric = true;
    } else {
      isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V.set(i, j, value.get(i, j));
        }
      }
      tred2(n, e, d, V);
      tql2(n, e, d, V);
    } else {
      let H = new Matrix(n, n);
      let ort = new Float64Array(n);
      for (j = 0; j < n; j++) {
        for (i = 0; i < n; i++) {
          H.set(i, j, value.get(i, j));
        }
      }
      orthes(n, H, ort, V);
      hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
  }

  get realEigenvalues() {
    return Array.from(this.d);
  }

  get imaginaryEigenvalues() {
    return Array.from(this.e);
  }

  get eigenvectorMatrix() {
    return this.V;
  }

  get diagonalMatrix() {
    let n = this.n;
    let e = this.e;
    let d = this.d;
    let X = new Matrix(n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i, j, 0);
      }
      X.set(i, i, d[i]);
      if (e[i] > 0) {
        X.set(i, i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i, i - 1, e[i]);
      }
    }
    return X;
  }
}

function tred2(n, e, d, V) {
  let f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
        V.set(j, i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j, i, f);
        g = e[j] + V.get(j, j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k, j) * d[k];
          e[k] += V.get(k, j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1, i, V.get(i, i));
    V.set(i, i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k, i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k, i + 1) * V.get(k, j);
        }
        for (k = 0; k <= i; k++) {
          V.set(k, j, V.get(k, j) - g * d[k]);
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k, i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
    V.set(n - 1, j, 0);
  }

  V.set(n - 1, n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  let f = 0;
  let tst1 = 0;
  let eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      do {

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k, i + 1);
            V.set(k, i + 1, s * V.get(k, i) + c * h);
            V.set(k, i, c * V.get(k, i) - s * h);
          }
        }

        p = (-s * s2 * c3 * el1 * e[l]) / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j, i);
        V.set(j, i, V.get(j, k));
        V.set(j, k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  let low = 0;
  let high = n - 1;
  let f, g, h, i, j, m;
  let scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i, m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i, m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i, j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.set(i, j, H.get(i, j) - f * ort[i]);
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i, j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.set(i, j, H.get(i, j) - f * ort[j]);
        }
      }

      ort[m] = scale * ort[m];
      H.set(m, m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i, j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m, m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i, m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i, j);
        }

        g = g / ort[m] / H.get(m, m - 1);
        for (i = m; i <= high; i++) {
          V.set(i, j, V.get(i, j) + g * ort[i]);
        }
      }
    }
  }
}

function hqr2(nn, e, d, V, H) {
  let n = nn - 1;
  let low = 0;
  let high = nn - 1;
  let eps = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p = 0;
  let q = 0;
  let r = 0;
  let s = 0;
  let z = 0;
  let iter = 0;
  let i, j, k, l, m, t, w, x, y;
  let ra, sa, vr, vi;
  let notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i, i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i, j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l, l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.set(n, n, H.get(n, n) + exshift);
      d[n] = H.get(n, n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n, n - 1) * H.get(n - 1, n);
      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.set(n, n, H.get(n, n) + exshift);
      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
      x = H.get(n, n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n, n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1, j);
          H.set(n - 1, j, q * z + p * H.get(n, j));
          H.set(n, j, q * H.get(n, j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i, n - 1);
          H.set(i, n - 1, q * z + p * H.get(i, n));
          H.set(i, n, q * H.get(i, n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i, n - 1);
          V.set(i, n - 1, q * z + p * V.get(i, n));
          V.set(i, n, q * V.get(i, n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n, n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1, n - 1);
        w = H.get(n, n - 1) * H.get(n - 1, n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.set(i, i, H.get(i, i) - x);
        }
        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.set(i, i, H.get(i, i) - s);
          }
          exshift += s;
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m, m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
        q = H.get(m + 1, m + 1) - z - r - s;
        r = H.get(m + 2, m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1, m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1, m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i, i - 2, 0);
        if (i > m + 2) {
          H.set(i, i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k, k - 1);
          q = H.get(k + 1, k - 1);
          r = notlast ? H.get(k + 2, k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k, k - 1, -s * x);
          } else if (l !== m) {
            H.set(k, k - 1, -H.get(k, k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k, j) + q * H.get(k + 1, j);
            if (notlast) {
              p = p + r * H.get(k + 2, j);
              H.set(k + 2, j, H.get(k + 2, j) - p * z);
            }

            H.set(k, j, H.get(k, j) - p * x);
            H.set(k + 1, j, H.get(k + 1, j) - p * y);
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i, k) + y * H.get(i, k + 1);
            if (notlast) {
              p = p + z * H.get(i, k + 2);
              H.set(i, k + 2, H.get(i, k + 2) - p * r);
            }

            H.set(i, k, H.get(i, k) - p);
            H.set(i, k + 1, H.get(i, k + 1) - p * q);
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i, k) + y * V.get(i, k + 1);
            if (notlast) {
              p = p + z * V.get(i, k + 2);
              V.set(i, k + 2, V.get(i, k + 2) - p * r);
            }

            V.set(i, k, V.get(i, k) - p);
            V.set(i, k + 1, V.get(i, k + 1) - p * q);
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n, n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i, i) - p;
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i, j) * H.get(j, n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i, n, t);
            H.set(
              i + 1,
              n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,
            );
          }

          t = Math.abs(H.get(i, n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
        H.set(n - 1, n - 1, q / H.get(n, n - 1));
        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
        H.set(n - 1, n - 1, cdivres[0]);
        H.set(n - 1, n, cdivres[1]);
      }

      H.set(n, n - 1, 0);
      H.set(n, n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i, j) * H.get(j, n - 1);
          sa = sa + H.get(i, j) * H.get(j, n);
        }

        w = H.get(i, i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi,
            );
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(
                i + 1,
                n - 1,
                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,
              );
              H.set(
                i + 1,
                n,
                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,
              );
            } else {
              cdivres = cdiv(
                -r - y * H.get(i, n - 1),
                -s - y * H.get(i, n),
                z,
                q,
              );
              H.set(i + 1, n - 1, cdivres[0]);
              H.set(i + 1, n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n - 1, H.get(j, n - 1) / t);
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i, j, H.get(i, j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i, k) * H.get(k, j);
      }
      V.set(i, j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  let r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

class CholeskyDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);
    if (!value.isSymmetric()) {
      throw new Error('Matrix is not symmetric');
    }

    let a = value;
    let dimension = a.rows;
    let l = new Matrix(dimension, dimension);
    let positiveDefinite = true;
    let i, j, k;

    for (j = 0; j < dimension; j++) {
      let d = 0;
      for (k = 0; k < j; k++) {
        let s = 0;
        for (i = 0; i < k; i++) {
          s += l.get(k, i) * l.get(j, i);
        }
        s = (a.get(j, k) - s) / l.get(k, k);
        l.set(j, k, s);
        d = d + s * s;
      }

      d = a.get(j, j) - d;

      positiveDefinite &= d > 0;
      l.set(j, j, Math.sqrt(Math.max(d, 0)));
      for (k = j + 1; k < dimension; k++) {
        l.set(j, k, 0);
      }
    }

    this.L = l;
    this.positiveDefinite = Boolean(positiveDefinite);
  }

  isPositiveDefinite() {
    return this.positiveDefinite;
  }

  solve(value) {
    value = WrapperMatrix2D.checkMatrix(value);

    let l = this.L;
    let dimension = l.rows;

    if (value.rows !== dimension) {
      throw new Error('Matrix dimensions do not match');
    }
    if (this.isPositiveDefinite() === false) {
      throw new Error('Matrix is not positive definite');
    }

    let count = value.columns;
    let B = value.clone();
    let i, j, k;

    for (k = 0; k < dimension; k++) {
      for (j = 0; j < count; j++) {
        for (i = 0; i < k; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    for (k = dimension - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        for (i = k + 1; i < dimension; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    return B;
  }

  get lowerTriangularMatrix() {
    return this.L;
  }
}

class nipals {
  constructor(X, options = {}) {
    X = WrapperMatrix2D.checkMatrix(X);
    let { Y } = options;
    const {
      scaleScores = false,
      maxIterations = 1000,
      terminationCriteria = 1e-10,
    } = options;

    let u;
    if (Y) {
      if (isAnyArray.isAnyArray(Y) && typeof Y[0] === 'number') {
        Y = Matrix.columnVector(Y);
      } else {
        Y = WrapperMatrix2D.checkMatrix(Y);
      }
      if (Y.rows !== X.rows) {
        throw new Error('Y should have the same number of rows as X');
      }
      u = Y.getColumnVector(0);
    } else {
      u = X.getColumnVector(0);
    }

    let diff = 1;
    let t, q, w, tOld;

    for (
      let counter = 0;
      counter < maxIterations && diff > terminationCriteria;
      counter++
    ) {
      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
      w = w.div(w.norm());

      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));

      if (counter > 0) {
        diff = t.clone().sub(tOld).pow(2).sum();
      }
      tOld = t.clone();

      if (Y) {
        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
        q = q.div(q.norm());

        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
      } else {
        u = t;
      }
    }

    if (Y) {
      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      p = p.div(p.norm());
      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      let yResidual = Y.clone().sub(
        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),
      );

      this.t = t;
      this.p = p.transpose();
      this.w = w.transpose();
      this.q = q;
      this.u = u;
      this.s = t.transpose().mmul(t);
      this.xResidual = xResidual;
      this.yResidual = yResidual;
      this.betas = residual;
    } else {
      this.w = w.transpose();
      this.s = t.transpose().mmul(t).sqrt();
      if (scaleScores) {
        this.t = t.clone().div(this.s.get(0, 0));
      } else {
        this.t = t;
      }
      this.xResidual = X.sub(t.mmul(w.transpose()));
    }
  }
}

exports.AbstractMatrix = AbstractMatrix;
exports.CHO = CholeskyDecomposition;
exports.CholeskyDecomposition = CholeskyDecomposition;
exports.EVD = EigenvalueDecomposition;
exports.EigenvalueDecomposition = EigenvalueDecomposition;
exports.LU = LuDecomposition;
exports.LuDecomposition = LuDecomposition;
exports.Matrix = Matrix;
exports.MatrixColumnSelectionView = MatrixColumnSelectionView;
exports.MatrixColumnView = MatrixColumnView;
exports.MatrixFlipColumnView = MatrixFlipColumnView;
exports.MatrixFlipRowView = MatrixFlipRowView;
exports.MatrixRowSelectionView = MatrixRowSelectionView;
exports.MatrixRowView = MatrixRowView;
exports.MatrixSelectionView = MatrixSelectionView;
exports.MatrixSubView = MatrixSubView;
exports.MatrixTransposeView = MatrixTransposeView;
exports.NIPALS = nipals;
exports.Nipals = nipals;
exports.QR = QrDecomposition;
exports.QrDecomposition = QrDecomposition;
exports.SVD = SingularValueDecomposition;
exports.SingularValueDecomposition = SingularValueDecomposition;
exports.WrapperMatrix1D = WrapperMatrix1D;
exports.WrapperMatrix2D = WrapperMatrix2D;
exports.correlation = correlation;
exports.covariance = covariance;
exports["default"] = Matrix;
exports.determinant = determinant;
exports.inverse = inverse;
exports.linearDependencies = linearDependencies;
exports.pseudoInverse = pseudoInverse;
exports.solve = solve;
exports.wrap = wrap;

},{"is-any-array":13,"ml-array-rescale":153}],187:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./shapes/1d/gaussian/Gaussian"), exports);
__exportStar(require("./shapes/1d/lorentzian/Lorentzian"), exports);
__exportStar(require("./shapes/1d/pseudoVoigt/PseudoVoigt"), exports);
__exportStar(require("./shapes/2d/gaussian2D/Gaussian2D"), exports);
__exportStar(require("./shapes/1d/getShape1D"), exports);
__exportStar(require("./shapes/2d/getShape2D"), exports);

},{"./shapes/1d/gaussian/Gaussian":188,"./shapes/1d/getShape1D":189,"./shapes/1d/lorentzian/Lorentzian":190,"./shapes/1d/pseudoVoigt/PseudoVoigt":191,"./shapes/2d/gaussian2D/Gaussian2D":192,"./shapes/2d/getShape2D":193}],188:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGaussianData = exports.getGaussianFactor = exports.getGaussianArea = exports.gaussianFwhmToWidth = exports.gaussianWidthToFWHM = exports.gaussianFct = exports.calculateGaussianHeight = exports.Gaussian = void 0;
const constants_1 = require("../../../util/constants");
const erfinv_1 = __importDefault(require("../../../util/erfinv"));
class Gaussian {
    constructor(options = {}) {
        const { fwhm = 500, sd } = options;
        this.fwhm = sd ? gaussianWidthToFWHM(2 * sd) : fwhm;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return gaussianFwhmToWidth(fwhm);
    }
    widthToFWHM(width) {
        return gaussianWidthToFWHM(width);
    }
    fct(x) {
        return gaussianFct(x, this.fwhm);
    }
    getArea(height = calculateGaussianHeight({ fwhm: this.fwhm })) {
        return getGaussianArea({ fwhm: this.fwhm, height });
    }
    getFactor(area) {
        return getGaussianFactor(area);
    }
    getData(options = {}) {
        return getGaussianData(this, options);
    }
    calculateHeight(area = 1) {
        return calculateGaussianHeight({ fwhm: this.fwhm, area });
    }
    getParameters() {
        return ['fwhm'];
    }
}
exports.Gaussian = Gaussian;
function calculateGaussianHeight(options) {
    let { fwhm = 500, area = 1, sd } = options;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    return (2 * area) / constants_1.ROOT_PI_OVER_LN2 / fwhm;
}
exports.calculateGaussianHeight = calculateGaussianHeight;
/**
 * Calculate the height of the gaussian function of a specific width (fwhm) at a speicifc
 * x position (the gaussian is centered on x=0)
 * @param x
 * @param fwhm
 * @returns y
 */
function gaussianFct(x, fwhm) {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * Math.pow(x / fwhm, 2));
}
exports.gaussianFct = gaussianFct;
function gaussianWidthToFWHM(width) {
    return width * constants_1.ROOT_2LN2;
}
exports.gaussianWidthToFWHM = gaussianWidthToFWHM;
function gaussianFwhmToWidth(fwhm) {
    return fwhm / constants_1.ROOT_2LN2;
}
exports.gaussianFwhmToWidth = gaussianFwhmToWidth;
function getGaussianArea(options) {
    let { fwhm = 500, sd, height = 1 } = options;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    return (height * constants_1.ROOT_PI_OVER_LN2 * fwhm) / 2;
}
exports.getGaussianArea = getGaussianArea;
function getGaussianFactor(area = 0.9999) {
    return Math.sqrt(2) * (0, erfinv_1.default)(area);
}
exports.getGaussianFactor = getGaussianFactor;
function getGaussianData(shape = {}, options = {}) {
    let { fwhm = 500, sd } = shape;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    let { length, factor = getGaussianFactor(), height = calculateGaussianHeight({ fwhm }), } = options;
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = gaussianFct(i - center, fwhm) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
}
exports.getGaussianData = getGaussianData;

},{"../../../util/constants":194,"../../../util/erfinv":195}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShape1D = void 0;
const Gaussian_1 = require("./gaussian/Gaussian");
const Lorentzian_1 = require("./lorentzian/Lorentzian");
const PseudoVoigt_1 = require("./pseudoVoigt/PseudoVoigt");
/**
 * Generate a instance of a specific kind of shape.
 */
function getShape1D(shape) {
    const { kind } = shape;
    switch (kind) {
        case 'gaussian':
            return new Gaussian_1.Gaussian(shape);
        case 'lorentzian':
            return new Lorentzian_1.Lorentzian(shape);
        case 'pseudoVoigt':
            return new PseudoVoigt_1.PseudoVoigt(shape);
        default: {
            throw Error(`Unknown distribution ${kind}`);
        }
    }
}
exports.getShape1D = getShape1D;

},{"./gaussian/Gaussian":188,"./lorentzian/Lorentzian":190,"./pseudoVoigt/PseudoVoigt":191}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLorentzianData = exports.getLorentzianFactor = exports.lorentzianFwhmToWidth = exports.lorentzianWidthToFWHM = exports.lorentzianFct = exports.getLorentzianArea = exports.calculateLorentzianHeight = exports.Lorentzian = void 0;
const constants_1 = require("../../../util/constants");
class Lorentzian {
    constructor(options = {}) {
        const { fwhm = 500 } = options;
        this.fwhm = fwhm;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return (0, exports.lorentzianFwhmToWidth)(fwhm);
    }
    widthToFWHM(width) {
        return (0, exports.lorentzianWidthToFWHM)(width);
    }
    fct(x) {
        return (0, exports.lorentzianFct)(x, this.fwhm);
    }
    getArea(height = 1) {
        return (0, exports.getLorentzianArea)({ fwhm: this.fwhm, height });
    }
    getFactor(area) {
        return (0, exports.getLorentzianFactor)(area);
    }
    getData(options = {}) {
        return (0, exports.getLorentzianData)(this, options);
    }
    calculateHeight(area = 1) {
        return (0, exports.calculateLorentzianHeight)({ fwhm: this.fwhm, area });
    }
    getParameters() {
        return ['fwhm'];
    }
}
exports.Lorentzian = Lorentzian;
const calculateLorentzianHeight = ({ fwhm = 1, area = 1 }) => {
    return (2 * area) / Math.PI / fwhm;
};
exports.calculateLorentzianHeight = calculateLorentzianHeight;
const getLorentzianArea = (options) => {
    const { fwhm = 500, height = 1 } = options;
    return (height * Math.PI * fwhm) / 2;
};
exports.getLorentzianArea = getLorentzianArea;
const lorentzianFct = (x, fwhm) => {
    return fwhm ** 2 / (4 * x ** 2 + fwhm ** 2);
};
exports.lorentzianFct = lorentzianFct;
const lorentzianWidthToFWHM = (width) => {
    return width * constants_1.ROOT_THREE;
};
exports.lorentzianWidthToFWHM = lorentzianWidthToFWHM;
const lorentzianFwhmToWidth = (fwhm) => {
    return fwhm / constants_1.ROOT_THREE;
};
exports.lorentzianFwhmToWidth = lorentzianFwhmToWidth;
const getLorentzianFactor = (area = 0.9999) => {
    if (area >= 1) {
        throw new Error('area should be (0 - 1)');
    }
    const halfResidual = (1 - area) * 0.5;
    const quantileFunction = (p) => Math.tan(Math.PI * (p - 0.5));
    return ((quantileFunction(1 - halfResidual) - quantileFunction(halfResidual)) / 2);
};
exports.getLorentzianFactor = getLorentzianFactor;
const getLorentzianData = (shape = {}, options = {}) => {
    let { fwhm = 500 } = shape;
    let { length, factor = (0, exports.getLorentzianFactor)(), height = (0, exports.calculateLorentzianHeight)({ fwhm, area: 1 }), } = options;
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = (0, exports.lorentzianFct)(i - center, fwhm) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
};
exports.getLorentzianData = getLorentzianData;

},{"../../../util/constants":194}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPseudoVoigtData = exports.getPseudoVoigtFactor = exports.getPseudoVoigtArea = exports.pseudoVoigtFwhmToWidth = exports.pseudoVoigtWidthToFWHM = exports.pseudoVoigtFct = exports.calculatePseudoVoigtHeight = exports.PseudoVoigt = void 0;
const constants_1 = require("../../../util/constants");
const Gaussian_1 = require("../gaussian/Gaussian");
const Lorentzian_1 = require("../lorentzian/Lorentzian");
class PseudoVoigt {
    constructor(options = {}) {
        const { fwhm = 500, mu = 0.5 } = options;
        this.mu = mu;
        this.fwhm = fwhm;
    }
    fwhmToWidth(fwhm = this.fwhm, mu = this.mu) {
        return (0, exports.pseudoVoigtFwhmToWidth)(fwhm, mu);
    }
    widthToFWHM(width, mu = this.mu) {
        return (0, exports.pseudoVoigtWidthToFWHM)(width, mu);
    }
    fct(x) {
        return (0, exports.pseudoVoigtFct)(x, this.fwhm, this.mu);
    }
    getArea(height = 1) {
        return (0, exports.getPseudoVoigtArea)({ fwhm: this.fwhm, height, mu: this.mu });
    }
    getFactor(area) {
        return (0, exports.getPseudoVoigtFactor)(area);
    }
    getData(options = {}) {
        const { length, factor, height = (0, exports.calculatePseudoVoigtHeight)({
            fwhm: this.fwhm,
            mu: this.mu,
            area: 1,
        }), } = options;
        return (0, exports.getPseudoVoigtData)(this, { factor, length, height });
    }
    calculateHeight(area = 1) {
        return (0, exports.calculatePseudoVoigtHeight)({ fwhm: this.fwhm, mu: this.mu, area });
    }
    getParameters() {
        return ['fwhm', 'mu'];
    }
}
exports.PseudoVoigt = PseudoVoigt;
const calculatePseudoVoigtHeight = (options = {}) => {
    let { fwhm = 1, mu = 0.5, area = 1 } = options;
    return (2 * area) / (fwhm * (mu * constants_1.ROOT_PI_OVER_LN2 + (1 - mu) * Math.PI));
};
exports.calculatePseudoVoigtHeight = calculatePseudoVoigtHeight;
const pseudoVoigtFct = (x, fwhm, mu) => {
    return (1 - mu) * (0, Lorentzian_1.lorentzianFct)(x, fwhm) + mu * (0, Gaussian_1.gaussianFct)(x, fwhm);
};
exports.pseudoVoigtFct = pseudoVoigtFct;
const pseudoVoigtWidthToFWHM = (width, mu = 0.5) => {
    return width * (mu * constants_1.ROOT_2LN2_MINUS_ONE + 1);
};
exports.pseudoVoigtWidthToFWHM = pseudoVoigtWidthToFWHM;
const pseudoVoigtFwhmToWidth = (fwhm, mu = 0.5) => {
    return fwhm / (mu * constants_1.ROOT_2LN2_MINUS_ONE + 1);
};
exports.pseudoVoigtFwhmToWidth = pseudoVoigtFwhmToWidth;
const getPseudoVoigtArea = (options) => {
    const { fwhm = 500, height = 1, mu = 0.5 } = options;
    return (fwhm * height * (mu * constants_1.ROOT_PI_OVER_LN2 + (1 - mu) * Math.PI)) / 2;
};
exports.getPseudoVoigtArea = getPseudoVoigtArea;
const getPseudoVoigtFactor = (area = 0.9999, mu = 0.5) => {
    return mu < 1 ? (0, Lorentzian_1.getLorentzianFactor)(area) : (0, Gaussian_1.getGaussianFactor)(area);
};
exports.getPseudoVoigtFactor = getPseudoVoigtFactor;
const getPseudoVoigtData = (shape = {}, options = {}) => {
    let { fwhm = 500, mu = 0.5 } = shape;
    let { length, factor = (0, exports.getPseudoVoigtFactor)(0.999, mu), height = (0, exports.calculatePseudoVoigtHeight)({ fwhm, mu, area: 1 }), } = options;
    if (!height) {
        height =
            1 /
                ((mu / Math.sqrt(-constants_1.GAUSSIAN_EXP_FACTOR / Math.PI)) * fwhm +
                    ((1 - mu) * fwhm * Math.PI) / 2);
    }
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = (0, exports.pseudoVoigtFct)(i - center, fwhm, mu) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
};
exports.getPseudoVoigtData = getPseudoVoigtData;

},{"../../../util/constants":194,"../gaussian/Gaussian":188,"../lorentzian/Lorentzian":190}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGaussian2DVolume = exports.calculateGaussian2DHeight = exports.getGaussian2DData = exports.gaussian2DFct = exports.Gaussian2D = void 0;
const constants_1 = require("../../../util/constants");
const Gaussian_1 = require("../../1d/gaussian/Gaussian");
class Gaussian2D {
    constructor(options = {}) {
        let { fwhm = 20, sd } = options;
        fwhm = ensureFWHM2D(fwhm, sd);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
    fct(x, y) {
        return (0, exports.gaussian2DFct)(x, y, this.fwhmX, this.fwhmY);
    }
    getData(options = {}) {
        return (0, exports.getGaussian2DData)({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        }, options);
    }
    getFactor(volume = 1) {
        return (0, Gaussian_1.getGaussianFactor)(volume);
    }
    getVolume(height = (0, exports.calculateGaussian2DHeight)({
        fwhm: { x: this.fwhmX, y: this.fwhmY },
        volume: 1,
    })) {
        return (0, exports.getGaussian2DVolume)({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
            height,
        });
    }
    widthToFWHM(width) {
        return (0, Gaussian_1.gaussianWidthToFWHM)(width);
    }
    fwhmToWidth(fwhm) {
        return (0, Gaussian_1.gaussianFwhmToWidth)(fwhm);
    }
    calculateHeight(volume = 1) {
        return (0, exports.calculateGaussian2DHeight)({
            volume,
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        });
    }
    set fwhm(fwhm) {
        fwhm = ensureXYNumber(fwhm);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
}
exports.Gaussian2D = Gaussian2D;
const gaussian2DFct = (x, y, xFWHM, yFWHM) => {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * (Math.pow(x / xFWHM, 2) + Math.pow(y / yFWHM, 2)));
};
exports.gaussian2DFct = gaussian2DFct;
const getGaussian2DData = (shape, options = {}) => {
    let { fwhm = 50, sd } = shape;
    fwhm = ensureFWHM2D(fwhm, sd);
    let { factor = (0, Gaussian_1.getGaussianFactor)(), length = { x: 0, y: 0 }, height = (0, exports.calculateGaussian2DHeight)({ fwhm, volume: 1 }), } = options;
    factor = ensureXYNumber(factor);
    length = ensureXYNumber(length);
    for (const axis of ['x', 'y']) {
        if (!length[axis]) {
            length[axis] = Math.min(Math.ceil(fwhm[axis] * factor[axis]), Math.pow(2, 25) - 1);
            if (length[axis] % 2 === 0)
                length[axis]++;
        }
    }
    const xCenter = (length.x - 1) / 2;
    const yCenter = (length.y - 1) / 2;
    const data = new Array(length.x);
    for (let i = 0; i < length.x; i++) {
        data[i] = new Float64Array(length.y);
    }
    for (let i = 0; i < length.x; i++) {
        for (let j = 0; j < length.y; j++) {
            data[i][j] =
                (0, exports.gaussian2DFct)(i - xCenter, j - yCenter, fwhm.x, fwhm.y) * height;
        }
    }
    return data;
};
exports.getGaussian2DData = getGaussian2DData;
const calculateGaussian2DHeight = (options = {}) => {
    let { volume = 1, fwhm = 50, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (volume * Math.LN2 * 4) / (Math.PI * fwhm.y * fwhm.x);
};
exports.calculateGaussian2DHeight = calculateGaussian2DHeight;
const getGaussian2DVolume = (options = {}) => {
    let { fwhm = 50, height = 1, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (height * Math.PI * fwhm.y * fwhm.x) / Math.LN2 / 4;
};
exports.getGaussian2DVolume = getGaussian2DVolume;
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function ensureFWHM2D(fwhm, sd) {
    if (sd !== undefined) {
        let sdObject = ensureXYNumber(sd);
        return {
            x: (0, Gaussian_1.gaussianWidthToFWHM)(2 * sdObject.x),
            y: (0, Gaussian_1.gaussianWidthToFWHM)(2 * sdObject.y),
        };
    }
    else if (fwhm !== undefined) {
        return ensureXYNumber(fwhm);
    }
    else {
        throw new Error('ensureFWHM2D must have either fwhm or sd defined');
    }
}

},{"../../../util/constants":194,"../../1d/gaussian/Gaussian":188}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShape2D = void 0;
const Gaussian2D_1 = require("./gaussian2D/Gaussian2D");
/**
 * Generate a instance of a specific kind of shape.
 */
function getShape2D(shape) {
    const { kind } = shape;
    switch (kind) {
        case 'gaussian':
            return new Gaussian2D_1.Gaussian2D(shape);
        default: {
            const unHandled = kind;
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw Error(`Unknown distribution ${unHandled}`);
        }
    }
}
exports.getShape2D = getShape2D;

},{"./gaussian2D/Gaussian2D":192}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ROOT_2LN2_MINUS_ONE = exports.ROOT_2LN2 = exports.ROOT_THREE = exports.ROOT_PI_OVER_LN2 = exports.GAUSSIAN_EXP_FACTOR = void 0;
exports.GAUSSIAN_EXP_FACTOR = -4 * Math.LN2;
exports.ROOT_PI_OVER_LN2 = Math.sqrt(Math.PI / Math.LN2);
exports.ROOT_THREE = Math.sqrt(3);
exports.ROOT_2LN2 = Math.sqrt(2 * Math.LN2);
exports.ROOT_2LN2_MINUS_ONE = Math.sqrt(2 * Math.LN2) - 1;

},{}],195:[function(require,module,exports){
"use strict";
// https://en.wikipedia.org/wiki/Error_function#Inverse_functions
// This code yields to a good approximation
Object.defineProperty(exports, "__esModule", { value: true });
// If needed a better implementation using polynomial can be found on https://en.wikipedia.org/wiki/Error_function#Inverse_functions
function erfinv(x) {
    let a = 0.147;
    if (x === 0)
        return 0;
    let ln1MinusXSqrd = Math.log(1 - x * x);
    let lnEtcBy2Plus2 = ln1MinusXSqrd / 2 + 2 / (Math.PI * a);
    let firstSqrt = Math.sqrt(lnEtcBy2Plus2 ** 2 - ln1MinusXSqrd / a);
    let secondSqrt = Math.sqrt(firstSqrt - lnEtcBy2Plus2);
    return secondSqrt * (x > 0 ? 1 : -1);
}
exports.default = erfinv;

},{}],196:[function(require,module,exports){
"use strict";
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
exports.referenceDeconvolution = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
const spectrum_generator_1 = require("spectrum-generator");
const getSignalReference_1 = require("./utilities/getSignalReference");
/**
 * My module
 * @returns A very important number
 */
function referenceDeconvolution(data, options = {}) {
    const { referenceRange = { from: 0, to: 0.5 }, fwhm = options.fwhm || (referenceRange.to - referenceRange.from) * 0.02, height = 1, } = options;
    const { x, y } = data;
    const reExperimentalSpectrum = JSON.parse(JSON.stringify(y)); //structuredClone(y);
    const reReferenceSpectrumPeak = (0, getSignalReference_1.getSignalReference)(referenceRange, x, y);
    const idealSpectrumPeak = (0, spectrum_generator_1.generateSpectrum)([
        {
            x: x[(0, ml_spectra_processing_1.xMaxIndex)(reReferenceSpectrumPeak)],
            y: (0, ml_spectra_processing_1.xMaxValue)(reExperimentalSpectrum) * height,
        },
    ], {
        generator: {
            from: x[0],
            to: x[x.length - 1],
            nbPoints: x.length,
            shape: {
                kind: 'gaussian',
                fwhm,
            },
        },
    });
    const reIdealSpectrumPeak = Array.from(idealSpectrumPeak.y);
    const imExperimentalSpectrum = (0, ml_spectra_processing_1.xHilbertTransform)(reExperimentalSpectrum, {
        inClockwise: false,
    });
    const imIdealSpectrumPeak = (0, ml_spectra_processing_1.xHilbertTransform)(reIdealSpectrumPeak, {
        inClockwise: false,
    });
    const imReferenceSpectrumPeak = (0, ml_spectra_processing_1.xHilbertTransform)(reReferenceSpectrumPeak, {
        inClockwise: false,
    });
    const { re: reExperimentalFid, im: imExperimentalFid } = (0, ml_spectra_processing_1.reimFFT)({ re: reExperimentalSpectrum, im: imExperimentalSpectrum }, { inverse: true });
    const { re: reIdealPeakFid, im: imIdealPeakFid } = (0, ml_spectra_processing_1.reimFFT)({ re: reIdealSpectrumPeak, im: imIdealSpectrumPeak }, { inverse: true });
    const { re: reReferencePeakFid, im: imReferencePeakFid } = (0, ml_spectra_processing_1.reimFFT)({ re: reReferenceSpectrumPeak, im: imReferenceSpectrumPeak }, { inverse: true });
    const reCompensatedFid = [];
    const imCompensatedFid = [];
    for (let i = 0; i < reExperimentalSpectrum.length; i++) {
        const realQuotient = (reExperimentalFid[i] * reReferencePeakFid[i] +
            imExperimentalFid[i] * imReferencePeakFid[i]) /
            (reReferencePeakFid[i] ** 2 + imReferencePeakFid[i] ** 2);
        const imagQuotient = (imExperimentalFid[i] * reReferencePeakFid[i] -
            reExperimentalFid[i] * imReferencePeakFid[i]) /
            (reReferencePeakFid[i] ** 2 + imReferencePeakFid[i] ** 2);
        reCompensatedFid[i] =
            realQuotient * reIdealPeakFid[i] - imagQuotient * imIdealPeakFid[i];
        imCompensatedFid[i] =
            realQuotient * imIdealPeakFid[i] + imagQuotient * reIdealPeakFid[i];
    }
    let sComp = zeroZone(reCompensatedFid, x, 9, x[x.length - 1], {
        real: true,
    });
    let sCompIm = zeroZone(imCompensatedFid, x, 9, x[x.length - 1], {
        real: false,
    });
    let sComp2 = expApodization(sComp);
    let sCompIm2 = expApodization(sCompIm);
    let { re: reCompensatedSpectrum, im: imCompensatedSpectrum } = (0, ml_spectra_processing_1.reimFFT)({ re: sComp2, im: sCompIm2 }, { inverse: false });
    return {
        x,
        y: reCompensatedSpectrum,
        sComp2,
        sComp,
        reReferenceSpectrumPeak,
        idealSpectrumPeak,
        // re: reCompensatedSpectrum,
        // im: imCompensatedSpectrum,
    };
}
exports.referenceDeconvolution = referenceDeconvolution;
function expApodization(fid, options = {}) {
    const { w = 0.00008 } = options;
    let result = fid.slice();
    for (let i = 0; i < result.length; i++) {
        result[i] = result[i] * Math.exp(-Math.PI * w * i);
    }
    return result;
}
function zeroZone(spectra, x, from, to, options = {}) {
    const { real = true } = options;
    const result = spectra.slice();
    const fromIndex = (0, ml_spectra_processing_1.xFindClosestIndex)(x, from);
    const toIndex = (0, ml_spectra_processing_1.xFindClosestIndex)(x, to);
    const maxV = (0, ml_spectra_processing_1.xMaxValue)(result);
    result[0] = real ? maxV : 0;
    for (let i = fromIndex; i < toIndex + 1; i++) {
        result[i] = 0;
    }
    return result;
}

},{"./utilities/getSignalReference":197,"ml-spectra-processing":208,"spectrum-generator":530}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignalReference = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
function getSignalReference(range, x, y) {
    const init = (0, ml_spectra_processing_1.xFindClosestIndex)(x, range.from);
    const end = (0, ml_spectra_processing_1.xFindClosestIndex)(x, range.to);
    const result = new Array(x.length).fill(0);
    for (let i = init; i < end; i++) {
        result[i] = y[i];
    }
    return result;
}
exports.getSignalReference = getSignalReference;

},{"ml-spectra-processing":208}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sgg = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * Apply Savitzky Golay algorithm
 * @param [ys] Array of y values
 * @param [xs] Array of X or deltaX
 * @return  Array containing the new ys (same length)
 */
function sgg(ys, xs, options = {}) {
    let { windowSize = 9, derivative = 0, polynomial = 3 } = options;
    if (windowSize % 2 === 0 || windowSize < 5 || !Number.isInteger(windowSize)) {
        throw new RangeError('Invalid window size (should be odd and at least 5 integer number)');
    }
    if (!(0, is_any_array_1.isAnyArray)(ys)) {
        throw new TypeError('Y values must be an array');
    }
    if (typeof xs === 'undefined') {
        throw new TypeError('X must be defined');
    }
    if (windowSize > ys.length) {
        throw new RangeError(`Window size is higher than the data length ${windowSize}>${ys.length}`);
    }
    if (derivative < 0 || !Number.isInteger(derivative)) {
        throw new RangeError('Derivative should be a positive integer');
    }
    if (polynomial < 1 || !Number.isInteger(polynomial)) {
        throw new RangeError('Polynomial should be a positive integer');
    }
    if (polynomial >= 6) {
        // eslint-disable-next-line no-console
        console.warn('You should not use polynomial grade higher than 5 if you are' +
            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');
    }
    let half = Math.floor(windowSize / 2);
    let np = ys.length;
    let ans = new Float64Array(np);
    let weights = fullWeights(windowSize, polynomial, derivative);
    let hs = 0;
    let constantH = true;
    if ((0, is_any_array_1.isAnyArray)(xs)) {
        constantH = false;
    }
    else {
        hs = Math.pow(xs, derivative);
    }
    //For the borders
    for (let i = 0; i < half; i++) {
        let wg1 = weights[half - i - 1];
        let wg2 = weights[half + i + 1];
        let d1 = 0;
        let d2 = 0;
        for (let l = 0; l < windowSize; l++) {
            d1 += wg1[l] * ys[l];
            d2 += wg2[l] * ys[np - windowSize + l];
        }
        if (constantH) {
            ans[half - i - 1] = d1 / hs;
            ans[np - half + i] = d2 / hs;
        }
        else {
            hs = getHs(xs, half - i - 1, half, derivative);
            ans[half - i - 1] = d1 / hs;
            hs = getHs(xs, np - half + i, half, derivative);
            ans[np - half + i] = d2 / hs;
        }
    }
    //For the internal points
    let wg = weights[half];
    for (let i = windowSize; i <= np; i++) {
        let d = 0;
        for (let l = 0; l < windowSize; l++)
            d += wg[l] * ys[l + i - windowSize];
        if (!constantH) {
            hs = getHs(xs, i - half - 1, half, derivative);
        }
        ans[i - half - 1] = d / hs;
    }
    return ans;
}
exports.sgg = sgg;
function getHs(h, center, half, derivative) {
    let hs = 0;
    let count = 0;
    for (let i = center - half; i < center + half; i++) {
        if (i >= 0 && i < h.length - 1) {
            hs += h[i + 1] - h[i];
            count++;
        }
    }
    return Math.pow(hs / count, derivative);
}
function gramPoly(i, m, k, s) {
    let Grampoly = 0;
    if (k > 0) {
        Grampoly =
            ((4 * k - 2) / (k * (2 * m - k + 1))) *
                (i * gramPoly(i, m, k - 1, s) + s * gramPoly(i, m, k - 1, s - 1)) -
                (((k - 1) * (2 * m + k)) / (k * (2 * m - k + 1))) *
                    gramPoly(i, m, k - 2, s);
    }
    else {
        if (k === 0 && s === 0) {
            Grampoly = 1;
        }
        else {
            Grampoly = 0;
        }
    }
    return Grampoly;
}
function genFact(a, b) {
    let gf = 1;
    if (a >= b) {
        for (let j = a - b + 1; j <= a; j++) {
            gf *= j;
        }
    }
    return gf;
}
function weight(i, t, m, n, s) {
    let sum = 0;
    for (let k = 0; k <= n; k++) {
        sum +=
            (2 * k + 1) *
                (genFact(2 * m, k) / genFact(2 * m + k + 1, k + 1)) *
                gramPoly(i, m, k, 0) *
                gramPoly(t, m, k, s);
    }
    return sum;
}
/**
 * @private
 * @param m  Number of points
 * @param n  Polynomial grade
 * @param s  Derivative
 */
function fullWeights(m, n, s) {
    let weights = new Array(m);
    let np = Math.floor(m / 2);
    for (let t = -np; t <= np; t++) {
        weights[t + np] = new Float64Array(m);
        for (let j = -np; j <= np; j++) {
            weights[t + np][j + np] = weight(j, t, np, n, s);
        }
    }
    return weights;
}

},{"is-any-array":13}],199:[function(require,module,exports){
/**
 * Created by acastillo on 8/8/16.
 */
'use strict';

const defOptions = {
    threshold:0,
    out:"assignment"
};
//TODO Consider a matrix of distances too
module.exports = function fullClusterGenerator(conMat, opt) {
    const options = Object.assign({}, defOptions, opt);
    var clList, i, j, k;
    if(typeof conMat[0] === "number"){
        clList = fullClusterGeneratorVector(conMat);
    }
    else{
        if(typeof conMat[0] === "object"){
            var nRows = conMat.length;
            var conn = new Array(nRows*(nRows+1)/2);
            var index = 0;
            for(var i=0;i<nRows;i++){
                for(var j=i;j<nRows;j++){
                    if(conMat[i][j]>options.threshold)
                        conn[index++]= 1;
                    else
                        conn[index++]= 0;
                }
            }
            clList = fullClusterGeneratorVector(conn);
        }
    }
    if (options.out === "indexes" || options.out === "values") {
        var result = new Array(clList.length);
        for(i=0;i<clList.length;i++){
            result[i] = [];
            for(j=0;j<clList[i].length;j++){
                if(clList[i][j] != 0){
                    result[i].push(j);
                }
            }
        }
        if (options.out === "values") {
            var resultAsMatrix = new Array(result.length);
            for (i = 0; i<result.length;i++){
                resultAsMatrix[i]=new Array(result[i].length);
                for(j = 0; j < result[i].length; j++){
                    resultAsMatrix[i][j]=new Array(result[i].length);
                    for(k = 0; k < result[i].length; k++){
                        resultAsMatrix[i][j][k]=conMat[result[i][j]][result[i][k]];
                    }
                }
            }
            return resultAsMatrix;
        }
        else{
            return result;
        }
    }

    return clList;

}

function fullClusterGeneratorVector(conn){
    var nRows = Math.sqrt(conn.length*2+0.25)-0.5;
    var clusterList = [];
    var available = new Array(nRows);
    var remaining = nRows, i=0;
    var cluster = [];
    //Mark all the elements as available
    for(i=nRows-1;i>=0;i--){
        available[i]=1;
    }
    var nextAv=-1;
    var toInclude = [];
    while(remaining>0){
        if(toInclude.length===0){
            //If there is no more elements to include. Start a new cluster
            cluster = new Array(nRows);
            for(i = 0;i < nRows ;i++)
                cluster[i]=0;
            clusterList.push(cluster);
            for(nextAv = 0;available[nextAv]==0;nextAv++){};
        }
        else{
            nextAv=toInclude.splice(0,1);
        }
        cluster[nextAv]=1;
        available[nextAv]=0;
        remaining--;
        //Copy the next available row
        var row = new Array(nRows);
        for( i = 0;i < nRows;i++){
            var c=Math.max(nextAv,i);
            var r=Math.min(nextAv,i);
            //The element in the conn matrix
            //console.log("index: "+r*(2*nRows-r-1)/2+c)
            row[i]=conn[r*(2*nRows-r-1)/2+c];
            //There is new elements to include in this row?
            //Then, include it to the current cluster
            if(row[i]==1&&available[i]==1&&cluster[i]==0){
                toInclude.push(i);
                cluster[i]=1;
            }
        }
    }
    return clusterList;
}
},{}],200:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var HashTable = require('ml-hash-table');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var HashTable__default = /*#__PURE__*/_interopDefaultLegacy(HashTable);

/* eslint-disable no-eval */

class SparseMatrix {
  constructor(rows, columns, options = {}) {
    if (rows instanceof SparseMatrix) {
      // clone
      const other = rows;
      this._init(
        other.rows,
        other.columns,
        other.elements.clone(),
        other.threshold,
      );
      return;
    }

    if (Array.isArray(rows)) {
      const matrix = rows;
      rows = matrix.length;
      options = columns || {};
      columns = matrix[0].length;
      this._init(rows, columns, new HashTable__default['default'](options), options.threshold);
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < columns; j++) {
          let value = matrix[i][j];
          if (this.threshold && Math.abs(value) < this.threshold) value = 0;
          if (value !== 0) {
            this.elements.set(i * columns + j, matrix[i][j]);
          }
        }
      }
    } else {
      this._init(rows, columns, new HashTable__default['default'](options), options.threshold);
    }
  }

  _init(rows, columns, elements, threshold) {
    this.rows = rows;
    this.columns = columns;
    this.elements = elements;
    this.threshold = threshold || 0;
  }

  static eye(rows = 1, columns = rows) {
    const min = Math.min(rows, columns);
    const matrix = new SparseMatrix(rows, columns, { initialCapacity: min });
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, 1);
    }
    return matrix;
  }

  clone() {
    return new SparseMatrix(this);
  }

  to2DArray() {
    const copy = new Array(this.rows);
    for (let i = 0; i < this.rows; i++) {
      copy[i] = new Array(this.columns);
      for (let j = 0; j < this.columns; j++) {
        copy[i][j] = this.get(i, j);
      }
    }
    return copy;
  }

  isSquare() {
    return this.rows === this.columns;
  }

  isSymmetric() {
    if (!this.isSquare()) return false;

    let symmetric = true;
    this.forEachNonZero((i, j, v) => {
      if (this.get(j, i) !== v) {
        symmetric = false;
        return false;
      }
      return v;
    });
    return symmetric;
  }

  /**
   * Search for the wither band in the main diagonals
   * @return {number}
   */
  bandWidth() {
    let min = this.columns;
    let max = -1;
    this.forEachNonZero((i, j, v) => {
      let diff = i - j;
      min = Math.min(min, diff);
      max = Math.max(max, diff);
      return v;
    });
    return max - min;
  }

  /**
   * Test if a matrix is consider banded using a threshold
   * @param {number} width
   * @return {boolean}
   */
  isBanded(width) {
    let bandWidth = this.bandWidth();
    return bandWidth <= width;
  }

  get cardinality() {
    return this.elements.size;
  }

  get size() {
    return this.rows * this.columns;
  }

  get(row, column) {
    return this.elements.get(row * this.columns + column);
  }

  set(row, column, value) {
    if (this.threshold && Math.abs(value) < this.threshold) value = 0;
    if (value === 0) {
      this.elements.remove(row * this.columns + column);
    } else {
      this.elements.set(row * this.columns + column, value);
    }
    return this;
  }

  mmul(other) {
    if (this.columns !== other.rows) {
      // eslint-disable-next-line no-console
      console.warn(
        'Number of columns of left matrix are not equal to number of rows of right matrix.',
      );
    }

    const m = this.rows;
    const p = other.columns;

    const result = new SparseMatrix(m, p);
    this.forEachNonZero((i, j, v1) => {
      other.forEachNonZero((k, l, v2) => {
        if (j === k) {
          result.set(i, l, result.get(i, l) + v1 * v2);
        }
        return v2;
      });
      return v1;
    });
    return result;
  }

  kroneckerProduct(other) {
    const m = this.rows;
    const n = this.columns;
    const p = other.rows;
    const q = other.columns;

    const result = new SparseMatrix(m * p, n * q, {
      initialCapacity: this.cardinality * other.cardinality,
    });
    this.forEachNonZero((i, j, v1) => {
      other.forEachNonZero((k, l, v2) => {
        result.set(p * i + k, q * j + l, v1 * v2);
        return v2;
      });
      return v1;
    });
    return result;
  }

  forEachNonZero(callback) {
    this.elements.forEachPair((key, value) => {
      const i = (key / this.columns) | 0;
      const j = key % this.columns;
      let r = callback(i, j, value);
      if (r === false) return false; // stop iteration
      if (this.threshold && Math.abs(r) < this.threshold) r = 0;
      if (r !== value) {
        if (r === 0) {
          this.elements.remove(key, true);
        } else {
          this.elements.set(key, r);
        }
      }
      return true;
    });
    this.elements.maybeShrinkCapacity();
    return this;
  }

  getNonZeros() {
    const cardinality = this.cardinality;
    const rows = new Array(cardinality);
    const columns = new Array(cardinality);
    const values = new Array(cardinality);
    let idx = 0;
    this.forEachNonZero((i, j, value) => {
      rows[idx] = i;
      columns[idx] = j;
      values[idx] = value;
      idx++;
      return value;
    });
    return { rows, columns, values };
  }

  setThreshold(newThreshold) {
    if (newThreshold !== 0 && newThreshold !== this.threshold) {
      this.threshold = newThreshold;
      this.forEachNonZero((i, j, v) => v);
    }
    return this;
  }

  /**
   * @return {SparseMatrix} - New transposed sparse matrix
   */
  transpose() {
    let trans = new SparseMatrix(this.columns, this.rows, {
      initialCapacity: this.cardinality,
    });
    this.forEachNonZero((i, j, value) => {
      trans.set(j, i, value);
      return value;
    });
    return trans;
  }

  isEmpty() {
    return this.rows === 0 || this.columns === 0;
  }
}

SparseMatrix.prototype.klass = 'Matrix';

SparseMatrix.identity = SparseMatrix.eye;
SparseMatrix.prototype.tensorProduct = SparseMatrix.prototype.kroneckerProduct;

/*
 Add dynamically instance and static methods for mathematical operations
 */

let inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

let inplaceOperatorScalar = `
(function %name%S(value) {
    this.forEachNonZero((i, j, v) => v %op% value);
    return this;
})
`;

let inplaceOperatorMatrix = `
(function %name%M(matrix) {
    matrix.forEachNonZero((i, j, v) => {
        this.set(i, j, this.get(i, j) %op% v);
        return v;
    });
    return this;
})
`;

let staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.%name%(value);
})
`;

let inplaceMethod = `
(function %name%() {
    this.forEachNonZero((i, j, v) => %method%(v));
    return this;
})
`;

let staticMethod = `
(function %name%(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.%name%();
})
`;

const operators = [
  // Arithmetic operators
  ['+', 'add'],
  ['-', 'sub', 'subtract'],
  ['*', 'mul', 'multiply'],
  ['/', 'div', 'divide'],
  ['%', 'mod', 'modulus'],
  // Bitwise operators
  ['&', 'and'],
  ['|', 'or'],
  ['^', 'xor'],
  ['<<', 'leftShift'],
  ['>>', 'signPropagatingRightShift'],
  ['>>>', 'rightShift', 'zeroFillRightShift'],
];

for (const operator of operators) {
  for (let i = 1; i < operator.length; i++) {
    SparseMatrix.prototype[operator[i]] = eval(
      fillTemplateFunction(inplaceOperator, {
        name: operator[i],
        op: operator[0],
      }),
    );
    SparseMatrix.prototype[`${operator[i]}S`] = eval(
      fillTemplateFunction(inplaceOperatorScalar, {
        name: `${operator[i]}S`,
        op: operator[0],
      }),
    );
    SparseMatrix.prototype[`${operator[i]}M`] = eval(
      fillTemplateFunction(inplaceOperatorMatrix, {
        name: `${operator[i]}M`,
        op: operator[0],
      }),
    );

    SparseMatrix[operator[i]] = eval(
      fillTemplateFunction(staticOperator, { name: operator[i] }),
    );
  }
}

let methods = [['~', 'not']];

[
  'abs',
  'acos',
  'acosh',
  'asin',
  'asinh',
  'atan',
  'atanh',
  'cbrt',
  'ceil',
  'clz32',
  'cos',
  'cosh',
  'exp',
  'expm1',
  'floor',
  'fround',
  'log',
  'log1p',
  'log10',
  'log2',
  'round',
  'sign',
  'sin',
  'sinh',
  'sqrt',
  'tan',
  'tanh',
  'trunc',
].forEach(function (mathMethod) {
  methods.push([`Math.${mathMethod}`, mathMethod]);
});

for (const method of methods) {
  for (let i = 1; i < method.length; i++) {
    SparseMatrix.prototype[method[i]] = eval(
      fillTemplateFunction(inplaceMethod, {
        name: method[i],
        method: method[0],
      }),
    );
    SparseMatrix[method[i]] = eval(
      fillTemplateFunction(staticMethod, { name: method[i] }),
    );
  }
}

function fillTemplateFunction(template, values) {
  for (const i in values) {
    template = template.replace(new RegExp(`%${i}%`, 'g'), values[i]);
  }
  return template;
}

exports.SparseMatrix = SparseMatrix;

},{"ml-hash-table":177}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimize = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
const getSumOfShapes_1 = require("./shapes/getSumOfShapes");
const getInternalPeaks_1 = require("./util/internalPeaks/getInternalPeaks");
const selectMethod_1 = require("./util/selectMethod");
/**
 * Fits a set of points to the sum of a set of bell functions.
 *
 * @param data - An object containing the x and y data to be fitted.
 * @param peaks - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 * @param options - Options for optimize
 * @returns - An object with fitting error and the list of optimized parameters { parameters: [ {x, y, width} ], error } if the kind of shape is pseudoVoigt mu parameter is optimized.
 */
function optimize(data, peaks, options = {}) {
    // rescale data
    let temp = (0, ml_spectra_processing_1.xMinMaxValues)(data.y);
    const minMaxY = { ...temp, range: temp.max - temp.min };
    const internalPeaks = (0, getInternalPeaks_1.getInternalPeaks)(peaks, minMaxY, options);
    // need to rescale what is related to Y
    const { baseline: shiftValue = minMaxY.min } = options;
    let normalizedY = new Float64Array(data.y.length);
    for (let i = 0; i < data.y.length; i++) {
        normalizedY[i] = (data.y[i] - shiftValue) / minMaxY.range;
    }
    const nbParams = internalPeaks[internalPeaks.length - 1].toIndex + 1;
    const minValues = new Float64Array(nbParams);
    const maxValues = new Float64Array(nbParams);
    const initialValues = new Float64Array(nbParams);
    const gradientDifferences = new Float64Array(nbParams);
    let index = 0;
    for (const peak of internalPeaks) {
        for (let i = 0; i < peak.parameters.length; i++) {
            minValues[index] = peak.propertiesValues.min[i];
            maxValues[index] = peak.propertiesValues.max[i];
            initialValues[index] = peak.propertiesValues.init[i];
            gradientDifferences[index] = peak.propertiesValues.gradientDifference[i];
            index++;
        }
    }
    let { algorithm, optimizationOptions } = (0, selectMethod_1.selectMethod)(options.optimization);
    let sumOfShapes = (0, getSumOfShapes_1.getSumOfShapes)(internalPeaks);
    let fitted = algorithm({ x: data.x, y: normalizedY }, sumOfShapes, {
        minValues,
        maxValues,
        initialValues,
        gradientDifference: gradientDifferences,
        ...optimizationOptions,
    });
    const fittedValues = fitted.parameterValues;
    let newPeaks = [];
    for (let peak of internalPeaks) {
        const { id, shape, parameters, fromIndex } = peak;
        let newPeak = { x: 0, y: 0, shape };
        if (id) {
            newPeak = { ...newPeak, id };
        }
        newPeak.x = fittedValues[fromIndex];
        newPeak.y = fittedValues[fromIndex + 1] * minMaxY.range + shiftValue;
        for (let i = 2; i < parameters.length; i++) {
            //@ts-expect-error should be fixed once
            newPeak.shape[parameters[i]] = fittedValues[fromIndex + i];
        }
        newPeaks.push(newPeak);
    }
    return {
        error: fitted.parameterError,
        iterations: fitted.iterations,
        peaks: newPeaks,
    };
}
exports.optimize = optimize;

},{"./shapes/getSumOfShapes":202,"./util/internalPeaks/getInternalPeaks":205,"./util/selectMethod":206,"ml-spectra-processing":208}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSumOfShapes = void 0;
/**
 * This function returns the sumOfShapes function
 * This function gives sumOfShapes access to the peak list and the associated data
 * @param parameters - parameters
 */
function getSumOfShapes(internalPeaks) {
    return function sumOfShapes(parameters) {
        return (x) => {
            let totalY = 0;
            for (const peak of internalPeaks) {
                const peakX = parameters[peak.fromIndex];
                const y = parameters[peak.fromIndex + 1];
                for (let i = 2; i < parameters.length; i++) {
                    //@ts-expect-error Not simply to solve the issue
                    peak.shapeFct[peak.parameters[i]] = parameters[peak.fromIndex + i];
                }
                totalY += y * peak.shapeFct.fct(x - peakX);
            }
            return totalY;
        };
    };
}
exports.getSumOfShapes = getSumOfShapes;

},{}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = void 0;
/**
 * Asserts that value is truthy.
 *
 * @param value - Value to check.
 * @param message - Optional error message to throw.
 */
function assert(value, message) {
    if (!value) {
        throw new Error(message ? message : 'unreachable');
    }
}
exports.assert = assert;

},{}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultParameters = void 0;
exports.DefaultParameters = {
    x: {
        init: (peak) => peak.x,
        min: (peak, peakShape) => peak.x - peakShape.fwhm * 2,
        max: (peak, peakShape) => peak.x + peakShape.fwhm * 2,
        gradientDifference: (peak, peakShape) => peakShape.fwhm * 2e-3,
    },
    y: {
        init: (peak) => peak.y,
        min: (peak) => (peak.y < 0 ? -1.1 : 0),
        max: (peak) => (peak.y < 0 ? 0 : 1.1),
        gradientDifference: () => 1e-3,
    },
    fwhm: {
        init: (peak, peakShape) => peakShape.fwhm,
        min: (peak, peakShape) => peakShape.fwhm * 0.25,
        max: (peak, peakShape) => peakShape.fwhm * 4,
        gradientDifference: (peak, peakShape) => peakShape.fwhm * 2e-3,
    },
    mu: {
        init: (peak, peakShape) => peakShape.mu,
        min: () => 0,
        max: () => 1,
        gradientDifference: () => 0.01,
    },
};

},{}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInternalPeaks = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const assert_1 = require("../assert");
const DefaultParameters_1 = require("./DefaultParameters");
const properties = ['init', 'min', 'max', 'gradientDifference'];
/**
 * Return an array of internalPeaks that contains the exact init, min, max values based on the options
 * @param peaks
 * @param options
 * @returns
 */
function getInternalPeaks(peaks, minMaxY, options = {}) {
    let index = 0;
    let internalPeaks = [];
    const { baseline: shiftValue = minMaxY.min } = options;
    const normalizedPeaks = peaks.map((peak) => {
        return {
            ...peak,
            y: (peak.y - shiftValue) / minMaxY.range,
        };
    });
    for (const peak of normalizedPeaks) {
        const { id, shape = options.shape ? options.shape : { kind: 'gaussian' } } = peak;
        const shapeFct = (0, ml_peak_shape_generator_1.getShape1D)(shape);
        const parameters = ['x', 'y', ...shapeFct.getParameters()];
        const propertiesValues = {
            min: [],
            max: [],
            init: [],
            gradientDifference: [],
        };
        for (let parameter of parameters) {
            for (let property of properties) {
                // check if the property is specified in the peak
                let propertyValue = peak?.parameters?.[parameter]?.[property];
                if (propertyValue) {
                    propertyValue = getNormalizedValue(propertyValue, parameter, property, minMaxY, options.baseline);
                    propertiesValues[property].push(propertyValue);
                    continue;
                }
                // check if there are some global option, it could be a number or a callback
                let generalParameterValue = options?.parameters?.[parameter]?.[property];
                if (generalParameterValue) {
                    if (typeof generalParameterValue === 'number') {
                        generalParameterValue = getNormalizedValue(generalParameterValue, parameter, property, minMaxY, options.baseline);
                        propertiesValues[property].push(generalParameterValue);
                        continue;
                    }
                    else {
                        let value = generalParameterValue(peak);
                        value = getNormalizedValue(value, parameter, property, minMaxY, options.baseline);
                        propertiesValues[property].push(value);
                        continue;
                    }
                }
                // we just need to take the default parameters
                (0, assert_1.assert)(DefaultParameters_1.DefaultParameters[parameter], `No default parameter for ${parameter}`);
                const defaultParameterValues = DefaultParameters_1.DefaultParameters[parameter][property];
                //@ts-expect-error should never happen
                propertiesValues[property].push(defaultParameterValues(peak, shapeFct));
            }
        }
        const fromIndex = index;
        const toIndex = fromIndex + parameters.length - 1;
        index += toIndex - fromIndex + 1;
        internalPeaks.push({
            id,
            shape,
            shapeFct,
            parameters,
            propertiesValues,
            fromIndex,
            toIndex,
        });
    }
    return internalPeaks;
}
exports.getInternalPeaks = getInternalPeaks;
function getNormalizedValue(value, parameter, property, minMaxY, baseline) {
    if (parameter === 'y') {
        if (property === 'gradientDifference') {
            return value;
        }
        else {
            return baseline !== undefined
                ? (value - baseline) / minMaxY.range
                : (value - minMaxY.min) / minMaxY.range;
        }
    }
    return value;
}

},{"../assert":203,"./DefaultParameters":204,"ml-peak-shape-generator":187}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectMethod = void 0;
const ml_levenberg_marquardt_1 = require("ml-levenberg-marquardt");
const directOptimization_1 = require("./wrappers/directOptimization");
/** Algorithm to select the method.
 * @param optimizationOptions - Optimization options
 * @returns - The algorithm and optimization options
 */
function selectMethod(optimizationOptions = {}) {
    let { kind = 'lm', options } = optimizationOptions;
    switch (kind) {
        case 'lm':
        case 'levenbergMarquardt':
            return {
                algorithm: ml_levenberg_marquardt_1.levenbergMarquardt,
                optimizationOptions: {
                    damping: 1.5,
                    maxIterations: 20,
                    errorTolerance: 1e-8,
                    ...options,
                },
            };
        case 'direct': {
            return {
                algorithm: directOptimization_1.directOptimization,
                optimizationOptions: {
                    iterations: 20,
                    epsilon: 1e-4,
                    tolerance: 1e-16,
                    tolerance2: 1e-12,
                    initialState: {},
                    ...options,
                },
            };
        }
        default:
            throw new Error(`Unknown fitting algorithm`);
    }
}
exports.selectMethod = selectMethod;

},{"./wrappers/directOptimization":207,"ml-levenberg-marquardt":182}],207:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.directOptimization = void 0;
const ml_direct_1 = __importDefault(require("ml-direct"));
function directOptimization(data, sumOfShapes, options) {
    const { minValues, maxValues, maxIterations, epsilon, tolerance, tolerance2, initialState, } = options;
    const objectiveFunction = getObjectiveFunction(data, sumOfShapes);
    const result = (0, ml_direct_1.default)(objectiveFunction, minValues, maxValues, {
        iterations: maxIterations,
        epsilon,
        tolerance,
        tolerance2,
        initialState,
    });
    const { optima } = result;
    return {
        parameterError: result.minFunctionValue,
        iterations: result.iterations,
        parameterValues: optima[0],
    };
}
exports.directOptimization = directOptimization;
function getObjectiveFunction(data, sumOfShapes) {
    const { x, y } = data;
    const nbPoints = x.length;
    return (parameters) => {
        const fct = sumOfShapes(parameters);
        let error = 0;
        for (let i = 0; i < nbPoints; i++) {
            error += Math.pow(y[i] - fct(x[i]), 2);
        }
        return error;
    };
}

},{"ml-direct":155}],208:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./reim/reimAbsolute"), exports);
__exportStar(require("./reim/reimAutoPhaseCorrection"), exports);
__exportStar(require("./reim/reimPhaseCorrection"), exports);
__exportStar(require("./reim/reimFFT"), exports);
__exportStar(require("./x/xAbsolute"), exports);
__exportStar(require("./x/xAbsoluteMedian"), exports);
__exportStar(require("./x/xAdd"), exports);
__exportStar(require("./x/xAutoCorrelation"), exports);
__exportStar(require("./x/xBoxPlot"), exports);
__exportStar(require("./x/xCheck"), exports);
__exportStar(require("./x/xCorrelation"), exports);
__exportStar(require("./x/xCrossCorrelation"), exports);
__exportStar(require("./x/xCumulative"), exports);
__exportStar(require("./x/xDivide"), exports);
__exportStar(require("./x/xDotProduct"), exports);
__exportStar(require("./x/xEnsureFloat64"), exports);
__exportStar(require("./x/xFindClosestIndex"), exports);
__exportStar(require("./x/xGetFromToIndex"), exports);
__exportStar(require("./x/xGetTargetIndex"), exports);
__exportStar(require("./x/xHilbertTransform"), exports);
__exportStar(require("./x/xHistogram"), exports);
__exportStar(require("./x/xIsEquallySpaced"), exports);
__exportStar(require("./x/xIsMonotonic"), exports);
__exportStar(require("./x/xMaxIndex"), exports);
__exportStar(require("./x/xMaxValue"), exports);
__exportStar(require("./x/xMaxAbsoluteValue"), exports);
__exportStar(require("./x/xMean"), exports);
__exportStar(require("./x/xMeanWeighted"), exports);
__exportStar(require("./x/xMeanAbsoluteError"), exports);
__exportStar(require("./x/xMeanSquaredError"), exports);
__exportStar(require("./x/xMedian"), exports);
__exportStar(require("./x/xMedianAbsoluteDeviation"), exports);
__exportStar(require("./x/xMinIndex"), exports);
__exportStar(require("./x/xMinMaxValues"), exports);
__exportStar(require("./x/xMinMaxDelta"), exports);
__exportStar(require("./x/xMinValue"), exports);
__exportStar(require("./x/xMode"), exports);
__exportStar(require("./x/xMultiply"), exports);
__exportStar(require("./x/xNoiseSanPlot"), exports);
__exportStar(require("./x/xNoiseStandardDeviation"), exports);
__exportStar(require("./x/xNorm"), exports);
__exportStar(require("./x/xNormed"), exports);
__exportStar(require("./x/xPadding"), exports);
__exportStar(require("./x/xParetoNormalization"), exports);
__exportStar(require("./x/xRescale"), exports);
__exportStar(require("./x/xRolling"), exports);
__exportStar(require("./x/xRollingAverage"), exports);
__exportStar(require("./x/xRollingMax"), exports);
__exportStar(require("./x/xRollingMedian"), exports);
__exportStar(require("./x/xRollingMin"), exports);
__exportStar(require("./x/xRotate"), exports);
__exportStar(require("./x/xSampling"), exports);
__exportStar(require("./x/xSequentialFill"), exports);
__exportStar(require("./x/xStandardDeviation"), exports);
__exportStar(require("./x/xApplyFunctionStr"), exports);
__exportStar(require("./x/xSubtract"), exports);
__exportStar(require("./x/xSum"), exports);
__exportStar(require("./x/xUniqueSorted"), exports);
__exportStar(require("./x/xVariance"), exports);
__exportStar(require("./x/utils/getOutputArray"), exports);
__exportStar(require("./xy/xyAlign"), exports);
__exportStar(require("./xy/xyCheck"), exports);
__exportStar(require("./xy/xyFindClosestPoint"), exports);
__exportStar(require("./xy/xyCovariance"), exports);
__exportStar(require("./xy/xyCumulativeDistributionStatistics"), exports);
__exportStar(require("./xy/xyEnsureGrowingX"), exports);
__exportStar(require("./xy/xyEquallySpaced"), exports);
__exportStar(require("./xy/xyExtract"), exports);
__exportStar(require("./xy/xyFilterMinYValue"), exports);
__exportStar(require("./xy/xyFilterTopYValues"), exports);
__exportStar(require("./xy/xyFilterX"), exports);
__exportStar(require("./xy/xyFilterXPositive"), exports);
__exportStar(require("./xy/xyGetNMaxY"), exports);
__exportStar(require("./xy/xyGrowingX"), exports);
__exportStar(require("./xy/xyIntegral"), exports);
__exportStar(require("./xy/xyIntegration"), exports);
__exportStar(require("./xy/xyJoinX"), exports);
__exportStar(require("./xy/xyMaxClosestYPoint"), exports);
__exportStar(require("./xy/xyMaximaY"), exports);
__exportStar(require("./xy/xyMaxMerge"), exports);
__exportStar(require("./xy/xyMaxY"), exports);
__exportStar(require("./xy/xyMaxYPoint"), exports);
__exportStar(require("./xy/xyMedian"), exports);
__exportStar(require("./xy/xyMergeByCentroids"), exports);
__exportStar(require("./xy/xyMinClosestYPoint"), exports);
__exportStar(require("./xy/xyMinimaY"), exports);
__exportStar(require("./xy/xyMinYPoint"), exports);
__exportStar(require("./xy/xyPeakInfo"), exports);
__exportStar(require("./xy/xyRealMaxYPoint"), exports);
__exportStar(require("./xy/xyRealMinYPoint"), exports);
__exportStar(require("./xy/xyReduce"), exports);
__exportStar(require("./xy/xyRolling"), exports);
__exportStar(require("./xy/xySetYValue"), exports);
__exportStar(require("./xy/xySortX"), exports);
__exportStar(require("./xy/xyToXYArray"), exports);
__exportStar(require("./xy/xyToXYObject"), exports);
__exportStar(require("./xy/xyUniqueX"), exports);
__exportStar(require("./xy/xyWeightedMerge"), exports);
__exportStar(require("./xy2/xy2ToXY"), exports);
__exportStar(require("./xreim/xreimZeroFilling"), exports);
__exportStar(require("./xreim/xreimSortX"), exports);
__exportStar(require("./xyArray/xyArrayAlign"), exports);
__exportStar(require("./xyArray/xyArrayMerge"), exports);
__exportStar(require("./xyArray/xyArrayWeightedMerge"), exports);
__exportStar(require("./xyArray/xyArrayAlignToFirst"), exports);
__exportStar(require("./xyObject/xyObjectBestPoints"), exports);
__exportStar(require("./xyObject/xyObjectJoinX"), exports);
__exportStar(require("./xyObject/xyObjectMaxXPoint"), exports);
__exportStar(require("./xyObject/xyObjectMinXPoint"), exports);
__exportStar(require("./xyObject/xyObjectMaxYPoint"), exports);
__exportStar(require("./xyObject/xyObjectMinYPoint"), exports);
__exportStar(require("./xyObject/xyObjectSlotX"), exports);
__exportStar(require("./xyObject/xyObjectSortX"), exports);
__exportStar(require("./xyObject/xyObjectSumY"), exports);
__exportStar(require("./xyObject/xyObjectToXY"), exports);
__exportStar(require("./zone/zoneToX"), exports);
__exportStar(require("./zones/zonesNormalize"), exports);
__exportStar(require("./matrix/matrixApplyNumericalEncoding"), exports);
__exportStar(require("./matrix/matrixAutoCorrelation"), exports);
__exportStar(require("./matrix/matrixBoxPlot"), exports);
__exportStar(require("./matrix/matrixCenterZMean"), exports);
__exportStar(require("./matrix/matrixClone"), exports);
__exportStar(require("./matrix/matrixHistogram"), exports);
__exportStar(require("./matrix/matrixMinMaxZ"), exports);
__exportStar(require("./matrix/matrixMinMaxAbsoluteZ"), exports);
__exportStar(require("./matrix/matrixMaxAbsoluteZ"), exports);
__exportStar(require("./matrix/matrixNumericalEncoding"), exports);
__exportStar(require("./matrix/matrixNumericalDecoding"), exports);
__exportStar(require("./matrix/matrixZPivotRescale"), exports);
__exportStar(require("./matrix/matrixPQN"), exports);
__exportStar(require("./matrix/matrixZRescale"), exports);
__exportStar(require("./matrix/matrixZRescalePerColumn"), exports);
__exportStar(require("./matrix/matrixAbsoluteMedian"), exports);
__exportStar(require("./matrix/matrixMedian"), exports);
__exportStar(require("./matrix/matrixNoiseStandardDeviation"), exports);
__exportStar(require("./matrix/matrixToArray"), exports);
__exportStar(require("./utils/createFromToArray"), exports);
__exportStar(require("./utils/createRandomArray"), exports);
__exportStar(require("./utils/createStepArray"), exports);
__exportStar(require("./types/DataReIm"), exports);
__exportStar(require("./types/DataXReIm"), exports);
__exportStar(require("./types/Point"), exports);

},{"./matrix/matrixAbsoluteMedian":209,"./matrix/matrixApplyNumericalEncoding":210,"./matrix/matrixAutoCorrelation":211,"./matrix/matrixBoxPlot":212,"./matrix/matrixCenterZMean":213,"./matrix/matrixClone":215,"./matrix/matrixHistogram":217,"./matrix/matrixMaxAbsoluteZ":218,"./matrix/matrixMedian":219,"./matrix/matrixMinMaxAbsoluteZ":220,"./matrix/matrixMinMaxZ":221,"./matrix/matrixNoiseStandardDeviation":222,"./matrix/matrixNumericalDecoding":223,"./matrix/matrixNumericalEncoding":224,"./matrix/matrixPQN":225,"./matrix/matrixToArray":226,"./matrix/matrixZPivotRescale":227,"./matrix/matrixZRescale":228,"./matrix/matrixZRescalePerColumn":229,"./reim/reimAbsolute":230,"./reim/reimAutoPhaseCorrection":231,"./reim/reimFFT":232,"./reim/reimPhaseCorrection":233,"./types/DataReIm":234,"./types/DataXReIm":235,"./types/Point":236,"./utils/createFromToArray":237,"./utils/createRandomArray":238,"./utils/createStepArray":239,"./x/utils/getOutputArray":242,"./x/xAbsolute":243,"./x/xAbsoluteMedian":244,"./x/xAdd":245,"./x/xApplyFunctionStr":246,"./x/xAutoCorrelation":247,"./x/xBoxPlot":248,"./x/xCheck":249,"./x/xCorrelation":251,"./x/xCrossCorrelation":252,"./x/xCumulative":253,"./x/xDivide":254,"./x/xDotProduct":255,"./x/xEnsureFloat64":256,"./x/xFindClosestIndex":257,"./x/xGetFromToIndex":258,"./x/xGetTargetIndex":259,"./x/xHilbertTransform":260,"./x/xHistogram":261,"./x/xIsEquallySpaced":262,"./x/xIsMonotonic":263,"./x/xMaxAbsoluteValue":264,"./x/xMaxIndex":265,"./x/xMaxValue":266,"./x/xMean":267,"./x/xMeanAbsoluteError":268,"./x/xMeanSquaredError":269,"./x/xMeanWeighted":270,"./x/xMedian":271,"./x/xMedianAbsoluteDeviation":272,"./x/xMinIndex":273,"./x/xMinMaxDelta":274,"./x/xMinMaxValues":275,"./x/xMinValue":276,"./x/xMode":277,"./x/xMultiply":278,"./x/xNoiseSanPlot":279,"./x/xNoiseStandardDeviation":280,"./x/xNorm":281,"./x/xNormed":282,"./x/xPadding":283,"./x/xParetoNormalization":284,"./x/xRescale":285,"./x/xRolling":286,"./x/xRollingAverage":287,"./x/xRollingMax":288,"./x/xRollingMedian":289,"./x/xRollingMin":290,"./x/xRotate":291,"./x/xSampling":292,"./x/xSequentialFill":293,"./x/xStandardDeviation":295,"./x/xSubtract":296,"./x/xSum":297,"./x/xUniqueSorted":298,"./x/xVariance":299,"./xreim/xreimSortX":300,"./xreim/xreimZeroFilling":301,"./xy/xyAlign":305,"./xy/xyCheck":306,"./xy/xyCovariance":307,"./xy/xyCumulativeDistributionStatistics":308,"./xy/xyEnsureGrowingX":309,"./xy/xyEquallySpaced":310,"./xy/xyExtract":311,"./xy/xyFilterMinYValue":312,"./xy/xyFilterTopYValues":313,"./xy/xyFilterX":314,"./xy/xyFilterXPositive":315,"./xy/xyFindClosestPoint":316,"./xy/xyGetNMaxY":317,"./xy/xyGrowingX":318,"./xy/xyIntegral":319,"./xy/xyIntegration":320,"./xy/xyJoinX":321,"./xy/xyMaxClosestYPoint":322,"./xy/xyMaxMerge":323,"./xy/xyMaxY":324,"./xy/xyMaxYPoint":325,"./xy/xyMaximaY":326,"./xy/xyMedian":327,"./xy/xyMergeByCentroids":328,"./xy/xyMinClosestYPoint":329,"./xy/xyMinYPoint":330,"./xy/xyMinimaY":331,"./xy/xyPeakInfo":332,"./xy/xyRealMaxYPoint":333,"./xy/xyRealMinYPoint":334,"./xy/xyReduce":335,"./xy/xyRolling":336,"./xy/xySetYValue":337,"./xy/xySortX":338,"./xy/xyToXYArray":339,"./xy/xyToXYObject":340,"./xy/xyUniqueX":341,"./xy/xyWeightedMerge":342,"./xy2/xy2ToXY":343,"./xyArray/xyArrayAlign":346,"./xyArray/xyArrayAlignToFirst":347,"./xyArray/xyArrayMerge":348,"./xyArray/xyArrayWeightedMerge":349,"./xyObject/xyObjectBestPoints":350,"./xyObject/xyObjectJoinX":352,"./xyObject/xyObjectMaxXPoint":353,"./xyObject/xyObjectMaxYPoint":354,"./xyObject/xyObjectMinXPoint":355,"./xyObject/xyObjectMinYPoint":356,"./xyObject/xyObjectSlotX":357,"./xyObject/xyObjectSortX":358,"./xyObject/xyObjectSumY":359,"./xyObject/xyObjectToXY":360,"./zone/zoneToX":361,"./zones/zonesNormalize":362}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixAbsoluteMedian = void 0;
const __1 = require("..");
/**
 * returns the median of the absolute matrix
 */
function matrixAbsoluteMedian(matrix) {
    const nbColumns = matrix[0].length;
    const flatten = new Float64Array(matrix.length * nbColumns);
    for (let row = 0; row < matrix.length; row++) {
        const currentRow = row * nbColumns;
        for (let column = 0; column < nbColumns; column++) {
            const value = matrix[row][column];
            flatten[currentRow + column] = value < 0 ? -value : value;
        }
    }
    return (0, __1.xMedian)(flatten);
}
exports.matrixAbsoluteMedian = matrixAbsoluteMedian;

},{"..":208}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixApplyNumericalEncoding = void 0;
const xMaxValue_1 = require("../x/xMaxValue");
const matrixClone_1 = require("./matrixClone");
/**
 * Numerically encodes the strings in the matrix with an encoding dictionary
 * @param matrixInitial - original matrix before encoding
 * @param dictionnary - dictionary against which to do the encoding
 * @returns - encoded matrix
 */
function matrixApplyNumericalEncoding(matrixInitial, dictionnary) {
    const matrix = (0, matrixClone_1.matrixClone)(matrixInitial);
    let arrayOfValues = [];
    for (let key in dictionnary) {
        arrayOfValues.push(dictionnary[key]);
    }
    let k = (0, xMaxValue_1.xMaxValue)(arrayOfValues);
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
            if (typeof matrix[i][j] === 'string') {
                if (matrix[i][j] in dictionnary) {
                    matrix[i][j] = dictionnary[matrix[i][j]];
                }
                else {
                    k++;
                    dictionnary[matrix[i][j]] = k;
                    matrix[i][j] = k;
                }
            }
        }
    }
    return matrix;
}
exports.matrixApplyNumericalEncoding = matrixApplyNumericalEncoding;

},{"../x/xMaxValue":266,"./matrixClone":215}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixAutoCorrelation = void 0;
const __1 = require("..");
/**
 * returns the median of the matrix
 */
function matrixAutoCorrelation(matrix, index = 0) {
    let nbRows = matrix.length;
    let nbColumns = matrix[0].length;
    if (nbRows < 2) {
        throw new Error('matrixAutoCorrelation: can not calculate info if matrix contains less than 2 rows');
    }
    let targetArray = new Float64Array(nbRows);
    let sourceArray = new Float64Array(nbRows);
    let result = new Float64Array(nbColumns);
    for (let j = 0; j < nbRows; j++) {
        targetArray[j] = matrix[j][index];
    }
    for (let i = 0; i < nbColumns; i++) {
        for (let j = 0; j < nbRows; j++) {
            sourceArray[j] = matrix[j][i];
        }
        result[i] = (0, __1.xCorrelation)(targetArray, sourceArray);
    }
    return result;
}
exports.matrixAutoCorrelation = matrixAutoCorrelation;

},{"..":208}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixBoxPlot = void 0;
/**
 * returns the median of the matrix
 */
function matrixBoxPlot(matrix) {
    const nbRows = matrix.length;
    const nbColumns = matrix[0].length;
    if (nbRows < 5) {
        throw new Error('matrixBoxPlot: can not calculate info if matrix contains less than 5 rows');
    }
    let info = {
        q1: new Float64Array(nbColumns),
        median: new Float64Array(nbColumns),
        q3: new Float64Array(nbColumns),
        min: Float64Array.from(matrix[0]),
        max: Float64Array.from(matrix[matrix.length - 1]),
    };
    const columnArray = new Float64Array(matrix.length);
    for (let column = 0; column < nbColumns; column++) {
        for (let row = 0; row < nbRows; row++) {
            columnArray[row] = matrix[row][column];
        }
        let q1max = 0;
        let q3min = 0;
        if (nbRows % 2 === 1) {
            // odd
            let middle = (nbRows - 1) / 2;
            info.median[column] = columnArray[middle];
            q1max = middle - 1;
            q3min = middle + 1;
        }
        else {
            // even
            q3min = nbRows / 2;
            q1max = q3min - 1;
            info.median[column] = (columnArray[q1max] + columnArray[q3min]) / 2;
        }
        if (q1max % 2 === 0) {
            info.q1[column] = columnArray[q1max / 2];
            info.q3[column] = columnArray[(nbRows + q3min - 1) / 2];
        }
        else {
            info.q1[column] =
                (columnArray[(q1max + 1) / 2] + columnArray[(q1max - 1) / 2]) / 2;
            let middleOver = (columnArray.length + q3min) / 2;
            info.q3[column] =
                (columnArray[middleOver] + columnArray[middleOver - 1]) / 2;
        }
    }
    return info;
}
exports.matrixBoxPlot = matrixBoxPlot;

},{}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixCenterZMean = void 0;
const matrixCreateEmpty_1 = require("./matrixCreateEmpty");
/**
 * Center mean of columns
 *
 * @param matrix - matrix [rows][cols]
 */
function matrixCenterZMean(matrix) {
    const nbColumns = matrix[0].length;
    const nbRows = matrix.length;
    const newMatrix = (0, matrixCreateEmpty_1.matrixCreateEmpty)({ nbColumns, nbRows });
    for (let column = 0; column < nbColumns; column++) {
        let mean = 0;
        for (let row = 0; row < nbRows; row++) {
            mean += matrix[row][column];
        }
        mean /= nbRows;
        for (let row = 0; row < nbRows; row++) {
            newMatrix[row][column] = matrix[row][column] - mean;
        }
    }
    return newMatrix;
}
exports.matrixCenterZMean = matrixCenterZMean;

},{"./matrixCreateEmpty":216}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixCheck = void 0;
function matrixCheck(data) {
    if (data.length === 0 || data[0].length === 0) {
        throw new RangeError('matrix should contain data');
    }
    const firstLength = data[0].length;
    for (let i = 1; i < data.length; i++) {
        if (data[i].length !== firstLength) {
            throw new RangeError('All rows should has the same length');
        }
    }
}
exports.matrixCheck = matrixCheck;

},{}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixClone = void 0;
/**
 * Clone the matrix
 */
function matrixClone(matrix) {
    return matrix.map((row) => row.slice(0));
}
exports.matrixClone = matrixClone;

},{}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixCreateEmpty = void 0;
/**
 * Create a new matrix based on the size of the current one
 */
function matrixCreateEmpty(options) {
    const { matrix, nbRows = matrix?.length || 1, nbColumns = matrix?.[0].length || 1, ArrayConstructor = Float64Array, } = options;
    const newMatrix = new Array(nbRows);
    for (let row = 0; row < nbRows; row++) {
        newMatrix[row] = new ArrayConstructor(nbColumns);
    }
    return newMatrix;
}
exports.matrixCreateEmpty = matrixCreateEmpty;

},{}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixHistogram = void 0;
const xHistogram_1 = require("../x/xHistogram");
const matrixMinMaxAbsoluteZ_1 = require("./matrixMinMaxAbsoluteZ");
const matrixMinMaxZ_1 = require("./matrixMinMaxZ");
/**
 * Calculates an histogram of defined number of slots
 *
 * @param matrix - matrix [rows][cols].
 * @param options - options
 * @returns - result of the histogram
 */
function matrixHistogram(matrix, options = {}) {
    const { logBaseY, logBaseX, absolute, min, max } = options;
    options = JSON.parse(JSON.stringify(options));
    delete options.logBaseY;
    if (matrix.length === 0 || matrix[0].length === 0) {
        throw new Error('matrixHistogram: matrix should have at least one column and one row');
    }
    if (min === undefined || max === undefined) {
        const minMax = absolute
            ? (0, matrixMinMaxAbsoluteZ_1.matrixMinMaxAbsoluteZ)(matrix)
            : (0, matrixMinMaxZ_1.matrixMinMaxZ)(matrix);
        if (min === undefined) {
            options.min =
                logBaseX && minMax.min
                    ? Math.log(minMax.min) / Math.log(logBaseX)
                    : minMax.min;
        }
        if (max === undefined) {
            options.max =
                logBaseX && minMax.max
                    ? Math.log(minMax.max) / Math.log(logBaseX)
                    : minMax.max;
        }
    }
    let histogram = (0, xHistogram_1.xHistogram)(matrix[0], options);
    options.histogram = histogram;
    const nbRows = matrix.length;
    for (let row = 1; row < nbRows; row++) {
        (0, xHistogram_1.xHistogram)(matrix[row], options);
    }
    const y = histogram.y;
    if (logBaseY) {
        const logOfBase = Math.log10(logBaseY);
        for (let i = 0; i < y.length; i++) {
            y[i] = Math.log10(y[i] + 1) / logOfBase;
        }
    }
    return histogram;
}
exports.matrixHistogram = matrixHistogram;

},{"../x/xHistogram":261,"./matrixMinMaxAbsoluteZ":220,"./matrixMinMaxZ":221}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixMaxAbsoluteZ = void 0;
/**
 * Returns the max absolute values of Z
 *
 * @param matrix - matrix [rows][cols].
 */
function matrixMaxAbsoluteZ(matrix) {
    if (matrix.length === 0 || matrix[0].length === 0) {
        throw new Error('matrixMaxAbsoluteZ requires at least 1 row and 1 column');
    }
    const nbRows = matrix.length;
    const nbColumns = matrix[0].length;
    let max = Number.NEGATIVE_INFINITY;
    for (let column = 0; column < nbColumns; column++) {
        for (let row = 0; row < nbRows; row++) {
            let value = matrix[row][column];
            if (value < 0)
                value *= -1;
            if (value > max)
                max = value;
        }
    }
    return max;
}
exports.matrixMaxAbsoluteZ = matrixMaxAbsoluteZ;

},{}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixMedian = void 0;
const __1 = require("..");
const matrixToArray_1 = require("./matrixToArray");
/**
 * returns the median of the matrix
 */
function matrixMedian(matrix) {
    return (0, __1.xMedian)((0, matrixToArray_1.matrixToArray)(matrix));
}
exports.matrixMedian = matrixMedian;

},{"..":208,"./matrixToArray":226}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixMinMaxAbsoluteZ = void 0;
/**
 * Get min and max of the absolute values of Z
 *
 * @param matrix - matrix [rows][cols].
 */
function matrixMinMaxAbsoluteZ(matrix) {
    if (matrix.length === 0 || matrix[0].length === 0) {
        throw new Error('matrixMinMaxAbsoluteZ requires at least 1 row and 1 column');
    }
    const nbRows = matrix.length;
    const nbColumns = matrix[0].length;
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    for (let column = 0; column < nbColumns; column++) {
        for (let row = 0; row < nbRows; row++) {
            let value = matrix[row][column];
            if (value < 0)
                value *= -1;
            if (value < min)
                min = value;
            if (value > max)
                max = value;
        }
    }
    return { min, max };
}
exports.matrixMinMaxAbsoluteZ = matrixMinMaxAbsoluteZ;

},{}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixMinMaxZ = void 0;
const matrixCheck_1 = require("./matrixCheck");
/**
 * Get min and max Z
 *
 * @param matrix - matrix [rows][cols].
 */
function matrixMinMaxZ(matrix) {
    (0, matrixCheck_1.matrixCheck)(matrix);
    const nbRows = matrix.length;
    const nbColumns = matrix[0].length;
    let min = matrix[0][0];
    let max = matrix[0][0];
    for (let column = 0; column < nbColumns; column++) {
        for (let row = 0; row < nbRows; row++) {
            if (matrix[row][column] < min)
                min = matrix[row][column];
            if (matrix[row][column] > max)
                max = matrix[row][column];
        }
    }
    return { min, max };
}
exports.matrixMinMaxZ = matrixMinMaxZ;

},{"./matrixCheck":214}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixNoiseStandardDeviation = void 0;
const xNoiseStandardDeviation_1 = require("../x/xNoiseStandardDeviation");
const matrixToArray_1 = require("./matrixToArray");
/**
 * Determine noise level using MAD https://en.wikipedia.org/wiki/Median_absolute_deviation
 * Constant to convert mad to sd calculated using https://www.wolframalpha.com/input?i=sqrt%282%29+inverse+erf%280.5%29
 * This assumes a gaussian distribution of the noise
 * @param matrix
 * @returns noise level corresponding to one standard deviation
 */
function matrixNoiseStandardDeviation(matrix) {
    return (0, xNoiseStandardDeviation_1.xNoiseStandardDeviation)((0, matrixToArray_1.matrixToArray)(matrix));
}
exports.matrixNoiseStandardDeviation = matrixNoiseStandardDeviation;

},{"../x/xNoiseStandardDeviation":280,"./matrixToArray":226}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixNumericalDecoding = void 0;
const matrixClone_1 = require("./matrixClone");
/**
 * Numerically decodes the matrix using the dictionnary
 * @param matrixInitial - original matrix before encoding
 * @param dictionnary - dictionary against which to do the encoding
 * @returns - decoded matrix
 */
function swap(dictionnary) {
    let ret = {};
    for (let key in dictionnary) {
        ret[Number(dictionnary[key])] = key;
    }
    return ret;
}
function matrixNumericalDecoding(matrixInitial, dictionnary) {
    const matrix = (0, matrixClone_1.matrixClone)(matrixInitial);
    let invertedDictionnary = swap(dictionnary);
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] in invertedDictionnary) {
                matrix[i][j] = invertedDictionnary[matrix[i][j]];
            }
        }
    }
    return matrix;
}
exports.matrixNumericalDecoding = matrixNumericalDecoding;

},{"./matrixClone":215}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixNumericalEncoding = void 0;
const matrixClone_1 = require("./matrixClone");
/**
 * Numerically encodes the strings in the matrix and returns an encoding dictionnary which can be used to encode other matrices
 * @param matrix - original matrix before encoding
 * @param dictCategoricalToNumerical - dictionnary for encoding
 * @returns - dictionnary from string to number
 */
function matrixNumericalEncoding(matrixInitial) {
    const matrix = (0, matrixClone_1.matrixClone)(matrixInitial);
    let nRows = matrix.length;
    let nColumns = matrix[0].length;
    let dictCategoricalToNumerical = {};
    let k = 0;
    for (let i = 0; i < nRows; i++) {
        for (let j = 0; j < nColumns; j++) {
            if (typeof matrix[i][j] === 'number' && matrix[i][j] > k) {
                k = matrix[i][j];
            }
        }
    }
    for (let i = 0; i < nRows; i++) {
        for (let j = 0; j < nColumns; j++) {
            if (typeof matrix[i][j] === 'string') {
                if (matrix[i][j] in dictCategoricalToNumerical) {
                    matrix[i][j] = dictCategoricalToNumerical[matrix[i][j]];
                }
                else {
                    k++;
                    dictCategoricalToNumerical[matrix[i][j]] = k;
                    matrix[i][j] = k;
                }
            }
        }
    }
    return { matrix, dictCategoricalToNumerical };
}
exports.matrixNumericalEncoding = matrixNumericalEncoding;

},{"./matrixClone":215}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixPQN = void 0;
const ml_matrix_1 = require("ml-matrix");
const xMedian_1 = require("../x/xMedian");
/**
 * Performs a Probabilistic quotient normalization (PQN) over the dataset to account dilution based in median spectrum.
 * Dieterle, F., Ross, A., Schlotterbeck, G., & Senn, H. (2006). Probabilistic quotient normalization as robust method to account for dilution of complex biological mixtures. Application in 1H NMR metabonomics. Analytical chemistry, 78(13), 4281-4290.
 * DOI: 10.1021/ac051632c
 *
 * @param matrix - matrix [rows][cols].
 * @param options - options
 * @returns - {data: Normalized dataset, medianOfQuotients: The median of quotients of each variables}
 */
function matrixPQN(matrix, options = {}) {
    const { max = 100 } = options;
    let matrixB = new ml_matrix_1.Matrix(matrix);
    for (let i = 0; i < matrixB.rows; i++) {
        const normalizationFactor = matrixB.getRowVector(i).norm('frobenius') / max;
        const row = matrixB.getRowVector(i).div(normalizationFactor);
        matrixB.setRow(i, row);
    }
    let referenceSpectrum = [];
    for (let i = 0; i < matrixB.columns; i++) {
        const currentVariable = matrixB.getColumn(i);
        referenceSpectrum.push((0, xMedian_1.xMedian)(currentVariable));
    }
    let medianOfQuotients = [];
    for (let i = 0; i < matrixB.columns; i++) {
        let quotients = matrixB.getColumnVector(i).div(referenceSpectrum[i]);
        medianOfQuotients.push((0, xMedian_1.xMedian)(quotients.getColumn(0)));
    }
    for (let i = 0; i < matrixB.rows; i++) {
        matrixB.mulRow(i, 1 / medianOfQuotients[i]);
    }
    return {
        data: matrixB.to2DArray(),
        medianOfQuotients,
    };
}
exports.matrixPQN = matrixPQN;

},{"../x/xMedian":271,"ml-matrix":186}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixToArray = void 0;
const matrixCheck_1 = require("./matrixCheck");
function matrixToArray(matrix) {
    (0, matrixCheck_1.matrixCheck)(matrix);
    const nbColumns = matrix[0].length;
    const flatten = new Float64Array(matrix.length * nbColumns);
    for (let row = 0; row < matrix.length; row++) {
        const currentRow = row * nbColumns;
        for (let column = 0; column < nbColumns; column++) {
            flatten[currentRow + column] = matrix[row][column];
        }
    }
    return flatten;
}
exports.matrixToArray = matrixToArray;

},{"./matrixCheck":214}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixZPivotRescale = void 0;
const matrixCreateEmpty_1 = require("./matrixCreateEmpty");
const matrixMaxAbsoluteZ_1 = require("./matrixMaxAbsoluteZ");
/**
 * Rescale a matrix around 0 taking into account the absolute max value
 *
 * @param matrix - matrix [rows][cols].
 * @param options - Options
 */
function matrixZPivotRescale(matrix, options = {}) {
    const { max = 1, ArrayConstructor } = options;
    const nbColumns = matrix[0].length;
    const nbRows = matrix.length;
    const newMatrix = (0, matrixCreateEmpty_1.matrixCreateEmpty)({ nbColumns, nbRows, ArrayConstructor });
    const currentMax = (0, matrixMaxAbsoluteZ_1.matrixMaxAbsoluteZ)(matrix);
    for (let column = 0; column < nbColumns; column++) {
        const factor = max / currentMax;
        for (let row = 0; row < nbRows; row++) {
            newMatrix[row][column] = matrix[row][column] * factor;
        }
    }
    return newMatrix;
}
exports.matrixZPivotRescale = matrixZPivotRescale;

},{"./matrixCreateEmpty":216,"./matrixMaxAbsoluteZ":218}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixZRescale = void 0;
const matrixCreateEmpty_1 = require("./matrixCreateEmpty");
const matrixMinMaxZ_1 = require("./matrixMinMaxZ");
/**
 * Rescale a matrix between min and max values
 *
 * @param matrix - matrix [rows][cols].
 * @param options - Options
 */
function matrixZRescale(matrix, options = {}) {
    const { min = 0, max = 1, ArrayConstructor } = options;
    const nbColumns = matrix[0].length;
    const nbRows = matrix.length;
    const newMatrix = (0, matrixCreateEmpty_1.matrixCreateEmpty)({ nbColumns, nbRows, ArrayConstructor });
    const { min: currentMin, max: currentMax } = (0, matrixMinMaxZ_1.matrixMinMaxZ)(matrix);
    const factor = (max - min) / (currentMax - currentMin);
    for (let column = 0; column < nbColumns; column++) {
        for (let row = 0; row < nbRows; row++) {
            newMatrix[row][column] =
                (matrix[row][column] - currentMin) * factor + min;
        }
    }
    return newMatrix;
}
exports.matrixZRescale = matrixZRescale;

},{"./matrixCreateEmpty":216,"./matrixMinMaxZ":221}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matrixZRescalePerColumn = void 0;
const matrixCreateEmpty_1 = require("./matrixCreateEmpty");
/**
 * Rescale the matrix per column for which we get the min and max values
 *
 * @param matrix - matrix [rows][cols].
 * @param options - Options
 */
function matrixZRescalePerColumn(matrix, options = {}) {
    const { min = 0, max = 1 } = options;
    const nbColumns = matrix[0].length;
    const nbRows = matrix.length;
    const newMatrix = (0, matrixCreateEmpty_1.matrixCreateEmpty)({ nbColumns, nbRows });
    for (let column = 0; column < nbColumns; column++) {
        let currentMin = matrix[0][column];
        let currentMax = matrix[0][column];
        for (let row = 1; row < nbRows; row++) {
            if (matrix[row][column] < currentMin)
                currentMin = matrix[row][column];
            if (matrix[row][column] > currentMax)
                currentMax = matrix[row][column];
        }
        const factor = (max - min) / (currentMax - currentMin);
        for (let row = 0; row < nbRows; row++) {
            newMatrix[row][column] =
                (matrix[row][column] - currentMin) * factor + min;
        }
    }
    return newMatrix;
}
exports.matrixZRescalePerColumn = matrixZRescalePerColumn;

},{"./matrixCreateEmpty":216}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimAbsolute = void 0;
/**
 * Calculates reimAbsolute value of a complex spectrum
 *
 * @param data - complex spectrum
 * @returns - reimAbsolute value
 */
function reimAbsolute(data) {
    const length = data.re.length;
    const re = data.re;
    const im = data.im;
    const newArray = new Float64Array(length);
    for (let i = 0; i < length; i++) {
        newArray[i] = Math.sqrt(re[i] ** 2 + im[i] ** 2);
    }
    return newArray;
}
exports.reimAbsolute = reimAbsolute;

},{}],231:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimAutoPhaseCorrection = void 0;
const xNoiseSanPlot_1 = require("../x/xNoiseSanPlot");
const reimAbsolute_1 = require("./reimAbsolute");
const reimPhaseCorrection_1 = require("./reimPhaseCorrection");
/**
 * Implementation of the algorithm for automatic phase correction: A robust, general automatic phase
 * correction algorithm for high-resolution NMR data. 10.1002/mrc.4586
 *
 * @param data - complex spectrum
 * @param options - options
 */
function reimAutoPhaseCorrection(data, options = {}) {
    const { re, im } = data;
    const length = re.length;
    const { magnitudeMode = true, minRegSize = 30, factorNoise = 3, maxDistanceToJoin = 256, } = options;
    let magnitudeData = magnitudeMode ? (0, reimAbsolute_1.reimAbsolute)(data) : re;
    let ds = holoborodko(magnitudeData);
    let peaksDs = robustBaseLineRegionsDetection(ds, {
        maxDistanceToJoin,
        magnitudeMode,
        factorNoise,
    });
    let peaksSp = robustBaseLineRegionsDetection(magnitudeData, {
        maxDistanceToJoin,
        magnitudeMode,
        factorNoise,
    });
    let finalPeaks = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        finalPeaks[i] = peaksSp[i] && peaksDs[i];
    }
    // Once the regions are detected, we auto phase each of them separately.
    // This part can be put inside a function
    let i = -1;
    let x0 = 0;
    let res = [];
    while (i < length) {
        //phase first region
        let reTmp = [];
        let imTmp = [];
        //Look for the first 1 in the array
        while (!finalPeaks[++i] && i < length) {
            //Add some extra points(0.1 ppm) at rigth and left sides of the region.
            x0 = i;
        }
        for (; finalPeaks[i] && i < length; i++) {
            reTmp.push(re[i]);
            imTmp.push(im[i]);
            i++;
        }
        if (reTmp.length > minRegSize) {
            res.push(autoPhaseRegion(reTmp, imTmp, x0));
        }
    }
    // Still some corrections needed. In the paper they remove the outlayers interatively
    // until they can perform a regression witout bad points. Can someone help here?
    let [ph1, ph0] = weightedLinearRegression(res.map((r) => r.x0 / length), res.map((r) => r.ph0), res.map((r) => r.area / 1e11));
    let phased = (0, reimPhaseCorrection_1.reimPhaseCorrection)({ re, im }, (ph0 * Math.PI) / 180, (ph1 * Math.PI) / 180);
    return { data: phased, ph0, ph1 };
}
exports.reimAutoPhaseCorrection = reimAutoPhaseCorrection;
/**
 * AutoPhaseRegion.
 *
 * @param re - Array of Number.
 * @param im - Array of Number.
 * @param x0 - Number.
 * @returns Region.
 */
function autoPhaseRegion(re, im, x0) {
    let start = -180;
    let stop = 180;
    let nSteps = 6;
    let maxSteps = 5;
    let bestAng = 0;
    let minArea = Number.MAX_SAFE_INTEGER;
    while (maxSteps > 0) {
        let dAng = (stop - start) / (nSteps + 1);
        for (let i = start; i <= stop; i += dAng) {
            let phased = (0, reimPhaseCorrection_1.reimPhaseCorrection)({ re, im }, toRadians(i), 0);
            let negArea = getNegArea(phased.re);
            if (negArea < minArea) {
                [minArea, bestAng] = [negArea, i];
            }
        }
        start = bestAng - dAng;
        stop = bestAng + dAng;
        maxSteps--;
    }
    // Calculate the area for the best angle
    let phased = (0, reimPhaseCorrection_1.reimPhaseCorrection)({ re, im }, toRadians(bestAng), 0);
    let area = 0;
    let sumX = 0;
    for (let j = 0; j < re.length; j++) {
        area += phased.re[j];
        sumX += phased.re[j] * (j + x0);
    }
    return { ph0: bestAng, area, x0: sumX / area };
}
/**
 * Holoborodko.
 *
 * @param s - Array of float.
 * @returns Array of float.
 */
function holoborodko(s) {
    let dk = new Float64Array(s.length);
    for (let i = 5; i < s.length - 5; i++) {
        dk[i] =
            (42 * (s[i + 1] - s[i - 1]) +
                48 * (s[i + 2] - s[i - 2]) +
                27 * (s[i + 3] + s[i - 3]) +
                8 * (s[i + 4] - s[i - 4]) +
                s[i + 5] -
                s[i - 5]) /
                512;
    }
    //Fill the borders
    for (let i = 0; i < 5; i++) {
        dk[i] = dk[5];
        dk[s.length - i - 1] = dk[s.length - 6];
    }
    return dk;
}
/**
 * RobustBaseLineRegionsDetection.
 *
 * @param s
 * @param options
 * @param options.magnitudeMode
 * @param options.maxDistanceToJoin
 * @param options.factorNoise
 */
function robustBaseLineRegionsDetection(s, options) {
    const { maxDistanceToJoin, magnitudeMode, factorNoise } = options;
    let mask = new Uint8Array(s.length);
    for (let i = 0; i < s.length; i++) {
        mask[i] = 0;
    }
    let change = true;
    while (change) {
        let noiseLevel = (0, xNoiseSanPlot_1.xNoiseSanPlot)(s, { magnitudeMode });
        let cutOff = factorNoise * noiseLevel.positive;
        change = false;
        for (let i = 0; i < s.length; i++) {
            if (Math.abs(s[i]) > cutOff && !mask[i]) {
                change = true;
                mask[i] = 1;
            }
        }
    }
    // Clean up mask by merging peaks blocks, separated by just a few points(4??).
    let count = 0;
    let prev = 0;
    for (let i = 0; i < s.length; i++) {
        if (!mask[i]) {
            count++;
        }
        else {
            if (count < maxDistanceToJoin) {
                for (let j = 0; j <= count; j++) {
                    mask[prev + j] = 1;
                }
            }
            while (mask[++i] && i < s.length)
                ;
            prev = i;
            count = 0;
        }
    }
    return mask;
}
/**
 * WeightedLinearRegression.
 *
 * @param x
 * @param y
 * @param w
 */
function weightedLinearRegression(x, y, w) {
    let sxtw = 0;
    let swx = 0;
    let sw = 0;
    let sxtwy = 0;
    let swy = 0;
    for (let i = 0; i < x.length; i++) {
        sxtw += x[i] * x[i] * w[i];
        swx += x[i] * w[i];
        sw += w[i];
        sxtwy += x[i] * w[i] * y[i];
        swy += w[i] * y[i];
    }
    /* Just to know what is the matrix system that we solve
     let Mx=[[sxtw, swx], [swx, sw]];
     let My=[[sxtwy], [swy]];
    */
    //Mx inverse
    let detMx = sxtw * sw - swx * swx;
    let inMx = [
        [sw / detMx, -swx / detMx],
        [-swx / detMx, sxtw / detMx],
    ];
    return [
        inMx[0][0] * sxtwy + inMx[0][1] * swy,
        inMx[1][0] * sxtwy + inMx[1][1] * swy,
    ];
}
const toRadians = (degree) => (degree * Math.PI) / 180;
const getNegArea = (data) => {
    let area = 0;
    for (let element of data) {
        if (element < 0)
            area -= element;
    }
    return area;
};

},{"../x/xNoiseSanPlot":279,"./reimAbsolute":230,"./reimPhaseCorrection":233}],232:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimFFT = void 0;
const fft_js_1 = __importDefault(require("fft.js"));
const xRotate_1 = require("../x/xRotate");
/**
 * ReimFFT.
 *
 * @param data - complex spectrum
 * @param options - options.
 * @returns FFT of complex spectrum.
 */
function reimFFT(data, options = {}) {
    const { inverse = false, applyZeroShift = false } = options;
    let { re, im } = data;
    const size = re.length;
    const csize = size << 1;
    let complexArray = new Float64Array(csize);
    for (let i = 0; i < csize; i += 2) {
        complexArray[i] = re[i >>> 1];
        complexArray[i + 1] = im[i >>> 1];
    }
    let fft = new fft_js_1.default(size);
    let output = new Float64Array(csize);
    if (inverse) {
        if (applyZeroShift)
            complexArray = zeroShift(complexArray, true);
        fft.inverseTransform(output, complexArray);
    }
    else {
        fft.transform(output, complexArray);
        if (applyZeroShift)
            output = zeroShift(output);
    }
    let newRe = new Float64Array(size);
    let newIm = new Float64Array(size);
    for (let i = 0; i < csize; i += 2) {
        newRe[i >>> 1] = output[i];
        newIm[i >>> 1] = output[i + 1];
    }
    return { re: newRe, im: newIm };
}
exports.reimFFT = reimFFT;
const zeroShift = (data, inverse) => {
    let middle = inverse
        ? Math.ceil(data.length / 2)
        : Math.floor(data.length / 2);
    return (0, xRotate_1.xRotate)(data, middle);
};

},{"../x/xRotate":291,"fft.js":8}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimPhaseCorrection = void 0;
/**
 * Phase correction filter
 *
 * @param data - complex spectrum
 * @param phi0 - Angle in radians for zero order phase correction
 * @param phi1 - Angle in radians for first order phase correction
 * @returns - returns a new object {re:[], im:[]}
 */
function reimPhaseCorrection(data, phi0 = 0, phi1 = 0) {
    phi0 = Number.isFinite(phi0) ? phi0 : 0;
    phi1 = Number.isFinite(phi1) ? phi1 : 0;
    const re = data.re;
    const im = data.im;
    const length = data.re.length;
    const delta = phi1 / length;
    const alpha = 2 * Math.pow(Math.sin(delta / 2), 2);
    const beta = Math.sin(delta);
    let cosTheta = Math.cos(phi0);
    let sinTheta = Math.sin(phi0);
    const newRe = new Float64Array(length);
    const newIm = new Float64Array(length);
    for (let i = 0; i < length; i++) {
        newRe[i] = re[i] * cosTheta - im[i] * sinTheta;
        newIm[i] = re[i] * sinTheta + im[i] * cosTheta;
        // calculate angles i+1 from i
        let newCosTheta = cosTheta - (alpha * cosTheta + beta * sinTheta);
        let newSinTheta = sinTheta - (alpha * sinTheta - beta * cosTheta);
        cosTheta = newCosTheta;
        sinTheta = newSinTheta;
    }
    return { re: newRe, im: newIm };
}
exports.reimPhaseCorrection = reimPhaseCorrection;

},{}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFromToArray = void 0;
/**
 * Create an array with numbers between "from" and "to" of length "length"
 *
 * @param options - options
 * @return - array of distributed numbers between "from" and "to"
 */
function createFromToArray(options = {}) {
    let { from = 0, to = 1, length = 1000, includeFrom = true, includeTo = true, distribution = 'uniform', } = options;
    const array = new Float64Array(length);
    let div = length;
    if (includeFrom && includeTo) {
        div = length - 1;
    }
    else if ((!includeFrom && includeTo) || (includeFrom && !includeTo)) {
        div = length;
    }
    else if (!includeFrom && !includeTo) {
        div = length + 1;
    }
    let delta = (to - from) / div;
    if (distribution === 'uniform') {
        if (includeFrom) {
            let index = 0;
            while (index < length) {
                array[index] = from + delta * index;
                index++;
            }
        }
        else {
            let index = 0;
            while (index < length) {
                array[index] = from + delta * (index + 1);
                index++;
            }
        }
    }
    else if (distribution === 'log') {
        let base = (to / from) ** (1 / div);
        let firstExponent = Math.log(from) / Math.log(base);
        if (includeFrom) {
            let index = 0;
            while (index < length) {
                array[index] = base ** (firstExponent + index);
                index++;
            }
        }
        else {
            let index = 0;
            while (index < length) {
                array[index] = base ** (firstExponent + index + 1);
                index++;
            }
        }
    }
    else {
        throw new Error('Please choose for the distribution either uniform or log. By default the distribution chosen is uniform.');
    }
    return array;
}
exports.createFromToArray = createFromToArray;

},{}],238:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRandomArray = void 0;
const ml_xsadd_1 = __importDefault(require("ml-xsadd"));
/**
 * Create a random array of numbers of a specific length
 *
 * @return - array of random floats normally distributed
 */
let spare;
let hasSpare = false;
function createRandomArray(options = {}) {
    const { mean = 0, standardDeviation = 1, length = 1000, range = 1, seed, distribution = 'normal', } = options;
    const generator = new ml_xsadd_1.default(seed);
    let returnArray = new Float64Array(length);
    switch (distribution) {
        case 'normal':
            for (let i = 0; i < length; i++) {
                returnArray[i] = generateGaussian(mean, standardDeviation, generator);
            }
            break;
        case 'uniform':
            for (let i = 0; i < length; i++) {
                returnArray[i] = (generator.random() - 0.5) * range + mean;
            }
            break;
        default:
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`unknown distribution: ${distribution}`);
    }
    return returnArray;
}
exports.createRandomArray = createRandomArray;
function generateGaussian(mean, standardDeviation, generator) {
    let val, u, v, s;
    if (hasSpare) {
        hasSpare = false;
        val = spare * standardDeviation + mean;
    }
    else {
        do {
            u = generator.random() * 2 - 1;
            v = generator.random() * 2 - 1;
            s = u * u + v * v;
        } while (s >= 1 || s === 0);
        s = Math.sqrt((-2 * Math.log(s)) / s);
        spare = v * s;
        hasSpare = true;
        val = mean + standardDeviation * u * s;
    }
    return val;
}

},{"ml-xsadd":365}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStepArray = void 0;
/**
 * Create an array with numbers starting from "from" with step "step" of length "length"
 *
 * @param options - options
 * @return - array of distributed numbers with step "step" from "from"
 */
function createStepArray(options = {}) {
    let { from = 0, step = 1, length = 1000 } = options;
    const array = new Float64Array(length);
    let index = 0;
    while (index < length) {
        array[index] = from + step * index;
        index++;
    }
    return array;
}
exports.createStepArray = createStepArray;

},{}],240:[function(require,module,exports){
"use strict";
/* eslint-disable @typescript-eslint/no-loss-of-precision */
/*
Adapted from: https://github.com/compute-io/erfcinv/blob/aa116e23883839359e310ad41a7c42f72815fc1e/lib/number.js

The MIT License (MIT)

Copyright (c) 2014-2015 The Compute.io Authors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:

The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", { value: true });
// Coefficients for erfcinv on [0, 0.5]:
const Y1 = 8.91314744949340820313e-2;
const P1 = [
    -5.38772965071242932965e-3, 8.22687874676915743155e-3,
    2.19878681111168899165e-2, -3.65637971411762664006e-2,
    -1.26926147662974029034e-2, 3.34806625409744615033e-2,
    -8.36874819741736770379e-3, -5.08781949658280665617e-4,
];
const Q1 = [
    8.86216390456424707504e-4, -2.33393759374190016776e-3,
    7.95283687341571680018e-2, -5.27396382340099713954e-2,
    -7.1228902341542847553e-1, 6.62328840472002992063e-1, 1.56221558398423026363,
    -1.56574558234175846809, -9.70005043303290640362e-1, 1,
];
// Coefficients for erfcinv for 0.5 > 1-x >= 0:
const Y2 = 2.249481201171875;
const P2 = [
    -3.67192254707729348546, 2.11294655448340526258e1, 1.7445385985570866523e1,
    -4.46382324441786960818e1, -1.88510648058714251895e1,
    1.76447298408374015486e1, 8.37050328343119927838, 1.05264680699391713268e-1,
    -2.02433508355938759655e-1,
];
const Q2 = [
    1.72114765761200282724, -2.26436933413139721736e1, 1.08268667355460159008e1,
    4.85609213108739935468e1, -2.01432634680485188801e1,
    -2.86608180499800029974e1, 3.9713437953343869095, 6.24264124854247537712, 1,
];
// Coefficients for erfcinv for sqrt( -log(1-x)):
const Y3 = 8.07220458984375e-1;
const P3 = [
    -6.81149956853776992068e-10, 2.85225331782217055858e-8,
    -6.79465575181126350155e-7, 2.14558995388805277169e-3,
    2.90157910005329060432e-2, 1.42869534408157156766e-1,
    3.37785538912035898924e-1, 3.87079738972604337464e-1,
    1.17030156341995252019e-1, -1.63794047193317060787e-1,
    -1.31102781679951906451e-1,
];
const Q3 = [
    1.105924229346489121e-2, 1.52264338295331783612e-1, 8.48854343457902036425e-1,
    2.59301921623620271374, 4.77846592945843778382, 5.38168345707006855425,
    3.46625407242567245975, 1,
];
const Y4 = 9.3995571136474609375e-1;
const P4 = [
    2.66339227425782031962e-12, -2.30404776911882601748e-10,
    4.60469890584317994083e-6, 1.57544617424960554631e-4,
    1.87123492819559223345e-3, 9.50804701325919603619e-3,
    1.85573306514231072324e-2, -2.22426529213447927281e-3,
    -3.50353787183177984712e-2,
];
const Q4 = [
    7.64675292302794483503e-5, 2.63861676657015992959e-3,
    3.41589143670947727934e-2, 2.20091105764131249824e-1,
    7.62059164553623404043e-1, 1.3653349817554063097, 1,
];
const Y5 = 9.8362827301025390625e-1;
const P5 = [
    9.9055709973310326855e-17, -2.81128735628831791805e-14,
    4.62596163522878599135e-9, 4.49696789927706453732e-7,
    1.49624783758342370182e-5, 2.09386317487588078668e-4,
    1.05628862152492910091e-3, -1.12951438745580278863e-3,
    -1.67431005076633737133e-2,
];
const Q5 = [
    2.82243172016108031869e-7, 2.75335474764726041141e-5,
    9.64011807005165528527e-4, 1.60746087093676504695e-2,
    1.38151865749083321638e-1, 5.91429344886417493481e-1, 1,
];
/**
 * Polyval.
 *
 * @param c - Array of Number.
 * @param x - Number.
 * @returns Number.
 */
function polyval(c, x) {
    let p = 0;
    for (const coef of c) {
        p = p * x + coef;
    }
    return p;
}
/**
 * Calculates a rational approximation.
 *
 * @private
 * @param x - Number.
 * @param v - Number.
 * @param P - Array of polynomial coefficients.
 * @param Q - Array of polynomial coefficients.
 * @param Y - Number.
 * @returns Rational approximation.
 */
function calc(x, v, P, Q, Y) {
    const s = x - v;
    const r = polyval(P, s) / polyval(Q, s);
    return Y * x + r * x;
}
/**
 * Evaluates the complementary inverse error function for an input value.
 *
 * @private
 * @param x - Input value.
 * @returns Evaluated complementary inverse error function.
 */
function erfcinv(x) {
    let sign = false;
    let val;
    let q;
    let g;
    let r;
    // [1] Special cases...
    // NaN:
    if (Number.isNaN(x)) {
        return Number.NaN;
    }
    // x not on the interval: [0,2]
    if (x < 0 || x > 2) {
        throw new RangeError(`erfcinv()::invalid input argument. Value must be on the interval [0,2]. Value: \`${x}\`.`);
    }
    if (x === 0) {
        return Number.POSITIVE_INFINITY;
    }
    if (x === 2) {
        return Number.NEGATIVE_INFINITY;
    }
    if (x === 1) {
        return 0;
    }
    // [2] Get the sign and make use of `erfc` reflection formula: `erfc(-z)=2 - erfc(z)`...
    if (x > 1) {
        q = 2 - x;
        x = 1 - q;
        sign = true;
    }
    else {
        q = x;
        x = 1 - x;
    }
    // [3] |x| <= 0.5
    if (x <= 0.5) {
        g = x * (x + 10);
        r = polyval(P1, x) / polyval(Q1, x);
        val = g * Y1 + g * r;
        return sign ? -val : val;
    }
    // [4] 1-|x| >= 0.25
    if (q >= 0.25) {
        g = Math.sqrt(-2 * Math.log(q));
        q = q - 0.25;
        r = polyval(P2, q) / polyval(Q2, q);
        val = g / (Y2 + r);
        return sign ? -val : val;
    }
    q = Math.sqrt(-Math.log(q));
    // [5] q < 3
    if (q < 3) {
        return calc(q, 1.125, P3, Q3, Y3);
    }
    // [6] q < 6
    if (q < 6) {
        return calc(q, 3, P4, Q4, Y4);
    }
    // Note that the smallest number in JavaScript is 5e-324. Math.sqrt( -Math.log( 5e-324 ) ) ~27.2844
    return calc(q, 6, P5, Q5, Y5);
    // Note that in the boost library, they are able to go to much smaller values, as 128 bit long doubles support ~1e-5000; something which JavaScript does not natively support.
}
exports.default = erfcinv;

},{}],241:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RayleighCdf.
 *
 * @param x - data
 * @param sigma - standard deviation
 * @returns - rayleigh cdf
 */
function rayleighCdf(x, sigma = 1) {
    if (x < 0) {
        return 0;
    }
    return -Math.expm1(-Math.pow(x, 2) / (2 * Math.pow(sigma, 2)));
}
exports.default = rayleighCdf;

},{}],242:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutputArray = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * This function
 * @param output - undefined or a new array
 * @param length - length of the output array
 * @returns
 */
function getOutputArray(output, length) {
    if (output !== undefined) {
        if (!(0, is_any_array_1.isAnyArray)(output)) {
            throw new TypeError('output option must be an array if specified');
        }
        if (output.length !== length) {
            throw new TypeError('the output array does not have the correct length');
        }
        return output;
    }
    else {
        return new Float64Array(length);
    }
}
exports.getOutputArray = getOutputArray;

},{"is-any-array":13}],243:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xAbsolute = void 0;
/**
 * This function returns an array with absolute values
 *
 * @param array - array of data
 * @returns - array with absolute values
 */
function xAbsolute(array) {
    let tmpArray = array.slice();
    for (let i = 0; i < tmpArray.length; i++) {
        if (tmpArray[i] < 0)
            tmpArray[i] *= -1;
    }
    return tmpArray;
}
exports.xAbsolute = xAbsolute;

},{}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xAbsoluteMedian = void 0;
const xAbsolute_1 = require("./xAbsolute");
const xMedian_1 = require("./xMedian");
/**
 * This function calculates the median after taking the reimAbsolute values of the points
 *
 * @param array - the array for which we want to calculate the absolute value
 * @returns - median
 */
function xAbsoluteMedian(array) {
    return (0, xMedian_1.xMedian)((0, xAbsolute_1.xAbsolute)(array));
}
exports.xAbsoluteMedian = xAbsoluteMedian;

},{"./xAbsolute":243,"./xMedian":271}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xAdd = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * This function xAdd the first array by the second array or a constant value to each element of the first array
 *
 * @param array1 - the first array
 * @param array2 - the second array or number
 */
function xAdd(array1, array2) {
    let isConstant = false;
    let constant = 0;
    if ((0, is_any_array_1.isAnyArray)(array2)) {
        if (array1.length !== array2.length) {
            throw new Error('xAdd: size of array1 and array2 must be identical');
        }
    }
    else {
        isConstant = true;
        constant = array2;
    }
    let array3 = new Float64Array(array1.length);
    if (isConstant) {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] + constant;
        }
    }
    else {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] + array2[i];
        }
    }
    return array3;
}
exports.xAdd = xAdd;

},{"is-any-array":13}],246:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xApplyFunctionStr = void 0;
/**
 * Will apply a function on each element of the array described as a string
 * By default we will use as variable 'x'
 * In front of sequence of lowercase we will add 'Math.'. This allows to write
 * `sin(x) + cos(x)` and it will be replace internally by (x) => (Math.sin(x) + Math.cos(x))
 * @param array
 * @param options
 * @returns
 */
function xApplyFunctionStr(array, options = {}) {
    const { variableLabel = 'x', fctString = variableLabel } = options;
    const fct = new Function(variableLabel, `return Number(${fctString
        .replace(/(?<before>^|\W)(?<after>[\da-z]{2,}\()/g, '$<before>Math.$<after>')
        .replace(/Math\.Math/g, 'Math')})`);
    const toReturn = Float64Array.from(array);
    for (let i = 0; i < array.length; i++) {
        toReturn[i] = fct(array[i]);
        if (Number.isNaN(toReturn[i])) {
            throw new Error(`The callback ${fctString} does not return a number: ${array[i]}`);
        }
    }
    return toReturn;
}
exports.xApplyFunctionStr = xApplyFunctionStr;

},{}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xAutoCorrelation = void 0;
const xCrossCorrelation_1 = require("./xCrossCorrelation");
/**
 * Calculates the auto-correlation of an array
 *
 * @param A - the array for which to calculate the auto-correlation
 * @param options - Options
 */
function xAutoCorrelation(A, options = {}) {
    return (0, xCrossCorrelation_1.xCrossCorrelation)(A, A, options);
}
exports.xAutoCorrelation = xAutoCorrelation;

},{"./xCrossCorrelation":252}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xBoxPlot = void 0;
/**
 * Calculating the box plot of the array
 *
 * @param array - data
 */
function xBoxPlot(array) {
    array = Float64Array.from(array).sort();
    if (array.length < 5) {
        throw new Error('xBoxPlot: can not calculate info if array contains less than 5 elements');
    }
    let info = {
        q1: 0,
        median: 0,
        q3: 0,
        min: array[0],
        max: array[array.length - 1],
    };
    let q1max, q3min;
    if (array.length % 2 === 1) {
        // odd
        let middle = (array.length - 1) / 2;
        info.median = array[middle];
        q1max = middle - 1;
        q3min = middle + 1;
    }
    else {
        // even
        q3min = array.length / 2;
        q1max = q3min - 1;
        info.median = (array[q1max] + array[q3min]) / 2;
    }
    if (q1max % 2 === 0) {
        info.q1 = array[q1max / 2];
        info.q3 = array[(array.length + q3min - 1) / 2];
    }
    else {
        info.q1 = (array[(q1max + 1) / 2] + array[(q1max - 1) / 2]) / 2;
        let middleOver = (array.length + q3min) / 2;
        info.q3 = (array[middleOver] + array[middleOver - 1]) / 2;
    }
    return info;
}
exports.xBoxPlot = xBoxPlot;

},{}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCheck = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * Checks if input is of type array
 *
 * @param input - input
 */
function xCheck(input, options = {}) {
    const { minLength } = options;
    if (!(0, is_any_array_1.isAnyArray)(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    //@ts-expect-error we already checked that input is an array
    if (minLength && input.length < minLength) {
        throw new Error(`input must have a length of at least ${minLength}`);
    }
}
exports.xCheck = xCheck;

},{"is-any-array":13}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCheckLengths = void 0;
/**
 * XCheckLengths.
 *
 * @param array1 - First array.
 * @param array2 - Second array.
 */
function xCheckLengths(array1, array2) {
    if (array1.length !== array2.length) {
        throw new TypeError('Length of array1 and array2 must be identical');
    }
}
exports.xCheckLengths = xCheckLengths;

},{}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCorrelation = void 0;
/**
 * Calculates the correlation between 2 vectors
 * https://en.wikipedia.org/wiki/Correlation_and_dependence
 *
 * @param A - first array
 * @param B - sencond array
 */
function xCorrelation(A, B) {
    let n = A.length;
    let sumA = 0;
    let sumA2 = 0;
    let sumB = 0;
    let sumB2 = 0;
    let sumAB = 0;
    for (let i = 0; i < n; i++) {
        let a = A[i];
        let b = B[i];
        sumA += a;
        sumA2 += a ** 2;
        sumB += b;
        sumB2 += b ** 2;
        sumAB += a * b;
    }
    return ((n * sumAB - sumA * sumB) /
        (Math.sqrt(n * sumA2 - sumA ** 2) * Math.sqrt(n * sumB2 - sumB ** 2)));
}
exports.xCorrelation = xCorrelation;

},{}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCrossCorrelation = void 0;
const xDotProduct_1 = require("./xDotProduct");
/**
 * Calculates the cross-correlation between 2 arrays
 *
 * @param A - fixed array
 * @param B - sweeping array
 * @param options - Options
 */
function xCrossCorrelation(A, B, options = {}) {
    let { tau = 1, lag = A.length - 1 } = options;
    let result = new Float64Array(1 + (2 * lag) / tau);
    if (A.length === B.length) {
        let n = B.length;
        let g = new Float64Array(2 * n);
        let q = new Float64Array(2 * n);
        for (let i = 0; i < n; i++) {
            q[n + i] = B[i];
        }
        for (let i = n * 2 - (tau - 1); i > 0; i -= tau) {
            let k = 0;
            for (let j = i; j < n * 2; j++) {
                g[k] = q[j];
                k++;
            }
            let w = [];
            for (let l = 0; l < n; l++) {
                w[l] = g[l];
            }
            result[(k - (n - lag)) / tau] = (0, xDotProduct_1.xDotProduct)(A, w);
        }
    }
    return result;
}
exports.xCrossCorrelation = xCrossCorrelation;

},{"./xDotProduct":255}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCumulative = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * Calculate an array of the same size that is the cumulative values
 *
 * @param array - initial array
 */
function xCumulative(array) {
    if (!(0, is_any_array_1.isAnyArray)(array)) {
        throw new TypeError('input must be an array');
    }
    let newArray = new Float64Array(array.length);
    if (array.length === 0)
        return newArray;
    newArray[0] = array[0];
    for (let i = 1; i < array.length; i++) {
        newArray[i] = newArray[i - 1] + array[i];
    }
    return newArray;
}
exports.xCumulative = xCumulative;

},{"is-any-array":13}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xDivide = void 0;
const is_any_array_1 = require("is-any-array");
const __1 = require("..");
/**
 * This function divide the first array by the second array or a constant value to each element of the first array
 *
 * @param array1 - first array
 * @param array2 - second array or number
 * @param options - options
 */
function xDivide(array1, array2, options = {}) {
    let isConstant = false;
    let constant = 0;
    if ((0, is_any_array_1.isAnyArray)(array2)) {
        if (array1.length !== array2.length) {
            throw new Error('xDivide: size of array1 and array2 must be identical');
        }
    }
    else {
        isConstant = true;
        constant = Number(array2);
    }
    let array3 = (0, __1.getOutputArray)(options.output, array1.length);
    if (isConstant) {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] / constant;
        }
    }
    else {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] / array2[i];
        }
    }
    return array3;
}
exports.xDivide = xDivide;

},{"..":208,"is-any-array":13}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xDotProduct = void 0;
const xMultiply_1 = require("./xMultiply");
/**
 * Dot product between two arrays
 *
 * @param A - First array.
 * @param B - Second array.
 */
function xDotProduct(A, B) {
    let g = (0, xMultiply_1.xMultiply)(A, B);
    let result = 0;
    for (let i = 0; i < A.length; i++) {
        result += g[i];
    }
    return result;
}
exports.xDotProduct = xDotProduct;

},{"./xMultiply":278}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xEnsureFloat64 = void 0;
const xCheck_1 = require("./xCheck");
/**
 * Returns a copy of the data as Float64
 *
 * @param array - array of numbers
 */
function xEnsureFloat64(array) {
    (0, xCheck_1.xCheck)(array);
    if (array instanceof Float64Array) {
        return array.slice(0);
    }
    return Float64Array.from(array);
}
exports.xEnsureFloat64 = xEnsureFloat64;

},{"./xCheck":249}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xFindClosestIndex = void 0;
/**
 * Returns the closest index of a `target`
 *
 * @param array - array of numbers
 * @param target - target
 * @returns - closest index
 */
function xFindClosestIndex(array, target, options = {}) {
    const { sorted = true } = options;
    if (sorted) {
        let low = 0;
        let high = array.length - 1;
        let middle = 0;
        while (high - low > 1) {
            middle = low + ((high - low) >> 1);
            if (array[middle] < target) {
                low = middle;
            }
            else if (array[middle] > target) {
                high = middle;
            }
            else {
                return middle;
            }
        }
        if (low < array.length - 1) {
            if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {
                return low;
            }
            else {
                return low + 1;
            }
        }
        else {
            return low;
        }
    }
    else {
        let index = 0;
        let diff = Number.POSITIVE_INFINITY;
        for (let i = 0; i < array.length; i++) {
            const currentDiff = Math.abs(array[i] - target);
            if (currentDiff < diff) {
                diff = currentDiff;
                index = i;
            }
        }
        return index;
    }
}
exports.xFindClosestIndex = xFindClosestIndex;

},{}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xGetFromToIndex = void 0;
const xFindClosestIndex_1 = require("./xFindClosestIndex");
/**
 * Returns an object with {fromIndex, toIndex} for a specific from / to
 *
 * @param x - array of numbers
 * @param options - Options
 */
function xGetFromToIndex(x, options = {}) {
    let { fromIndex, toIndex, from, to } = options;
    if (fromIndex === undefined) {
        if (from !== undefined) {
            fromIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, from);
        }
        else {
            fromIndex = 0;
        }
    }
    if (toIndex === undefined) {
        if (to !== undefined) {
            toIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, to);
        }
        else {
            toIndex = x.length - 1;
        }
    }
    if (fromIndex < 0)
        fromIndex = 0;
    if (toIndex < 0)
        toIndex = 0;
    if (fromIndex >= x.length)
        fromIndex = x.length - 1;
    if (toIndex >= x.length)
        toIndex = x.length - 1;
    if (fromIndex > toIndex)
        [fromIndex, toIndex] = [toIndex, fromIndex];
    return { fromIndex, toIndex };
}
exports.xGetFromToIndex = xGetFromToIndex;

},{"./xFindClosestIndex":257}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xGetTargetIndex = void 0;
const xFindClosestIndex_1 = require("./xFindClosestIndex");
/**
 *  Returns the targetIndex
 *
 * @param x - array of numbers
 * @param options - options
 */
function xGetTargetIndex(x, options = {}) {
    let { target, targetIndex } = options;
    if (targetIndex === undefined) {
        if (target !== undefined) {
            return (0, xFindClosestIndex_1.xFindClosestIndex)(x, target);
        }
        else {
            return 0;
        }
    }
    return targetIndex;
}
exports.xGetTargetIndex = xGetTargetIndex;

},{"./xFindClosestIndex":257}],260:[function(require,module,exports){
"use strict";
/**
 * Performs the Hilbert transform
 * @returns A new vector with 90 degree shift regarding the phase of the original function
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.xHilbertTransform = void 0;
function xHilbertTransform(input, options = {}) {
    const { inClockwise = true } = options;
    const array = [0, ...input, 0];
    const result = new Float64Array(input.length);
    for (let k = 1; k < array.length - 1; k++) {
        let aSum = 0;
        for (let i = 0; i < k - 1; i++) {
            const log = Math.log((k - i) / (k - i - 1));
            aSum += array[i] * log + (array[i + 1] - array[i]) * (-1 + (k - i) * log);
        }
        const b = array[k - 1] - array[k + 1];
        let cSum = 0;
        for (let i = k + 1; i < array.length - 1; i++) {
            const log = Math.log((i - k) / (i - k + 1));
            cSum += array[i] * log + (array[i - 1] - array[i]) * (1 + (i - k) * log);
        }
        result[k - 1] = ((inClockwise ? 1 : -1) * (aSum + b + cSum)) / Math.PI;
    }
    return result;
}
exports.xHilbertTransform = xHilbertTransform;

},{}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xHistogram = void 0;
const createFromToArray_1 = require("../utils/createFromToArray");
const xAbsolute_1 = require("./xAbsolute");
const xCheck_1 = require("./xCheck");
const xMaxValue_1 = require("./xMaxValue");
const xMinValue_1 = require("./xMinValue");
/**
 * Calculates a histogram of defined number of slots
 *
 * @param array - Array containing values
 * @param options - options
 * @returns - result of the histogram
 */
function xHistogram(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    let histogram = options.histogram;
    const { centerX = true, nbSlots = histogram === undefined ? 256 : histogram.x.length, logBaseX, logBaseY, absolute = false, } = options;
    if (absolute) {
        array = (0, xAbsolute_1.xAbsolute)(array);
    }
    if (logBaseX) {
        array = array.slice();
        const logOfBase = Math.log10(logBaseX);
        for (let i = 0; i < array.length; i++) {
            array[i] = Math.log10(array[i]) / logOfBase;
        }
    }
    const { min = (0, xMinValue_1.xMinValue)(array), max = (0, xMaxValue_1.xMaxValue)(array) } = options;
    const slotSize = (max - min) / (nbSlots + Number.EPSILON);
    const y = histogram === undefined ? new Float64Array(nbSlots) : histogram.y;
    const x = histogram === undefined
        ? Array.from((0, createFromToArray_1.createFromToArray)({
            from: min + (centerX ? slotSize / 2 : 0),
            to: max - (centerX ? slotSize / 2 : 0),
            length: nbSlots,
        }))
        : histogram.x;
    for (const element of array) {
        const index = Math.max(Math.min(Math.floor((element - min - Number.EPSILON) / slotSize), nbSlots - 1), 0);
        y[index]++;
    }
    if (logBaseY) {
        const logOfBase = Math.log10(logBaseY);
        for (let i = 0; i < y.length; i++) {
            y[i] = Math.log10(y[i] + 1) / logOfBase;
        }
    }
    return { x, y };
}
exports.xHistogram = xHistogram;

},{"../utils/createFromToArray":237,"./xAbsolute":243,"./xCheck":249,"./xMaxValue":266,"./xMinValue":276}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xIsEquallySpaced = void 0;
/**
 * Check if the values are separated always by the same difference
 *
 * @param array - Monotone growing array of number
 */
function xIsEquallySpaced(array, options = {}) {
    if (array.length < 3)
        return true;
    const { tolerance = 0.05 } = options;
    let maxDx = 0;
    let minDx = Number.MAX_SAFE_INTEGER;
    for (let i = 0; i < array.length - 1; ++i) {
        let absoluteDifference = array[i + 1] - array[i];
        if (absoluteDifference < minDx) {
            minDx = absoluteDifference;
        }
        if (absoluteDifference > maxDx) {
            maxDx = absoluteDifference;
        }
    }
    return (maxDx - minDx) / maxDx < tolerance;
}
exports.xIsEquallySpaced = xIsEquallySpaced;

},{}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xIsMonotonic = void 0;
/**
 * Returns true if x is monotone
 *
 * @param array - array of numbers
 */
function xIsMonotonic(array) {
    if (array.length <= 2) {
        return 1;
    }
    if (array[0] === array[1]) {
        // maybe a constant series
        for (let i = 1; i < array.length - 1; i++) {
            if (array[i] !== array[i + 1])
                return 0;
        }
        return 1;
    }
    if (array[0] < array[array.length - 1]) {
        for (let i = 0; i < array.length - 1; i++) {
            if (array[i] >= array[i + 1])
                return 0;
        }
        return 1;
    }
    else {
        for (let i = 0; i < array.length - 1; i++) {
            if (array[i] <= array[i + 1])
                return 0;
        }
        return -1;
    }
}
exports.xIsMonotonic = xIsMonotonic;

},{}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMaxAbsoluteValue = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the maximal value of an array of values
 *
 * @param array - array of numbers
 * @param options - options
 */
function xMaxAbsoluteValue(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let maxValue = array[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        if (array[i] >= 0) {
            if (array[i] > maxValue) {
                maxValue = array[i];
            }
        }
        else if (-array[i] > maxValue) {
            maxValue = -array[i];
        }
    }
    return maxValue;
}
exports.xMaxAbsoluteValue = xMaxAbsoluteValue;

},{"./xCheck":249,"./xGetFromToIndex":258}],265:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMaxIndex = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the index of the maximum of the given values
 *
 * @param array - array of numbers
 * @param  options - options
 * @returns - index
 */
function xMaxIndex(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let maxIndex = fromIndex;
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        if (array[i] > array[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}
exports.xMaxIndex = xMaxIndex;

},{"./xCheck":249,"./xGetFromToIndex":258}],266:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMaxValue = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the maximal value of an array of values
 *
 * @param array - array of numbers
 * @param options - options
 */
function xMaxValue(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let maxValue = array[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        if (array[i] > maxValue) {
            maxValue = array[i];
        }
    }
    return maxValue;
}
exports.xMaxValue = xMaxValue;

},{"./xCheck":249,"./xGetFromToIndex":258}],267:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMean = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the mean value of an array of values
 *
 * @param array - array of numbers
 * @param options - options
 */
function xMean(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let sumValue = array[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        sumValue += array[i];
    }
    return sumValue / (toIndex - fromIndex + 1);
}
exports.xMean = xMean;

},{"./xCheck":249,"./xGetFromToIndex":258}],268:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMeanAbsoluteError = void 0;
const xCheckLengths_1 = require("./xCheckLengths");
/**
 * This function calculates the mean absolute error
 *
 * @param array1 - first array
 * @param array2 - second array
 */
function xMeanAbsoluteError(array1, array2) {
    (0, xCheckLengths_1.xCheckLengths)(array1, array2);
    let sum = 0;
    for (let i = 0; i < array1.length; i++) {
        sum += Math.abs(array1[i] - array2[i]);
    }
    return sum / array1.length;
}
exports.xMeanAbsoluteError = xMeanAbsoluteError;

},{"./xCheckLengths":250}],269:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMeanSquaredError = void 0;
const xCheckLengths_1 = require("./xCheckLengths");
/**
 * This function calculates the mean squared error
 *
 * @param array1 -first array
 * @param array2 - second array
 */
function xMeanSquaredError(array1, array2) {
    (0, xCheckLengths_1.xCheckLengths)(array1, array2);
    let sum = 0;
    for (let i = 0; i < array1.length; i++) {
        sum += Math.pow(array1[i] - array2[i], 2);
    }
    return sum / array1.length;
}
exports.xMeanSquaredError = xMeanSquaredError;

},{"./xCheckLengths":250}],270:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMeanWeighted = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the weighted mean value of an array of values
 *
 * @param array - array of numbers
 * @param weights - array of weights
 * @param options - options
 */
function xMeanWeighted(array, weights, options = {}) {
    (0, xCheck_1.xCheck)(array, { minLength: 1 });
    (0, xCheck_1.xCheck)(weights);
    if (array.length !== weights.length) {
        throw new Error('array and weights must have the same length');
    }
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    // normalize weights
    let sumWeights = 0;
    let sumValue = array[fromIndex] * weights[fromIndex];
    sumWeights += weights[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        sumValue += array[i] * weights[i];
        sumWeights += weights[i];
    }
    if (sumWeights === 0) {
        // We throw because the case is not well defined
        throw new Error('sum of weights must be > 0');
    }
    return sumValue / sumWeights;
}
exports.xMeanWeighted = xMeanWeighted;

},{"./xCheck":249,"./xGetFromToIndex":258}],271:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMedian = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * Calculates the median of an array
 *
 * @param input - Array containing values
 * @returns - median
 */
function xMedian(input) {
    if (!(0, is_any_array_1.isAnyArray)(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    const array = input.slice();
    let low = 0;
    let high = array.length - 1;
    let middle = 0;
    let currentLow = 0;
    let currentHigh = 0;
    let median = calcMiddle(low, high);
    while (true) {
        if (high <= low) {
            return array[median];
        }
        if (high === low + 1) {
            if (array[low] > array[high]) {
                swap(array, low, high);
            }
            return array[median];
        }
        // Find median of low, middle and high items; swap into position low
        middle = calcMiddle(low, high);
        if (array[middle] > array[high])
            swap(array, middle, high);
        if (array[low] > array[high])
            swap(array, low, high);
        if (array[middle] > array[low])
            swap(array, middle, low);
        // Swap low item (now in position middle) into position (low+1)
        swap(array, middle, low + 1);
        // Nibble from each end towards middle, swapping items when stuck
        currentLow = low + 1;
        currentHigh = high;
        while (true) {
            do
                currentLow++;
            while (array[low] > array[currentLow]);
            do
                currentHigh--;
            while (array[currentHigh] > array[low]);
            if (currentHigh < currentLow) {
                break;
            }
            swap(array, currentLow, currentHigh);
        }
        // Swap middle item (in position low) back into correct position
        swap(array, low, currentHigh);
        // Re-set active partition
        if (currentHigh <= median) {
            low = currentLow;
        }
        if (currentHigh >= median) {
            high = currentHigh - 1;
        }
    }
}
exports.xMedian = xMedian;
function swap(array, i, j) {
    const temp = array[j];
    array[j] = array[i];
    array[i] = temp;
}
function calcMiddle(i, j) {
    return Math.floor((i + j) / 2);
}

},{"is-any-array":13}],272:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMedianAbsoluteDeviation = void 0;
const xMedian_1 = require("./xMedian");
/**
 * This function calculates the median absolute deviation (MAD)
 * https://en.wikipedia.org/wiki/Median_absolute_deviation
 * @param array
 */
function xMedianAbsoluteDeviation(array) {
    const median = (0, xMedian_1.xMedian)(array);
    const averageDeviations = new Float64Array(array.length);
    for (let i = 0; i < array.length; i++) {
        averageDeviations[i] = Math.abs(array[i] - median);
    }
    return {
        median,
        mad: (0, xMedian_1.xMedian)(averageDeviations),
    };
}
exports.xMedianAbsoluteDeviation = xMedianAbsoluteDeviation;

},{"./xMedian":271}],273:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMinIndex = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the index of the minimum of the given values
 *
 * @param array - array of numbers
 * @param options - options
 * @returns - index
 */
function xMinIndex(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let minIndex = fromIndex;
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        if (array[i] < array[minIndex]) {
            minIndex = i;
        }
    }
    return minIndex;
}
exports.xMinIndex = xMinIndex;

},{"./xCheck":249,"./xGetFromToIndex":258}],274:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMinMaxDelta = void 0;
const xCheck_1 = require("./xCheck");
/**
 * Return min and max values of an array
 *
 * @param array - array of number
 * @returns - Object with 2 properties, min and max
 */
function xMinMaxDelta(array) {
    (0, xCheck_1.xCheck)(array, {
        minLength: 2,
    });
    let minDelta = array[1] - array[0];
    let maxDelta = minDelta;
    for (let i = 0; i < array.length - 1; i++) {
        const delta = array[i + 1] - array[i];
        if (delta < minDelta)
            minDelta = delta;
        if (delta > maxDelta)
            maxDelta = delta;
    }
    return { min: minDelta, max: maxDelta };
}
exports.xMinMaxDelta = xMinMaxDelta;

},{"./xCheck":249}],275:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMinMaxValues = void 0;
const xCheck_1 = require("./xCheck");
/**
 * Return min and max values of an array
 *
 * @param array - array of number
 * @returns - Object with 2 properties, min and max
 */
function xMinMaxValues(array) {
    (0, xCheck_1.xCheck)(array);
    let min = array[0];
    let max = array[0];
    for (let value of array) {
        if (value < min)
            min = value;
        if (value > max)
            max = value;
    }
    return { min, max };
}
exports.xMinMaxValues = xMinMaxValues;

},{"./xCheck":249}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMinValue = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Computes the minimal value of an array of values
 *
 * @param array - array of numbers
 * @param options - options
 */
function xMinValue(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let minValue = array[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        if (array[i] < minValue) {
            minValue = array[i];
        }
    }
    return minValue;
}
exports.xMinValue = xMinValue;

},{"./xCheck":249,"./xGetFromToIndex":258}],277:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMode = void 0;
/**
 * Calculates the mode of an array
 *
 * @param input - Array containing values
 * @returns - mode
 */
function xMode(input) {
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    let maxValue = 0;
    let maxCount = 0;
    let count = 0;
    let counts = {};
    for (let i = 0; i < input.length; ++i) {
        let element = input[i];
        count = counts[element];
        if (count) {
            counts[element]++;
            count++;
        }
        else {
            counts[element] = 1;
            count = 1;
        }
        if (count > maxCount) {
            maxCount = count;
            maxValue = input[i];
        }
    }
    return maxValue;
}
exports.xMode = xMode;

},{}],278:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xMultiply = void 0;
const is_any_array_1 = require("is-any-array");
const getOutputArray_1 = require("./utils/getOutputArray");
/**
 * This function xMultiply the first array by the second array or a constant value to each element of the first array
 *
 * @param array1 - first array
 * @param array2 - second array
 * @param options - options
 */
function xMultiply(array1, array2, options = {}) {
    let isConstant = false;
    let constant = 0;
    if ((0, is_any_array_1.isAnyArray)(array2)) {
        if (array1.length !== array2.length) {
            throw new Error('xMultiply: size of array1 and array2 must be identical');
        }
    }
    else {
        isConstant = true;
        constant = Number(array2);
    }
    let array3 = (0, getOutputArray_1.getOutputArray)(options.output, array1.length);
    if (isConstant) {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] * constant;
        }
    }
    else {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] * array2[i];
        }
    }
    return array3;
}
exports.xMultiply = xMultiply;

},{"./utils/getOutputArray":242,"is-any-array":13}],279:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xNoiseSanPlot = void 0;
const spline_interpolator_1 = __importDefault(require("spline-interpolator"));
const createFromToArray_1 = require("../utils/createFromToArray");
const erfcinv_1 = __importDefault(require("./erfcinv"));
const rayleighCdf_1 = __importDefault(require("./rayleighCdf"));
/**
 * Determine noise level by san plot methodology (https://doi.org/10.1002/mrc.4882)
 *
 * @param array - real or magnitude spectra data.
 * @param options - options
 * @returns noise level
 */
function xNoiseSanPlot(array, options = {}) {
    const { mask, cutOff, refine = true, magnitudeMode = false, scaleFactor = 1, factorStd = 5, fixOffset = true, } = options;
    let input;
    if (Array.isArray(mask) && mask.length === array.length) {
        input = new Float64Array(array.filter((_e, i) => !mask[i]));
    }
    else {
        input = new Float64Array(array);
    }
    if (scaleFactor > 1) {
        for (let i = 0; i < input.length; i++) {
            input[i] *= scaleFactor;
        }
    }
    input = input.sort().reverse();
    if (fixOffset && !magnitudeMode) {
        let medianIndex = Math.floor(input.length / 2);
        let median = 0.5 * (input[medianIndex] + input[medianIndex + 1]);
        for (let i = 0; i < input.length; i++) {
            input[i] -= median;
        }
    }
    let firstNegativeValueIndex = input[input.length - 1] >= 0 ? input.length : input.findIndex((e) => e < 0);
    let lastPositiveValueIndex = firstNegativeValueIndex - 1;
    for (let i = lastPositiveValueIndex; i >= 0; i--) {
        if (input[i] > 0) {
            lastPositiveValueIndex = i;
            break;
        }
    }
    let signPositive = input.slice(0, lastPositiveValueIndex + 1);
    let signNegative = input.slice(firstNegativeValueIndex);
    let cutOffDist = cutOff || determineCutOff(signPositive, { magnitudeMode });
    let pIndex = Math.floor(signPositive.length * cutOffDist);
    let initialNoiseLevelPositive = signPositive[pIndex];
    let skyPoint = signPositive[0];
    let initialNoiseLevelNegative;
    if (signNegative.length > 0) {
        let nIndex = Math.floor(signNegative.length * (1 - cutOffDist));
        initialNoiseLevelNegative = -1 * signNegative[nIndex];
    }
    else {
        initialNoiseLevelNegative = 0;
    }
    let noiseLevelPositive = initialNoiseLevelPositive;
    let noiseLevelNegative = initialNoiseLevelNegative;
    let cloneSignPositive = signPositive.slice();
    let cloneSignNegative = signNegative.slice();
    let cutOffSignalsIndexPlus = 0;
    let cutOffSignalsIndexNeg = 2;
    if (refine) {
        let cutOffSignals = noiseLevelPositive * factorStd;
        cutOffSignalsIndexPlus = signPositive.findIndex((e) => e < cutOffSignals);
        if (cutOffSignalsIndexPlus > -1) {
            cloneSignPositive = signPositive.slice(cutOffSignalsIndexPlus);
            noiseLevelPositive =
                cloneSignPositive[Math.floor(cloneSignPositive.length * cutOffDist)];
        }
        cutOffSignals = noiseLevelNegative * factorStd;
        cutOffSignalsIndexNeg = signNegative.findIndex((e) => e < cutOffSignals);
        if (cutOffSignalsIndexNeg > -1) {
            cloneSignNegative = signNegative.slice(cutOffSignalsIndexNeg);
            noiseLevelNegative =
                cloneSignPositive[Math.floor(cloneSignNegative.length * (1 - cutOffDist))];
        }
    }
    let correctionFactor = -simpleNormInv(cutOffDist / 2, { magnitudeMode });
    initialNoiseLevelPositive = initialNoiseLevelPositive / correctionFactor;
    initialNoiseLevelNegative = initialNoiseLevelNegative / correctionFactor;
    let effectiveCutOffDist, refinedCorrectionFactor;
    if (refine && cutOffSignalsIndexPlus > -1) {
        effectiveCutOffDist =
            (cutOffDist * cloneSignPositive.length + cutOffSignalsIndexPlus) /
                (cloneSignPositive.length + cutOffSignalsIndexPlus);
        refinedCorrectionFactor =
            -1 *
                simpleNormInv(effectiveCutOffDist / 2, { magnitudeMode });
        noiseLevelPositive /= refinedCorrectionFactor;
        if (cutOffSignalsIndexNeg > -1) {
            effectiveCutOffDist =
                (cutOffDist * cloneSignNegative.length + cutOffSignalsIndexNeg) /
                    (cloneSignNegative.length + cutOffSignalsIndexNeg);
            refinedCorrectionFactor =
                -1 *
                    simpleNormInv(effectiveCutOffDist / 2, { magnitudeMode });
            if (noiseLevelNegative !== 0) {
                noiseLevelNegative /= refinedCorrectionFactor;
            }
        }
    }
    else {
        noiseLevelPositive /= correctionFactor;
        noiseLevelNegative /= correctionFactor;
    }
    return {
        positive: noiseLevelPositive,
        negative: noiseLevelNegative,
        snr: skyPoint / noiseLevelPositive,
        sanplot: generateSanPlot(input, {
            fromTo: {
                positive: { from: 0, to: lastPositiveValueIndex },
                negative: { from: firstNegativeValueIndex, to: input.length },
            },
        }),
    };
}
exports.xNoiseSanPlot = xNoiseSanPlot;
/**
 * DetermineCutOff.
 *
 * @param signPositive - Array of numbers.
 * @param [options = {}] - Options.
 * @param [options.mask] - Boolean array to filter data, if the i-th element is true then the i-th element of the distribution will be ignored.
 * @param [options.scaleFactor=1] - Factor to scale the data input[i]*=scaleFactor.
 * @param [options.cutOff] - Percent of positive signal distribution where the noise level will be determined, if it is not defined the program calculate it.
 * @param [options.factorStd=5] - Factor times std to determine what will be marked as signals.
 * @param [options.refine=true] - If true the noise level will be recalculated get out the signals using factorStd.
 * @param [options.fixOffset=true] - If the baseline is correct, the midpoint of distribution should be zero. If true, the distribution will be centered.
 * @param [options.logBaseY=2] - Log scale to apply in the intensity axis in order to avoid big numbers.
 * @param options.magnitudeMode -
 * @param options.considerList -
 * @param options.considerList.from -
 * @param options.considerList.step -
 * @param options.considerList.to -
 * @param options.fromTo -
 * @returns Result.
 */
function determineCutOff(signPositive, options = {}) {
    let { magnitudeMode = false, considerList = { from: 0.5, step: 0.1, to: 0.9 }, } = options;
    //generate a list of values for
    let cutOff = [];
    let indexMax = signPositive.length - 1;
    for (let i = 0.01; i <= 0.99; i += 0.01) {
        let index = Math.round(indexMax * i);
        let value = -signPositive[index] /
            simpleNormInv([i / 2], { magnitudeMode });
        cutOff.push([i, value]);
    }
    let minKi = Number.MAX_SAFE_INTEGER;
    let { from, to, step } = considerList;
    let delta = step / 2;
    let whereToCutStat = 0.5;
    for (let i = from; i <= to; i += step) {
        let floor = i - delta;
        let top = i + delta;
        let elementsOfCutOff = cutOff.filter((e) => e[0] < top && e[0] > floor);
        let averageValue = elementsOfCutOff.reduce((a, b) => a + Math.abs(b[1]), 0);
        let kiSqrt = 0;
        for (const element of elementsOfCutOff) {
            kiSqrt += Math.pow(element[1] - averageValue, 2);
        }
        if (kiSqrt < minKi) {
            minKi = kiSqrt;
            whereToCutStat = i;
        }
    }
    return whereToCutStat;
}
/**
 * SimpleNormInvs.
 *
 * @param data - Data array.
 * @param [options = {}] - Options.
 * @param [options.mask] - Boolean array to filter data, if the i-th element is true then the i-th element of the distribution will be ignored.
 * @param [options.scaleFactor=1] - Factor to scale the data input[i]*=scaleFactor.
 * @param [options.cutOff] - Percent of positive signal distribution where the noise level will be determined, if it is not defined the program calculate it.
 * @param [options.factorStd=5] - Factor times std to determine what will be marked as signals.
 * @param [options.refine=true] - If true the noise level will be recalculated get out the signals using factorStd.
 * @param [options.fixOffset=true] - If the baseline is correct, the midpoint of distribution should be zero. If true, the distribution will be centered.
 * @param [options.logBaseY=2] - Log scale to apply in the intensity axis in order to avoid big numbers.
 * @param options.magnitudeMode -
 * @param options.considerList -
 * @param options.considerList.from -
 * @param options.considerList.step -
 * @param options.considerList.to -
 * @param options.fromTo -
 * @returns Result.
 */
function simpleNormInv(data, options = {}) {
    const { magnitudeMode = false } = options;
    if (!Array.isArray(data))
        data = [data];
    let from = 0;
    let to = 2;
    let step = 0.01;
    let xTraining = Array.from(createArray(from, to, step));
    let result = new Float64Array(data.length);
    let yTraining = new Float64Array(xTraining.length);
    if (magnitudeMode) {
        let factor = 1;
        for (let i = 0; i < yTraining.length; i++) {
            let finalInput = xTraining[i] * factor;
            yTraining[i] = 1 - (0, rayleighCdf_1.default)(finalInput);
        }
        let interp = new spline_interpolator_1.default(xTraining, yTraining);
        for (let i = 0; i < result.length; i++) {
            let yValue = 2 * data[i];
            result[i] = -1 * interp.interpolate(yValue);
        }
    }
    else {
        for (let i = 0; i < result.length; i++) {
            result[i] = -1 * Math.SQRT2 * (0, erfcinv_1.default)(2 * data[i]);
        }
    }
    return result.length === 1 ? result[0] : result;
}
/**
 * CreateArray.
 *
 * @param from - From.
 * @param to - To.
 * @param step - Step.
 * @returns Array of results.
 */
function createArray(from, to, step) {
    // Changed Array to Float64Array
    let result = new Float64Array(Math.abs((from - to) / step + 1));
    for (let i = 0; i < result.length; i++) {
        result[i] = from + i * step;
    }
    return result;
}
/**
 * GenerateSanPlot.
 *
 * @param array - Array.
 * @param [options = {}] - Options.
 * @param [options.mask] - Boolean array to filter data, if the i-th element is true then the i-th element of the distribution will be ignored.
 * @param [options.scaleFactor=1] - Factor to scale the data input[i]*=scaleFactor.
 * @param [options.cutOff] - Percent of positive signal distribution where the noise level will be determined, if it is not defined the program calculate it.
 * @param [options.factorStd=5] - Factor times std to determine what will be marked as signals.
 * @param [options.refine=true] - If true the noise level will be recalculated get out the signals using factorStd.
 * @param [options.fixOffset=true] - If the baseline is correct, the midpoint of distribution should be zero. If true, the distribution will be centered.
 * @param [options.logBaseY=2] - Log scale to apply in the intensity axis in order to avoid big numbers.
 * @param options.magnitudeMode -
 * @param options.considerList -
 * @param options.considerList.from -
 * @param options.considerList.step -
 * @param options.considerList.to -
 * @param options.fromTo -
 * @returns Results.
 */
function generateSanPlot(array, options = {}) {
    const { fromTo, logBaseY = 2 } = options;
    let sanplot = {};
    for (let key in fromTo) {
        let { from, to } = fromTo[key];
        sanplot[key] =
            from !== to
                ? scale(array.slice(from, to), {
                    logBaseY,
                })
                : { x: [], y: [] };
        if (key === 'negative') {
            sanplot[key].y.reverse();
        }
    }
    return sanplot;
}
/**
 * Scale.
 *
 * @param array - Array.
 * @param [options = {}] - Options.
 * @param [options.mask] - Boolean array to filter data, if the i-th element is true then the i-th element of the distribution will be ignored.
 * @param [options.scaleFactor=1] - Factor to scale the data input[i]*=scaleFactor.
 * @param [options.cutOff] - Percent of positive signal distribution where the noise level will be determined, if it is not defined the program calculate it.
 * @param [options.factorStd=5] - Factor times std to determine what will be marked as signals.
 * @param [options.refine=true] - If true the noise level will be recalculated get out the signals using factorStd.
 * @param [options.fixOffset=true] - If the baseline is correct, the midpoint of distribution should be zero. If true, the distribution will be centered.
 * @param [options.logBaseY=2] - Log scale to apply in the intensity axis in order to avoid big numbers.
 * @param options.magnitudeMode -
 * @param options.considerList -
 * @param options.considerList.from -
 * @param options.considerList.step -
 * @param options.considerList.to -
 * @param options.fromTo -
 * @returns Results.
 */
function scale(array, options = {}) {
    const { log10, abs } = Math;
    const { logBaseY } = options;
    if (logBaseY) {
        array = array.slice();
        const logOfBase = log10(logBaseY);
        for (let i = 0; i < array.length; i++) {
            array[i] = log10(abs(array[i])) / logOfBase;
        }
    }
    const xAxis = (0, createFromToArray_1.createFromToArray)({
        from: 0,
        to: array.length - 1,
        length: array.length,
    });
    return { x: xAxis, y: array };
}

},{"../utils/createFromToArray":237,"./erfcinv":240,"./rayleighCdf":241,"spline-interpolator":533}],280:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xNoiseStandardDeviation = void 0;
const __1 = require("..");
/**
 * Determine noise level using MAD https://en.wikipedia.org/wiki/Median_absolute_deviation
 * Constant to convert mad to sd calculated using https://www.wolframalpha.com/input?i=sqrt%282%29+inverse+erf%280.5%29
 * This assumes a gaussian distribution of the noise
 * @param array
 * @returns noise level corresponding to one standard deviation
 */
function xNoiseStandardDeviation(array) {
    const { mad, median } = (0, __1.xMedianAbsoluteDeviation)(array);
    return { sd: mad / 0.6744897501960817, mad, median };
}
exports.xNoiseStandardDeviation = xNoiseStandardDeviation;

},{"..":208}],281:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xNorm = void 0;
/**
 * This function calculate the norm of a vector
 *
 * @example xNorm([3, 4]) -> 5
 * @param array - array
 * @returns - calculated norm
 */
function xNorm(array) {
    let result = 0;
    for (const element of array) {
        result += element ** 2;
    }
    return Math.sqrt(result);
}
exports.xNorm = xNorm;

},{}],282:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xNormed = void 0;
const getOutputArray_1 = require("./utils/getOutputArray");
const xCheck_1 = require("./xCheck");
const xMaxValue_1 = require("./xMaxValue");
const xSum_1 = require("./xSum");
/**
 * Divides the data with either the sum, the absolute sum or the maximum of the data
 * @param array - Array containing values
 * @param options - options
 * @returns - normalized data
 */
function xNormed(input, options = {}) {
    const { algorithm = 'absolute', value = 1 } = options;
    (0, xCheck_1.xCheck)(input);
    const output = (0, getOutputArray_1.getOutputArray)(options.output, input.length);
    if (input.length === 0) {
        throw new Error('input must not be empty');
    }
    switch (algorithm.toLowerCase()) {
        case 'absolute': {
            let absoluteSumValue = absoluteSum(input) / value;
            if (absoluteSumValue === 0) {
                throw new Error('xNormed: trying to divide by 0');
            }
            for (let i = 0; i < input.length; i++) {
                output[i] = input[i] / absoluteSumValue;
            }
            return output;
        }
        case 'max': {
            let currentMaxValue = (0, xMaxValue_1.xMaxValue)(input);
            if (currentMaxValue === 0) {
                throw new Error('xNormed: trying to divide by 0');
            }
            const factor = value / currentMaxValue;
            for (let i = 0; i < input.length; i++) {
                output[i] = input[i] * factor;
            }
            return output;
        }
        case 'sum': {
            let sumFactor = (0, xSum_1.xSum)(input) / value;
            if (sumFactor === 0) {
                throw new Error('xNormed: trying to divide by 0');
            }
            for (let i = 0; i < input.length; i++) {
                output[i] = input[i] / sumFactor;
            }
            return output;
        }
        default:
            throw new Error(`norm: unknown algorithm: ${algorithm}`);
    }
}
exports.xNormed = xNormed;
function absoluteSum(input) {
    let sumValue = 0;
    for (let i = 0; i < input.length; i++) {
        sumValue += Math.abs(input[i]);
    }
    return sumValue;
}

},{"./utils/getOutputArray":242,"./xCheck":249,"./xMaxValue":266,"./xSum":297}],283:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xPadding = void 0;
const xCheck_1 = require("./xCheck");
/**
 * This function pads an array
 *s
 * @param array - the array that will be padded
 * @param options - options
 */
function xPadding(array, options = {}) {
    const { size = 0, value = 0, algorithm = '' } = options;
    (0, xCheck_1.xCheck)(array);
    if (!algorithm) {
        if (array instanceof Float64Array) {
            return array.slice();
        }
        else {
            return Float64Array.from(array);
        }
    }
    let result = new Float64Array(array.length + size * 2);
    for (let i = 0; i < array.length; i++) {
        result[i + size] = array[i];
    }
    let fromEnd = size + array.length;
    let toEnd = 2 * size + array.length;
    switch (algorithm.toLowerCase()) {
        case 'value':
            for (let i = 0; i < size; i++) {
                result[i] = value;
            }
            for (let i = fromEnd; i < toEnd; i++) {
                result[i] = value;
            }
            break;
        case 'duplicate':
            for (let i = 0; i < size; i++) {
                result[i] = array[0];
            }
            for (let i = fromEnd; i < toEnd; i++) {
                result[i] = array[array.length - 1];
            }
            break;
        case 'circular':
            for (let i = 0; i < size; i++) {
                result[i] =
                    array[(array.length - (size % array.length) + i) % array.length];
            }
            for (let i = 0; i < size; i++) {
                result[i + fromEnd] = array[i % array.length];
            }
            break;
        default:
            throw new Error('xPadding: unknown algorithm');
    }
    return result;
}
exports.xPadding = xPadding;

},{"./xCheck":249}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xParetoNormalization = void 0;
const xCheck_1 = require("./xCheck");
const xStandardDeviation_1 = require("./xStandardDeviation");
/**
 * Pareto scaling, which uses the square root of standard deviation as the scaling factor, circumvents the amplification of noise by retaining a small portion of magnitude information.
 * Noda, I. (2008). Scaling techniques to enhance two-dimensional correlation spectra. Journal of Molecular Structure, 883, 216-227.
 * DOI: 10.1016/j.molstruc.2007.12.026
 *
 * @param array - array of number
 */
function xParetoNormalization(array) {
    (0, xCheck_1.xCheck)(array);
    let result = [];
    const sqrtSD = Math.sqrt((0, xStandardDeviation_1.xStandardDeviation)(array));
    for (let item of array) {
        result.push(item / sqrtSD);
    }
    return result;
}
exports.xParetoNormalization = xParetoNormalization;

},{"./xCheck":249,"./xStandardDeviation":295}],285:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRescale = void 0;
const __1 = require("..");
const getOutputArray_1 = require("./utils/getOutputArray");
const xMaxValue_1 = require("./xMaxValue");
const xMinValue_1 = require("./xMinValue");
/** Function used to rescale data
 *
 * @param input - input for the rescale
 * @param options - options
 * @returns rescaled data
 */
function xRescale(input, options = {}) {
    (0, __1.xCheck)(input);
    const output = (0, getOutputArray_1.getOutputArray)(options.output, input.length);
    const currentMin = (0, xMinValue_1.xMinValue)(input);
    const currentMax = (0, xMaxValue_1.xMaxValue)(input);
    if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
    }
    const { min = 0, max = 1 } = options;
    if (min >= max) {
        throw new RangeError('min option must be smaller than max option');
    }
    const factor = (max - min) / (currentMax - currentMin);
    for (let i = 0; i < input.length; i++) {
        output[i] = (input[i] - currentMin) * factor + min;
    }
    return output;
}
exports.xRescale = xRescale;

},{"..":208,"./utils/getOutputArray":242,"./xMaxValue":266,"./xMinValue":276}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRolling = void 0;
const xCheck_1 = require("./xCheck");
const xPadding_1 = require("./xPadding");
/**
 * This function calculates a rolling average
 *
 * @param array - array
 * @param fct - callback function that from an array returns a value
 * @param options - options
 */
function xRolling(array, fct, options = {}) {
    (0, xCheck_1.xCheck)(array);
    if (typeof fct !== 'function')
        throw new Error('fct has to be a function');
    const { window = 5, padding = {} } = options;
    const { size = window - 1, algorithm, value } = padding;
    array = (0, xPadding_1.xPadding)(array, { size, algorithm, value }); // ensure we get a copy and it is float64
    const newArray = [];
    for (let i = 0; i < array.length - window + 1; i++) {
        // we will send a view to the original buffer
        newArray.push(fct(array.subarray(i, i + window)));
    }
    return newArray;
}
exports.xRolling = xRolling;

},{"./xCheck":249,"./xPadding":283}],287:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRollingAverage = void 0;
const xMean_1 = require("./xMean");
const xRolling_1 = require("./xRolling");
/**
 * This function calculates a rolling average
 *
 * @param array - array
 * @param options - option
 */
function xRollingAverage(array, options = {}) {
    return (0, xRolling_1.xRolling)(array, xMean_1.xMean, options);
}
exports.xRollingAverage = xRollingAverage;

},{"./xMean":267,"./xRolling":286}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRollingMax = void 0;
const xMaxValue_1 = require("./xMaxValue");
const xRolling_1 = require("./xRolling");
/**
 * This function calculates a maximum within a rolling window
 *
 * @param array - array
 * @param options - options
 */
function xRollingMax(array, options = {}) {
    return (0, xRolling_1.xRolling)(array, xMaxValue_1.xMaxValue, options);
}
exports.xRollingMax = xRollingMax;

},{"./xMaxValue":266,"./xRolling":286}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRollingMedian = void 0;
const xMedian_1 = require("./xMedian");
const xRolling_1 = require("./xRolling");
/**
 * This function calculates a rolling average
 *
 * @param array - array
 * @param options - options
 */
function xRollingMedian(array, options = {}) {
    return (0, xRolling_1.xRolling)(array, xMedian_1.xMedian, options);
}
exports.xRollingMedian = xRollingMedian;

},{"./xMedian":271,"./xRolling":286}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRollingMin = void 0;
const xMinValue_1 = require("./xMinValue");
const xRolling_1 = require("./xRolling");
/**
 * This function calculates a minimum within a rolling window
 *
 * @param array - array
 * @param options - options
 */
function xRollingMin(array, options = {}) {
    return (0, xRolling_1.xRolling)(array, xMinValue_1.xMinValue, options);
}
exports.xRollingMin = xRollingMin;

},{"./xMinValue":276,"./xRolling":286}],291:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xRotate = void 0;
/**
 * This function performs a circular shift to an array
 * Positive values of shifts will shift to the right and negative values will do to the left
 *
 * @example xRotate([1,2,3,4],1) -> [4,1,2,3]
 * @example xRotate([1,2,3,4],-1) -> [2,3,4,1]
 * @param array - array
 * @param shift - shift
 * @returns - rotated array
 */
function xRotate(array, shift) {
    shift = shift % array.length;
    if (shift < 0)
        shift += array.length;
    let result = new Float64Array(array.length);
    result.set(array.slice(array.length - shift));
    result.set(array.slice(0, array.length - shift), shift);
    return result;
}
exports.xRotate = xRotate;

},{}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xSampling = void 0;
/**
 * Sample within the array
 *
 * @param array - array from which to sample
 * @param options - options
 * @return - array with evenly spaced elements
 */
function xSampling(array, options = {}) {
    const { length = 10 } = options;
    let returnArray = [];
    if (length > array.length) {
        throw new Error('Choose sample number smaller than the number of elements in the array');
    }
    let clonedArray = array.slice();
    returnArray.push(clonedArray[0]);
    clonedArray.shift();
    let delta = Math.floor(clonedArray.length / (length - 1));
    for (let i = delta - 1, j = 0; i < clonedArray.length && j < length - 1; i = i + delta, j++) {
        returnArray.push(clonedArray[i]);
    }
    return returnArray;
}
exports.xSampling = xSampling;

},{}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xSequentialFill = void 0;
const is_any_array_1 = require("is-any-array");
/** Fill an array with sequential numbers
 *
 * @param input - optional destination array (if not provided a new array will be created)
 * @param options - options
 * @return array with sequential numbers
 */
function xSequentialFill(input = [], options = {}) {
    if (typeof input === 'object' && !(0, is_any_array_1.isAnyArray)(input)) {
        options = input;
        input = [];
    }
    if (!(0, is_any_array_1.isAnyArray)(input)) {
        throw new TypeError('input must be an array');
    }
    // maybe should not specify default step and size
    let { from = 0, to = 10, size = Array.isArray(input) ||
        input.constructor === Float64Array ||
        input.constructor === Uint16Array
        ? input.length
        : 0, step = null, } = options;
    if (!size) {
        if (step) {
            size = Math.floor((to - from) / step) + 1;
        }
        else {
            size = to - from + 1;
        }
    }
    if (!step && size) {
        step = (to - from) / (size - 1);
    }
    if (Array.isArray(input)) {
        // only works with normal array
        input.length = 0;
        for (let i = 0; i < size; i++) {
            input.push(from);
            if (step)
                from += step;
        }
    }
    else {
        if (Array.isArray(input) ||
            input.constructor === Float64Array ||
            (input.constructor === Uint16Array && input.length !== size)) {
            throw new Error('sequentialFill typed array must have the correct length');
        }
        for (let i = 0; i < size; i++) {
            if (Array.isArray(input) ||
                input.constructor === Float64Array ||
                input.constructor === Uint16Array) {
                input[i] = from;
            }
            if (step) {
                from += step;
            }
        }
    }
    return Array.isArray(input) ||
        input.constructor === Float64Array ||
        input.constructor === Uint16Array
        ? Array.from(input)
        : [];
}
exports.xSequentialFill = xSequentialFill;

},{"is-any-array":13}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xSortDescending = exports.xSortAscending = void 0;
/** Function that sorts arrays or Float64Arrays in ascending order
 *
 * @param array - array to sort
 * @returns sorted array
 */
function xSortAscending(array) {
    if (array instanceof Float64Array) {
        return array.sort();
    }
    else if (Array.isArray(array)) {
        return array.sort((a, b) => a - b);
    }
    throw new Error('Trying to sort non aray');
}
exports.xSortAscending = xSortAscending;
/** Function that sorts arrays or Float64Arrays in descending order
 *
 * @param array - array to sort
 * @returns sorted array
 */
function xSortDescending(array) {
    if (array instanceof Float64Array) {
        return array.sort().reverse();
    }
    else if (Array.isArray(array)) {
        return array.sort((a, b) => b - a);
    }
    throw new Error('Trying to sort non aray');
}
exports.xSortDescending = xSortDescending;

},{}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xStandardDeviation = void 0;
const xVariance_1 = require("./xVariance");
/** Finds the standard deviation for the data at hand
 *
 * @param values - values in the data
 * @param options - options
 * @returns standard deviation
 */
function xStandardDeviation(values, options = {}) {
    return Math.sqrt((0, xVariance_1.xVariance)(values, options));
}
exports.xStandardDeviation = xStandardDeviation;

},{"./xVariance":299}],296:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xSubtract = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * This function xSubtract the first array by the second array or a constant value from each element of the first array
 *
 * @param array1 - the array that will be rotated
 * @param array2 - second array or number
 * @returns array after subtraction
 */
function xSubtract(array1, array2) {
    let isConstant = false;
    let constant = 0;
    if ((0, is_any_array_1.isAnyArray)(array2)) {
        if (array1.length !== array2.length) {
            throw new Error('xSubtract: size of array1 and array2 must be identical');
        }
    }
    else {
        isConstant = true;
        constant = Number(array2);
    }
    let array3 = new Float64Array(array1.length);
    if (isConstant) {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] - constant;
        }
    }
    else {
        for (let i = 0; i < array1.length; i++) {
            array3[i] = array1[i] - array2[i];
        }
    }
    return array3;
}
exports.xSubtract = xSubtract;

},{"is-any-array":13}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xSum = void 0;
const xCheck_1 = require("./xCheck");
const xGetFromToIndex_1 = require("./xGetFromToIndex");
/**
 * Calculate the sum of the values
 *
 * @param array - Object that contains property x (an ordered increasing array) and y (an array).
 * @param options - Options.
 * @returns XSum value on the specified range.
 */
function xSum(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(array, options);
    let sumValue = array[fromIndex];
    for (let i = fromIndex + 1; i <= toIndex; i++) {
        sumValue += array[i];
    }
    return sumValue;
}
exports.xSum = xSum;

},{"./xCheck":249,"./xGetFromToIndex":258}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xUniqueSorted = void 0;
/**
 * XUniqueSorted.
 *
 * @param array - array of numbers
 * @returns - sorted array
 */
function xUniqueSorted(array) {
    return Float64Array.from(new Set(array)).sort();
}
exports.xUniqueSorted = xUniqueSorted;

},{}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xVariance = void 0;
const is_any_array_1 = require("is-any-array");
const xMean_1 = require("./xMean");
/** Finds the variance of the data
 *
 * @param values - the values of the array
 * @param options - options
 * @returns variance
 */
function xVariance(values, options = {}) {
    if (!(0, is_any_array_1.isAnyArray)(values)) {
        throw new TypeError('input must be an array');
    }
    const { unbiased = true, mean = (0, xMean_1.xMean)(values) } = options;
    let sqrError = 0;
    for (let i = 0; i < values.length; i++) {
        let x = values[i] - mean;
        sqrError += x * x;
    }
    if (unbiased) {
        return sqrError / (values.length - 1);
    }
    else {
        return sqrError / values.length;
    }
}
exports.xVariance = xVariance;

},{"./xMean":267,"is-any-array":13}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xreimSortX = void 0;
/**
 * Sort object of array, x has to be monotone.
 *
 * @param data - object of kind {x:[], re:[], im:[]}
 * @returns - sorted array
 */
function xreimSortX(data) {
    const { x, re, im } = data;
    if (x.length !== re.length || x.length !== im.length) {
        throw new TypeError('xreimSortX: length of x, re and im must be identical');
    }
    if (x.length < 2 || x[0] < x[1])
        return data;
    return {
        x: x.slice(0).reverse(),
        re: re.slice(0).reverse(),
        im: im.slice(0).reverse(),
    };
}
exports.xreimSortX = xreimSortX;

},{}],301:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xreimZeroFilling = void 0;
/**
 * This function make a zero filling to re and im part.
 *
 * @param data - object of kind {x:[], re:[], im:[]}
 * @param totalLength - final number of points
 * @returns - data.
 */
function xreimZeroFilling(data, totalLength) {
    let length = data.x.length;
    if (totalLength === 0 || length === totalLength)
        return data;
    if (length > totalLength) {
        return {
            x: data.x.slice(0, totalLength),
            re: data.re.slice(0, totalLength),
            im: data.im.slice(0, totalLength),
        };
    }
    const x = data.x;
    const re = data.re;
    const im = data.im;
    const newX = new Float64Array(totalLength);
    const newRE = new Float64Array(totalLength);
    const newIM = new Float64Array(totalLength);
    for (let i = 0; i < length; i++) {
        newX[i] = x[i];
        newRE[i] = re[i];
        newIM[i] = im[i];
    }
    const deltaX = (x[x.length - 1] - x[0]) / (length - 1);
    for (let i = length; i < totalLength; i++) {
        newX[i] = newX[i - 1] + deltaX;
    }
    return {
        x: newX,
        re: newRE,
        im: newIM,
    };
}
exports.xreimZeroFilling = xreimZeroFilling;

},{}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * function that retrieves the getEquallySpacedData with the variant "slot"
 *
 * @param x
 * @param y
 * @param from
 * @param to
 * @param numberOfPoints
 * @return Array of y's equally spaced with the variant "slot"
 */
function equallySpacedSlot(
/** x coordinates */
x, 
/** y coordinates */
y, 
/** from value */
from, 
/** to value */
to, 
/** number of points */
numberOfPoints) {
    let xLength = x.length;
    let step = (to - from) / (numberOfPoints > 1 ? numberOfPoints - 1 : 1);
    let halfStep = step / 2;
    let lastStep = x[x.length - 1] - x[x.length - 2];
    let start = from - halfStep;
    // Changed Array to Float64Array
    let output = new Float64Array(numberOfPoints);
    // Init main variables
    let min = start;
    let max = start + step;
    let previousX = -Number.MAX_VALUE;
    let previousY = 0;
    let nextX = x[0];
    let nextY = y[0];
    let frontOutsideSpectra = 0;
    let backOutsideSpectra = true;
    let currentValue = 0;
    // for slot algorithm
    let currentPoints = 0;
    let i = 1; // index of input
    let j = 0; // index of output
    main: while (true) {
        if (previousX >= nextX)
            throw new Error('x must be a growing series');
        while (previousX - max > 0) {
            // no overlap with original point, just consume current value
            if (backOutsideSpectra) {
                currentPoints++;
                backOutsideSpectra = false;
            }
            output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;
            j++;
            if (j === numberOfPoints) {
                break main;
            }
            min = max;
            max += step;
            currentValue = 0;
            currentPoints = 0;
        }
        if (previousX > min) {
            currentValue += previousY;
            currentPoints++;
        }
        if (previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1) {
            currentPoints--;
        }
        previousX = nextX;
        previousY = nextY;
        if (i < xLength) {
            nextX = x[i];
            nextY = y[i];
            i++;
        }
        else {
            nextX += lastStep;
            nextY = 0;
            frontOutsideSpectra++;
        }
    }
    return output;
}
exports.default = equallySpacedSlot;

},{}],303:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const integral_1 = __importDefault(require("./integral"));
/**
 * function that retrieves the getEquallySpacedData with the variant "smooth"
 *
 * @param x
 * @param y
 * @param from
 * @param to
 * @param numberOfPoints
 * @return - Array of y's equally spaced with the variant "smooth"
 */
function equallySpacedSmooth(
/** x coordinates */
x, 
/** y coordinates */
y, 
/** from value */
from, 
/** to value */
to, 
/** number of points */
numberOfPoints) {
    let xLength = x.length;
    let step = (to - from) / (numberOfPoints > 1 ? numberOfPoints - 1 : 1);
    let halfStep = step / 2;
    // Changed Array to Float64Array
    let output = new Float64Array(numberOfPoints);
    let initialOriginalStep = x[1] - x[0];
    let lastOriginalStep = x[xLength - 1] - x[xLength - 2];
    // Init main variables
    let min = from - halfStep;
    let max = from + halfStep;
    let previousX = Number.MIN_SAFE_INTEGER;
    let previousY = 0;
    let nextX = x[0] - initialOriginalStep;
    let nextY = 0;
    let currentValue = 0;
    let slope = 0;
    let intercept = 0;
    let sumAtMin = 0;
    let sumAtMax = 0;
    let i = 0; // index of input
    let j = 0; // index of output
    let add = 0;
    main: while (true) {
        if (previousX >= nextX)
            throw new Error('x must be a growing series');
        if (previousX <= min && min <= nextX) {
            add = (0, integral_1.default)(0, min - previousX, slope, previousY);
            sumAtMin = currentValue + add;
        }
        while (nextX - max >= 0) {
            // no overlap with original point, just consume current value
            add = (0, integral_1.default)(0, max - previousX, slope, previousY);
            sumAtMax = currentValue + add;
            output[j++] = (sumAtMax - sumAtMin) / step;
            if (j === numberOfPoints) {
                break main;
            }
            min = max;
            max += step;
            sumAtMin = sumAtMax;
        }
        currentValue += (0, integral_1.default)(previousX, nextX, slope, intercept);
        previousX = nextX;
        previousY = nextY;
        if (i < xLength) {
            nextX = x[i];
            nextY = y[i];
            i++;
        }
        else if (i === xLength) {
            nextX += lastOriginalStep;
            nextY = 0;
        }
        slope = getSlope(previousX, previousY, nextX, nextY);
        intercept = -slope * previousX + previousY;
    }
    return output;
}
exports.default = equallySpacedSmooth;
function getSlope(x0, y0, x1, y1) {
    return (y1 - y0) / (x1 - x0);
}

},{"./integral":304}],304:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Function that calculates the integral of the line between two
 * x-coordinates, given the slope and intercept of the line.
 * @param x0
 * @param x1
 * @param slope
 * @param intercept
 * @return integral value.
 */
function integral(
/** first coordinate of point */
x0, 
/** second coordinate of point */
x1, 
/** slope of the line */
slope, 
/** intercept of the line on the y axis */
intercept) {
    return (0.5 * slope * x1 * x1 +
        intercept * x1 -
        (0.5 * slope * x0 * x0 + intercept * x0));
}
exports.default = integral;

},{}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyAlign = void 0;
/**
 * XyAlign will align data of two spectra by verifying wether x values are in a certain range (`delta`).
 * The two spectra should not have two consecutive x values which difference is
 * smaller than `delta` to achieve good results!
 *
 * @param data1 - First spectrum data
 * @param data2 - Second spectrum data
 * @param options - Options
 */
function xyAlign(data1, data2, options = {}) {
    const { delta = 1, common = true, x = 'x1' } = options;
    let result = {
        x: [],
        y1: [],
        y2: [],
    };
    let i = 0;
    let j = 0;
    let length1 = data1.x.length;
    let length2 = data2.x.length;
    while (i < length1 && j < length2) {
        let maxDiff = 0;
        if (typeof delta === 'function') {
            let mean = (data1.x[i] + data2.x[j]) / 2; // is this a good thing to do?
            maxDiff = delta(mean);
        }
        else {
            maxDiff = delta;
        }
        let difference = data1.x[i] - data2.x[j];
        if (Math.abs(difference) > maxDiff) {
            if (difference > 0) {
                if (!common) {
                    result.x.push(data2.x[j]);
                    result.y1.push(0);
                    result.y2.push(data2.y[j]);
                    if (j === length2 - 1) {
                        while (i < length1) {
                            result.x.push(data1.x[i]);
                            result.y1.push(data1.y[i]);
                            result.y2.push(0);
                            i++;
                        }
                    }
                }
                // console.log({ i, j }, result);
                j++;
            }
            else {
                if (!common) {
                    result.x.push(data1.x[i]);
                    result.y1.push(data1.y[i]);
                    result.y2.push(0);
                    if (i === length1 - 1) {
                        while (j < length2) {
                            result.x.push(data2.x[j]);
                            result.y1.push(0);
                            result.y2.push(data2.y[j]);
                            j++;
                        }
                    }
                }
                // console.log({ i, j }, result);
                i++;
            }
        }
        else {
            let weightedX = (data1.x[i] * data1.y[i] + data2.x[j] * data2.y[j]) /
                (data1.y[i] + data2.y[j]);
            switch (x) {
                case 'x1':
                    result.x.push(data1.x[i]);
                    break;
                case 'x2':
                    result.x.push(data2.x[j]);
                    break;
                case 'weighted':
                    result.x.push(weightedX);
                    break;
                default:
                    throw new Error(`Error: Unknown x option value: ${x}`);
            }
            result.y1.push(data1.y[i]);
            result.y2.push(data2.y[j]);
            // console.log({ i, j }, result);
            i++;
            j++;
        }
    }
    return result;
}
exports.xyAlign = xyAlign;

},{}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyCheck = void 0;
const is_any_array_1 = require("is-any-array");
/**
 * Throw an error in no an object of x,y arrays
 *
 * @param data - array of points {x,y,z}
 */
function xyCheck(data, options = {}) {
    const { minLength } = options;
    if (typeof data !== 'object' || !(0, is_any_array_1.isAnyArray)(data.x) || !(0, is_any_array_1.isAnyArray)(data.y)) {
        throw new Error('Data must be an object of x and y arrays');
    }
    if (data.x.length !== data.y.length) {
        throw new Error('The x and y arrays must have the same length');
    }
    if (minLength && data.x.length < minLength) {
        throw new Error(`data.x must have a length of at least ${minLength}`);
    }
}
exports.xyCheck = xyCheck;

},{"is-any-array":13}],307:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyCovariance = void 0;
const xMean_1 = require("../x/xMean");
/**Finds the covariance of the points
 *
 * @param data
 * @param options
 * @return the covariance
 */
function xyCovariance(data, options = {}) {
    const { x, y } = data;
    const { unbiased = true } = options;
    const meanX = (0, xMean_1.xMean)(x);
    const meanY = (0, xMean_1.xMean)(y);
    let error = 0;
    for (let i = 0; i < x.length; i++) {
        error += (x[i] - meanX) * (y[i] - meanY);
    }
    if (unbiased) {
        return error / (x.length - 1);
    }
    else {
        return error / x.length;
    }
}
exports.xyCovariance = xyCovariance;

},{"../x/xMean":267}],308:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyCumulativeDistributionStatistics = void 0;
const xCumulative_1 = require("../x/xCumulative");
const xMaxValue_1 = require("../x/xMaxValue");
const xyCheck_1 = require("./xyCheck");
const xyMaxYPoint_1 = require("./xyMaxYPoint");
const STEPS = [0.25, 0.5, 0.75];
/** Cumulative Distribution Statistics
 *
 * @param data - array of points {x,y}
 * @returns x0, x25, x50, x75, x100, mode (x for maxY)
 */
function xyCumulativeDistributionStatistics(data) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    if (x.length === 0) {
        throw new Error('xyCumulativeDistributionStatistics: Array length must be greater than 0');
    }
    const cumulativeSum = (0, xCumulative_1.xCumulative)(y);
    const maxY = (0, xMaxValue_1.xMaxValue)(cumulativeSum);
    for (let i = 0; i < cumulativeSum.length; i++) {
        cumulativeSum[i] /= maxY;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = {};
    // need to find the x values closest to STEPS/100
    result.x0 = x[0];
    result.x100 = x[x.length - 1];
    let currentStep = 0;
    breakPoint: for (let i = 1; i < cumulativeSum.length; i++) {
        while (STEPS[currentStep] < cumulativeSum[i]) {
            result[`x${STEPS[currentStep] * 100}`] =
                x[i - 1] +
                    (x[i] - x[i - 1]) *
                        ((STEPS[currentStep] - cumulativeSum[i - 1]) /
                            (cumulativeSum[i] - cumulativeSum[i - 1]));
            currentStep++;
            if (currentStep === STEPS.length)
                break breakPoint;
        }
    }
    result.xMode = (0, xyMaxYPoint_1.xyMaxYPoint)(data).x;
    let sumXY = 0;
    let sumY = 0;
    for (let i = 0; i < x.length; i++) {
        sumXY += x[i] * y[i];
        sumY += y[i];
    }
    result.xMean = sumXY / sumY;
    return result;
}
exports.xyCumulativeDistributionStatistics = xyCumulativeDistributionStatistics;

},{"../x/xCumulative":253,"../x/xMaxValue":266,"./xyCheck":306,"./xyMaxYPoint":325}],309:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyEnsureGrowingX = void 0;
const xIsMonotonic_1 = require("../x/xIsMonotonic");
const xyCheck_1 = require("./xyCheck");
/**
 * Filters x,y values to allow strictly growing values in x axis.
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array).
 */
function xyEnsureGrowingX(data) {
    (0, xyCheck_1.xyCheck)(data);
    if ((0, xIsMonotonic_1.xIsMonotonic)(data.x) === 1)
        return data;
    const x = Array.from(data.x);
    const y = Array.from(data.y);
    let prevX = Number.NEGATIVE_INFINITY;
    let currentIndex = 0;
    for (let index = 0; index < x.length; index++) {
        if (prevX < x[index]) {
            if (currentIndex < index) {
                x[currentIndex] = x[index];
                y[currentIndex] = y[index];
            }
            currentIndex++;
            prevX = x[index];
        }
    }
    x.length = currentIndex;
    y.length = currentIndex;
    return { x, y };
}
exports.xyEnsureGrowingX = xyEnsureGrowingX;

},{"../x/xIsMonotonic":263,"./xyCheck":306}],310:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyEquallySpaced = void 0;
const createFromToArray_1 = require("../utils/createFromToArray");
const zonesNormalize_1 = require("../zones/zonesNormalize");
const zonesWithPoints_1 = require("../zones/zonesWithPoints");
const equallySpacedSlot_1 = __importDefault(require("./utils/equallySpacedSlot"));
const equallySpacedSmooth_1 = __importDefault(require("./utils/equallySpacedSmooth"));
const xyCheck_1 = require("./xyCheck");
/**
 * Function that returns a Number array of equally spaced numberOfPoints
 * containing a representation of intensities of the spectra arguments x
 * and y.
 *
 * The options parameter contains an object in the following form:
 * from: starting point
 * to: last point
 * numberOfPoints: number of points between from and to
 * variant: "slot" or "smooth" - smooth is the default option
 *
 * The slot variant consist that each point in an array is calculated
 * averaging the existing points between the slot that belongs to the current
 * value. The smooth variant is the same but takes the integral of the range
 * of the slot and divide by the step size between two points in an array.
 *
 * If exclusions zone are present, zones are ignored !
 *
 * @param data - object containing 2 properties x and y
 * @param options - options
 * @return new object with x / y array with the equally spaced data.
 */
function xyEquallySpaced(data, options = {}) {
    let { x, y } = data;
    let xLength = x.length;
    const { from = x[0], to = x[xLength - 1], variant = 'smooth', numberOfPoints = 100, exclusions = [], zones = [{ from, to }], } = options;
    if (from > to) {
        throw new RangeError('from should be larger than to');
    }
    (0, xyCheck_1.xyCheck)(data);
    if (numberOfPoints < 2) {
        throw new RangeError("'numberOfPoints' option must be greater than 1");
    }
    const normalizedZones = (0, zonesNormalize_1.zonesNormalize)(zones, { from, to, exclusions });
    const zonesWithPointsRes = (0, zonesWithPoints_1.zonesWithPoints)(normalizedZones, numberOfPoints, {
        from,
        to,
    });
    let xResult = [];
    let yResult = [];
    for (let zone of zonesWithPointsRes) {
        if (!zone.numberOfPoints) {
            zone.numberOfPoints = 0;
        }
        let zoneResult = processZone(Array.from(x), Array.from(y), zone.from, zone.to, zone.numberOfPoints, variant);
        xResult = xResult.concat(zoneResult.x);
        yResult = yResult.concat(zoneResult.y);
    }
    return { x: xResult, y: yResult };
}
exports.xyEquallySpaced = xyEquallySpaced;
function processZone(x, y, from, to, numberOfPoints, variant) {
    if (numberOfPoints < 1) {
        throw new RangeError('the number of points must be at least 1');
    }
    let output = variant === 'slot'
        ? Array.from((0, equallySpacedSlot_1.default)(x, y, from, to, numberOfPoints))
        : Array.from((0, equallySpacedSmooth_1.default)(x, y, from, to, numberOfPoints));
    return {
        x: Array.from((0, createFromToArray_1.createFromToArray)({
            from,
            to,
            length: numberOfPoints,
        })),
        y: output,
    };
}

},{"../utils/createFromToArray":237,"../zones/zonesNormalize":362,"../zones/zonesWithPoints":363,"./utils/equallySpacedSlot":302,"./utils/equallySpacedSmooth":303,"./xyCheck":306}],311:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyExtract = void 0;
const zonesNormalize_1 = require("../zones/zonesNormalize");
const xyCheck_1 = require("./xyCheck");
/**
 * XyExtract zones from a XY data
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 * @returns - Array of points
 */
function xyExtract(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let { zones } = options;
    zones = (0, zonesNormalize_1.zonesNormalize)(zones);
    if (x === undefined ||
        y === undefined ||
        !Array.isArray(zones) ||
        zones.length === 0) {
        return data;
    }
    let newX = [];
    let newY = [];
    let currentZone = zones[0];
    let position = 0;
    loop: for (let i = 0; i < x.length; i++) {
        while (currentZone.to < x[i]) {
            position++;
            currentZone = zones[position];
            if (!currentZone) {
                i = x.length;
                break loop;
            }
        }
        if (x[i] >= currentZone.from) {
            newX.push(x[i]);
            newY.push(y[i]);
        }
    }
    return { x: newX, y: newY };
}
exports.xyExtract = xyExtract;

},{"../zones/zonesNormalize":362,"./xyCheck":306}],312:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyFilterMinYValue = void 0;
const xMinMaxValues_1 = require("../x/xMinMaxValues");
/** Filter an array x/y based on various criteria x points are expected to be sorted
 *
 * @param data - object containing 2 properties x and y
 * @param minRelativeYValue - the minimum relative value compare to the Y max value
 * @return filtered data
 */
function xyFilterMinYValue(data, minRelativeYValue) {
    if (minRelativeYValue === undefined)
        return data;
    const { x, y } = data;
    const { min, max } = (0, xMinMaxValues_1.xMinMaxValues)(y);
    const threshold = max * minRelativeYValue;
    if (min >= threshold)
        return data;
    const newX = [];
    const newY = [];
    for (let i = 0; i < x.length; i++) {
        if (y[i] >= threshold) {
            newX.push(x[i]);
            newY.push(y[i]);
        }
    }
    return {
        x: newX,
        y: newY,
    };
}
exports.xyFilterMinYValue = xyFilterMinYValue;

},{"../x/xMinMaxValues":275}],313:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyFilterTopYValues = void 0;
const xSort_1 = require("../x/xSort");
/** Filter an array x/y based on various criteria x points are expected to be sorted
 *
 * @param data - object containing 2 properties x and y
 * @param options - options
 * @return filtered data
 */
function xyFilterTopYValues(data, nbPeaks) {
    if (nbPeaks === undefined)
        return data;
    if (nbPeaks > data.x.length)
        return data;
    const { x, y } = data;
    const newX = [];
    const newY = [];
    const descending = (0, xSort_1.xSortDescending)(y.slice());
    const threshold = descending[nbPeaks - 1];
    let nbThreshold = 0;
    for (let i = 0; i < nbPeaks; i++) {
        if (descending[i] === threshold) {
            nbThreshold++;
        }
    }
    for (let i = 0; i < x.length; i++) {
        if (y[i] > threshold) {
            newX.push(x[i]);
            newY.push(y[i]);
        }
        else if (y[i] === threshold) {
            nbThreshold--;
            if (nbThreshold >= 0) {
                newX.push(x[i]);
                newY.push(y[i]);
            }
        }
    }
    return {
        x: newX,
        y: newY,
    };
}
exports.xyFilterTopYValues = xyFilterTopYValues;

},{"../x/xSort":294}],314:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyFilterX = void 0;
const zonesNormalize_1 = require("../zones/zonesNormalize");
/** Filter an array x/y based on various criteria x points are expected to be sorted
 *
 * @param data - object containing 2 properties x and y
 * @param options - options
 * @return filtered array
 */
function xyFilterX(data, options = {}) {
    const { x, y } = data;
    const { from = x[0], to = x[x.length - 1], zones = [{ from, to }], exclusions = [], } = options;
    let normalizedZones = (0, zonesNormalize_1.zonesNormalize)(zones, { from, to, exclusions });
    let currentZoneIndex = 0;
    let newX = [];
    let newY = [];
    let position = 0;
    while (position < x.length) {
        if (x[position] <= normalizedZones[currentZoneIndex].to &&
            x[position] >= normalizedZones[currentZoneIndex].from) {
            newX.push(x[position]);
            newY.push(y[position]);
        }
        else if (x[position] > normalizedZones[currentZoneIndex].to) {
            currentZoneIndex++;
            if (!normalizedZones[currentZoneIndex])
                break;
        }
        position++;
    }
    return {
        x: newX,
        y: newY,
    };
}
exports.xyFilterX = xyFilterX;

},{"../zones/zonesNormalize":362}],315:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyFilterXPositive = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Filter out all the points for which x <= 0. Useful to display log scale data
 *
 * @param data - data
 * @returns - An object with the filtered data
 */
function xyFilterXPositive(data) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    const newX = [];
    const newY = [];
    if (x === undefined || y === undefined)
        return { x: newX, y: newY };
    for (let i = 0; i < x.length; i++) {
        if (x[i] > 0) {
            newX.push(x[i]);
            newY.push(y[i]);
        }
    }
    return { x: newX, y: newY };
}
exports.xyFilterXPositive = xyFilterXPositive;

},{"./xyCheck":306}],316:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyFindClosestPoint = void 0;
const xFindClosestIndex_1 = require("../x/xFindClosestIndex");
/**
 * Finds the closest point
 *
 * @param data - x array should be sorted and ascending
 * @param target - target to search
 * @returns - closest point
 */
function xyFindClosestPoint(
/** points */
data, target) {
    const { x, y } = data;
    const index = (0, xFindClosestIndex_1.xFindClosestIndex)(x, target);
    return {
        x: x[index],
        y: y[index],
    };
}
exports.xyFindClosestPoint = xyFindClosestPoint;

},{"../x/xFindClosestIndex":257}],317:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyGetNMaxY = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Returns the numberMaxPoints points with the bigger y.
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param numberMaxPoints - Number of points to keep
 * @returns - The points filtered to keep the `numberMaxPoints` most intense points of the input.
 */
function xyGetNMaxY(data, numberMaxPoints) {
    (0, xyCheck_1.xyCheck)(data);
    if (data.x.length <= numberMaxPoints) {
        return data;
    }
    else {
        let newX = new Float64Array(numberMaxPoints);
        let newY = new Float64Array(numberMaxPoints);
        // slice() is used to make a copy of the array, because sort() is IPM
        let threshold = Float64Array.from(data.y).sort().reverse()[numberMaxPoints - 1];
        let index = 0;
        for (let i = 0; i < data.x.length; i++) {
            if (data.y[i] >= threshold) {
                newX[index] = data.x[i];
                newY[index] = data.y[i];
                index++;
            }
            if (index === numberMaxPoints) {
                return { x: newX, y: newY };
            }
        }
        return data;
    }
}
exports.xyGetNMaxY = xyGetNMaxY;

},{"./xyCheck":306}],318:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyGrowingX = void 0;
/**
 * Order object of array, x has to be monotone. Ensure x is growing
 *
 * @param data - Object of kind {x:[], y:[]}.
 */
function xyGrowingX(data) {
    const { x, y } = data;
    if (x.length !== y.length) {
        throw new TypeError('sortX: length of x and y must be identical');
    }
    if (x.length < 2 || x[0] < x[1])
        return data;
    return {
        x: x.slice(0).reverse(),
        y: y.slice(0).reverse(),
    };
}
exports.xyGrowingX = xyGrowingX;

},{}],319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyIntegral = void 0;
const xGetFromToIndex_1 = require("../x/xGetFromToIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Generate a X / Y of the xyIntegral
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - An object with the xyIntegration function
 */
function xyIntegral(data, options = {}) {
    const { reverse = false } = options;
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(x, options);
    let xyIntegration = 0;
    let currentxyIntegral;
    if (reverse) {
        currentxyIntegral = { x: [x[toIndex]], y: [0] };
        for (let i = toIndex; i > fromIndex; i--) {
            xyIntegration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;
            currentxyIntegral.x.push(x[i - 1]);
            currentxyIntegral.y.push(xyIntegration);
        }
        currentxyIntegral.x.reverse();
        currentxyIntegral.y.reverse();
    }
    else {
        currentxyIntegral = { x: [x[fromIndex]], y: [0] };
        for (let i = fromIndex; i < toIndex; i++) {
            xyIntegration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;
            currentxyIntegral.x.push(x[i + 1]);
            currentxyIntegral.y.push(xyIntegration);
        }
    }
    return currentxyIntegral;
}
exports.xyIntegral = xyIntegral;

},{"../x/xGetFromToIndex":258,"./xyCheck":306}],320:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyIntegration = void 0;
const xGetFromToIndex_1 = require("../x/xGetFromToIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Calculate integration
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - xyIntegration value on the specified range
 */
function xyIntegration(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    if (x.length === 1)
        return 0;
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(x, options);
    let currentxyIntegration = 0;
    for (let i = fromIndex; i < toIndex; i++) {
        currentxyIntegration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;
    }
    return currentxyIntegration;
}
exports.xyIntegration = xyIntegration;

},{"../x/xGetFromToIndex":258,"./xyCheck":306}],321:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyJoinX = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Join x / y values when difference in X is closer than delta.
 * When joining, y values are summed and x values are weighted average
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - An object with the xyIntegration function
 */
function xyJoinX(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { delta = 1 } = options;
    const deltaIsFunction = typeof delta === 'function';
    const x = Array.from(data.x);
    const y = Array.from(data.y);
    if (x.length < 2) {
        return { x, y };
    }
    let position = 0;
    for (let i = 1; i < x.length; i++) {
        let difference = x[i] - x[i - 1];
        let currentDelta = deltaIsFunction ? delta((x[i] + x[i - 1]) / 2) : delta;
        if (difference <= currentDelta) {
            // we join
            if (y[position] !== 0 || y[i] !== 0) {
                x[position] =
                    (x[position] * y[position] + x[i] * y[i]) / (y[position] + y[i]);
                y[position] += y[i];
            }
        }
        else {
            position++;
            x[position] = x[i];
            y[position] = y[i];
        }
    }
    x.length = position + 1;
    y.length = position + 1;
    return { x, y };
}
exports.xyJoinX = xyJoinX;

},{"./xyCheck":306}],322:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMaxClosestYPoint = void 0;
const xFindClosestIndex_1 = require("../x/xFindClosestIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Find the closest maximum going up hill
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 * @returns - An object with the x/y value
 */
function xyMaxClosestYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let { target, targetIndex } = options;
    if (targetIndex === undefined) {
        if (target !== undefined) {
            targetIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, target);
        }
        else {
            targetIndex = 0;
        }
    }
    let previousIndex = Number.MIN_SAFE_INTEGER;
    let currentIndex = targetIndex;
    let xyMaxY = y[targetIndex];
    while (currentIndex !== previousIndex) {
        previousIndex = currentIndex;
        if (currentIndex > 0 && y[currentIndex - 1] > xyMaxY) {
            currentIndex--;
        }
        else if (currentIndex < x.length - 1 && y[currentIndex + 1] > xyMaxY) {
            currentIndex++;
        }
        xyMaxY = y[currentIndex];
    }
    return {
        x: x[currentIndex],
        y: y[currentIndex],
        index: currentIndex,
    };
}
exports.xyMaxClosestYPoint = xyMaxClosestYPoint;

},{"../x/xFindClosestIndex":257,"./xyCheck":306}],323:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMaxMerge = void 0;
/**
 * Merge abscissas values on similar ordinates and weight the group of abscissas
 *
 * @param data - object containing 2 properties x and y
 * @param options - options
 * @return array of merged and weighted points
 */
function xyMaxMerge(data, options = {}) {
    const { x, y } = data;
    const { groupWidth = 0.001 } = options;
    let merged = { x: [], y: [] };
    let maxAbscissa = { x: [], y: [] };
    let size = 0;
    let index = 0;
    while (index < x.length) {
        if (size === 0 || x[index] - merged.x[size - 1] > groupWidth) {
            maxAbscissa.x.push(x[index]);
            maxAbscissa.y.push(y[index]);
            merged.x.push(x[index]);
            merged.y.push(y[index]);
            index++;
            size++;
        }
        else {
            if (y[index] > maxAbscissa.y[size - 1]) {
                maxAbscissa.x[size - 1] = x[index];
                maxAbscissa.y[size - 1] = y[index];
            }
            merged.x[size - 1] = x[index];
            merged.y[size - 1] += y[index];
            index++;
        }
    }
    merged.x = maxAbscissa.x.slice();
    return merged;
}
exports.xyMaxMerge = xyMaxMerge;

},{}],324:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMaxY = void 0;
const xGetFromToIndex_1 = require("../x/xGetFromToIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Finds the max value in a zone
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - Max y on the specified range
 */
function xyMaxY(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(x, options);
    let currentxyMaxY = y[fromIndex];
    for (let i = fromIndex; i <= toIndex; i++) {
        if (y[i] > currentxyMaxY)
            currentxyMaxY = y[i];
    }
    return currentxyMaxY;
}
exports.xyMaxY = xyMaxY;

},{"../x/xGetFromToIndex":258,"./xyCheck":306}],325:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMaxYPoint = void 0;
const xGetFromToIndex_1 = require("../x/xGetFromToIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Finds the max y value in a range and return a {x,y} point
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options Options
 */
function xyMaxYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    if (x.length === 1) {
        return { x: x[0], y: y[0], index: 0 };
    }
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(x, options);
    let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };
    for (let i = fromIndex; i <= toIndex; i++) {
        if (y[i] > current.y)
            current = { x: x[i], y: y[i], index: i };
    }
    return current;
}
exports.xyMaxYPoint = xyMaxYPoint;

},{"../x/xGetFromToIndex":258,"./xyCheck":306}],326:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMaximaY = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Finds all the max values
 * If the values are equal the middle
 * of the equal part will be the position of the signal!
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @returns - Array of points
 */
function xyMaximaY(data) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 2 });
    const { x, y } = data;
    let maxima = [];
    let startEqualIndex = -1;
    for (let i = 1; i < x.length - 1; i++) {
        if (y[i - 1] < y[i] && y[i + 1] < y[i]) {
            maxima.push({ x: x[i], y: y[i], index: i });
        }
        else if (y[i - 1] < y[i] && y[i + 1] === y[i]) {
            startEqualIndex = i;
        }
        else if (y[i - 1] === y[i] && y[i + 1] < y[i]) {
            let index = Math.floor((i + startEqualIndex) / 2);
            maxima.push({ x: x[index], y: y[index], index });
        }
    }
    return maxima;
}
exports.xyMaximaY = xyMaximaY;

},{"./xyCheck":306}],327:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMedian = void 0;
/**
 * Finds the median x value for an object with properties x and y (arrays of the same length)
 *
 * @param data - x should be sorted in increasing order
 * @returns - the median of x values
 */
function xyMedian(data) {
    const { x, y } = data;
    let sumY = 0;
    let cumSumY = 0;
    let i;
    if (x.length === 0) {
        return Number.NaN;
    }
    if (x.length === 1) {
        return x[0];
    }
    for (i = 0; i < y.length; i++) {
        sumY += y[i];
    }
    for (i = 0; i < y.length; i++) {
        cumSumY += y[i];
        if (cumSumY > sumY / 2) {
            return x[i];
        }
        else if (cumSumY === sumY / 2) {
            return 0.5 * (x[i] + x[i + 1]);
        }
    }
    return Number.NaN;
}
exports.xyMedian = xyMedian;

},{}],328:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMergeByCentroids = void 0;
/**
 * Merge abscissa values if the ordinate value is in a list of centroids
 *
 * @param data - object containing 2 properties x and y
 * @param centroids - centroids
 * @param options - options
 * @return merged points
 */
function xyMergeByCentroids(data, centroids, options = {}) {
    const { window = 0.01 } = options;
    let mergedPoints = {
        x: centroids.slice(),
        y: new Float64Array(centroids.length).fill(0),
    };
    let originalIndex = 0;
    let mergedIndex = 0;
    while (originalIndex < data.x.length && mergedIndex < centroids.length) {
        let diff = data.x[originalIndex] - centroids[mergedIndex];
        if (Math.abs(diff) < window) {
            mergedPoints.y[mergedIndex] += data.y[originalIndex++];
        }
        else if (diff < 0) {
            originalIndex++;
        }
        else {
            mergedIndex++;
        }
    }
    return mergedPoints;
}
exports.xyMergeByCentroids = xyMergeByCentroids;

},{}],329:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMinClosestYPoint = void 0;
const xFindClosestIndex_1 = require("../x/xFindClosestIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Find the closest minimum going down hill
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - An object with the x/y value
 */
function xyMinClosestYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let { target, targetIndex } = options;
    if (targetIndex === undefined) {
        if (target !== undefined) {
            targetIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, target);
        }
        else {
            targetIndex = 0;
        }
    }
    let previousIndex = Number.MIN_SAFE_INTEGER;
    let currentIndex = targetIndex;
    let minY = y[targetIndex];
    while (currentIndex !== previousIndex) {
        previousIndex = currentIndex;
        if (currentIndex > 0 && y[currentIndex - 1] < minY) {
            currentIndex--;
        }
        else if (currentIndex < x.length - 1 && y[currentIndex + 1] < minY) {
            currentIndex++;
        }
        minY = y[currentIndex];
    }
    return {
        x: x[currentIndex],
        y: y[currentIndex],
        index: currentIndex,
    };
}
exports.xyMinClosestYPoint = xyMinClosestYPoint;

},{"../x/xFindClosestIndex":257,"./xyCheck":306}],330:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMinYPoint = void 0;
const xGetFromToIndex_1 = require("../x/xGetFromToIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Finds the min y value in a range and return a {x,y} point
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 */
function xyMinYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    if (x.length === 1)
        return { x: x[0], y: y[0], index: 0 };
    const { fromIndex, toIndex } = (0, xGetFromToIndex_1.xGetFromToIndex)(x, options);
    let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };
    for (let i = fromIndex; i <= toIndex; i++) {
        if (y[i] < current.y)
            current = { x: x[i], y: y[i], index: i };
    }
    return current;
}
exports.xyMinYPoint = xyMinYPoint;

},{"../x/xGetFromToIndex":258,"./xyCheck":306}],331:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyMinimaY = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Finds all the min values
 * If the values are equal the middle
 * of the equal part will be the position of the signal!
 *
 * @param data - Object that contains property X (an ordered increasing array) and y (an arraY)
 * @returns - Array of points.
 */
function xyMinimaY(data) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 2 });
    const { x, y } = data;
    let maxima = [];
    let startEqualIndex = -1;
    for (let i = 1; i < x.length - 1; i++) {
        if (y[i - 1] > y[i] && y[i + 1] > y[i]) {
            maxima.push({ x: x[i], y: y[i], index: i });
        }
        else if (y[i - 1] > y[i] && y[i + 1] === y[i]) {
            startEqualIndex = i;
        }
        else if (y[i - 1] === y[i] && y[i + 1] > y[i]) {
            let index = Math.floor((i + startEqualIndex) / 2);
            maxima.push({ x: x[index], y: y[index], index });
        }
    }
    return maxima;
}
exports.xyMinimaY = xyMinimaY;

},{"./xyCheck":306}],332:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyPeakInfo = void 0;
const xFindClosestIndex_1 = require("../x/xFindClosestIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Returns an information about a signal.
 *
 *
 * We expect ordered data and equidistant X axis
 * You can use the method helper if required:
 * ML.ArrayPoints.uniqueX
 * ML.ArrayPoints.sortX
 * ML.ArrayPoints.equallySpaced
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 * @returns - Information about signal
 */
function xyPeakInfo(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    if (x === undefined || y === undefined || x.length < 3)
        return undefined;
    let { targetIndex, target } = options;
    if (targetIndex === undefined && target !== undefined) {
        targetIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, target);
    }
    if (targetIndex === undefined) {
        throw new Error('xyPeakInfo: need to specify target or targetIndex');
    }
    let i = targetIndex;
    let currentDiff = y[i] - y[i + 1];
    let multiplier = currentDiff < 0 ? -1 : 1;
    currentDiff *= multiplier;
    while (i < x.length - 1) {
        i++;
        let newDiff = (y[i] - y[i + 1]) * multiplier;
        if (newDiff < currentDiff)
            break;
        currentDiff = newDiff;
    }
    let after = { x: x[i], y: y[i] };
    i = targetIndex;
    currentDiff = (y[i] - y[i - 1]) * multiplier;
    while (i > 1) {
        i--;
        let newDiff = (y[i] - y[i - 1]) * multiplier;
        if (newDiff < currentDiff)
            break;
        currentDiff = newDiff;
    }
    let before = { x: x[i], y: y[i] };
    return {
        inflectionBefore: before,
        inflectionAfter: after,
        extrema: { x: x[targetIndex], y: y[targetIndex] },
        inflectionMiddle: {
            x: (before.x + after.x) / 2,
            y: (before.y + after.y) / 2,
        },
        width: Math.abs(before.x - after.x),
    };
}
exports.xyPeakInfo = xyPeakInfo;

},{"../x/xFindClosestIndex":257,"./xyCheck":306}],333:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyRealMaxYPoint = void 0;
const xGetTargetIndex_1 = require("../x/xGetTargetIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * Find the closest minimum going down hill
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 * @returns - An object with the x/y value
 */
function xyRealMaxYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    const targetIndex = (0, xGetTargetIndex_1.xGetTargetIndex)(x, options);
    // interpolation to a sin() function
    if (y[targetIndex - 1] > 0 &&
        y[targetIndex + 1] > 0 &&
        y[targetIndex] >= y[targetIndex - 1] &&
        y[targetIndex] >= y[targetIndex + 1]) {
        let alpha = 20 * Math.log10(y[targetIndex - 1]);
        let beta = 20 * Math.log10(y[targetIndex]);
        let gamma = 20 * Math.log10(y[targetIndex + 1]);
        let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);
        return {
            x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,
            y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,
            index: targetIndex,
        };
    }
    else {
        return {
            x: x[targetIndex],
            y: y[targetIndex],
            index: targetIndex,
        };
    }
}
exports.xyRealMaxYPoint = xyRealMaxYPoint;

},{"../x/xGetTargetIndex":259,"./xyCheck":306}],334:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyRealMinYPoint = void 0;
const xGetTargetIndex_1 = require("../x/xGetTargetIndex");
const xyCheck_1 = require("./xyCheck");
/**
 * XyRealMinYPoint.
 *
 * @param data - Data.
 * @param options - Options.
 */
function xyRealMinYPoint(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    const targetIndex = (0, xGetTargetIndex_1.xGetTargetIndex)(x, options);
    // interpolation to a sin() function
    if (y[targetIndex - 1] < 0 &&
        y[targetIndex + 1] < 0 &&
        y[targetIndex] <= y[targetIndex - 1] &&
        y[targetIndex] <= y[targetIndex + 1]) {
        let alpha = 20 * Math.log10(-y[targetIndex - 1]);
        let beta = 20 * Math.log10(-y[targetIndex]);
        let gamma = 20 * Math.log10(-y[targetIndex + 1]);
        let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);
        return {
            x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,
            y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,
            index: targetIndex,
        };
    }
    else {
        return {
            x: x[targetIndex],
            y: y[targetIndex],
            index: targetIndex,
        };
    }
}
exports.xyRealMinYPoint = xyRealMinYPoint;

},{"../x/xGetTargetIndex":259,"./xyCheck":306}],335:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyReduce = void 0;
const xFindClosestIndex_1 = require("../x/xFindClosestIndex");
const zonesNormalize_1 = require("../zones/zonesNormalize");
const xyCheck_1 = require("./xyCheck");
/**
 * XyReduce the number of points while keeping visually the same noise. Practical to
 * display many spectra as SVG. If you want a similar looking spectrum you should still however generate 4x the nbPoints that is being displayed.
 * SHOULD NOT BE USED FOR DATA PROCESSING !!!
 * You should rather use ml-xy-equally-spaced to make further processing
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 */
function xyReduce(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let { from = x[0], to = x[x.length - 1], nbPoints = 4001, optimize = false, zones = [], } = options;
    zones = (0, zonesNormalize_1.zonesNormalize)(zones, { from, to });
    if (zones.length === 0)
        zones = [{ from, to }]; // we take everything
    // for each zone we should know the first index, the last index and the number of points
    const internalZones = zones;
    let totalPoints = 0;
    for (let zone of internalZones) {
        zone.fromIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, zone.from);
        zone.toIndex = (0, xFindClosestIndex_1.xFindClosestIndex)(x, zone.to);
        if (zone.fromIndex > 0 && x[zone.fromIndex] > zone.from) {
            zone.fromIndex--;
        }
        if (zone.toIndex < x.length - 1 && x[zone.toIndex] < zone.to) {
            zone.toIndex++;
        }
        zone.nbPoints = zone.toIndex - zone.fromIndex + 1;
        totalPoints += zone.nbPoints;
    }
    // we calculate the number of points per zone that we should keep
    if (totalPoints > nbPoints) {
        // need to xyReduce number of points
        let ratio = nbPoints / totalPoints;
        let currentTotal = 0;
        for (let i = 0; i < internalZones.length - 1; i++) {
            const zone = internalZones[i];
            zone.nbPoints = Math.round(zone.nbPoints * ratio);
            currentTotal += zone.nbPoints;
        }
        internalZones[internalZones.length - 1].nbPoints = nbPoints - currentTotal;
    }
    else {
        let newX = new Float64Array(totalPoints);
        let newY = new Float64Array(totalPoints);
        let index = 0;
        for (let zone of internalZones) {
            for (let i = zone.fromIndex; i < zone.toIndex + 1; i++) {
                newX[index] = x[i];
                newY[index] = y[i];
                index++;
            }
        }
        return {
            x: newX,
            y: newY,
        };
    }
    let newX = [];
    let newY = [];
    for (let zone of internalZones) {
        if (!zone.nbPoints)
            continue;
        appendFromTo(zone.fromIndex, zone.toIndex, zone.nbPoints);
    }
    return { x: newX, y: newY };
    /**
     * AppendFromTo.
     *
     * @param fromIndex - From.
     * @param  toIndex - To.
     * @param zoneNbPoints - NbPoints.
     */
    function appendFromTo(fromIndex, toIndex, zoneNbPoints) {
        if (zoneNbPoints === 1) {
            newX.push(x[Math.round((toIndex - fromIndex) / 2)]);
            newY.push(y[Math.round((toIndex - fromIndex) / 2)]);
            return;
        }
        if (zoneNbPoints === 2) {
            newX.push(x[fromIndex], x[toIndex]);
            newY.push(y[fromIndex], y[toIndex]);
            return;
        }
        newX.push(x[fromIndex]);
        newY.push(y[fromIndex]);
        if (zoneNbPoints % 2 === 0) {
            zoneNbPoints = zoneNbPoints / 2 + 1;
        }
        else {
            zoneNbPoints = (zoneNbPoints - 1) / 2 + 1;
        }
        // we will need to make some kind of min / max because there are too many points
        // we will always keep the first point and the last point
        let slot = (x[toIndex] - x[fromIndex]) / (zoneNbPoints - 1);
        let currentX = x[fromIndex] + slot;
        let first = true;
        let minY = Number.POSITIVE_INFINITY;
        let xyMaxY = Number.NEGATIVE_INFINITY;
        for (let i = fromIndex + 1; i <= toIndex; i++) {
            if (first) {
                minY = y[i];
                xyMaxY = y[i];
                first = false;
            }
            else {
                if (y[i] < minY)
                    minY = y[i];
                if (y[i] > xyMaxY)
                    xyMaxY = y[i];
            }
            if (x[i] >= currentX || i === toIndex) {
                if (optimize) {
                    if (minY > newY[newX.length - 1]) {
                        // we can skip the intermediate value
                    }
                    else if (xyMaxY < newY[newX.length - 1]) {
                        // we can skip the intermediate value
                        xyMaxY = minY;
                    }
                    else {
                        newX.push(currentX - slot / 2);
                        newY.push(minY);
                    }
                }
                else {
                    newX.push(currentX - slot / 2);
                    newY.push(minY);
                }
                newX.push(currentX);
                newY.push(xyMaxY);
                currentX += slot;
                first = true;
            }
        }
    }
}
exports.xyReduce = xyReduce;

},{"../x/xFindClosestIndex":257,"../zones/zonesNormalize":362,"./xyCheck":306}],336:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyRolling = void 0;
const xRolling_1 = require("../x/xRolling");
const xRollingAverage_1 = require("../x/xRollingAverage");
/**
 * This function calculates a rolling average.
 * This methods will recalculate the x values by using xRollingAverage
 *
 * @param data - array of points {x,y}
 * @param fct - callback function that from an array returns a value.
 * @param options - options
 */
function xyRolling(data, fct, options = {}) {
    let { x, y } = data;
    y = (0, xRolling_1.xRolling)(y, fct, options);
    if (x.length !== y.length) {
        x = (0, xRollingAverage_1.xRollingAverage)(x, options);
    }
    return { x, y };
}
exports.xyRolling = xyRolling;

},{"../x/xRolling":286,"../x/xRollingAverage":287}],337:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xySetYValue = void 0;
const zonesNormalize_1 = require("../zones/zonesNormalize");
const xyCheck_1 = require("./xyCheck");
/**
 * Set a value (default 0) to specific zones.
 *
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - options
 * @returns - Array of points
 */
function xySetYValue(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let { zones, value = 0 } = options;
    if (!Array.isArray(zones) || zones.length === 0) {
        return data;
    }
    zones = (0, zonesNormalize_1.zonesNormalize)(zones);
    const newX = x.slice();
    const newY = y.slice();
    let currentZone = zones[0];
    let position = 0;
    loop: for (let i = 0; i < x.length; i++) {
        while (currentZone.to < x[i]) {
            position++;
            currentZone = zones[position];
            if (!currentZone) {
                i = x.length;
                break loop;
            }
        }
        if (x[i] >= currentZone.from) {
            newY[i] = value;
        }
    }
    return { x: newX, y: newY };
}
exports.xySetYValue = xySetYValue;

},{"../zones/zonesNormalize":362,"./xyCheck":306}],338:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xySortX = void 0;
const xIsMonotonic_1 = require("../x/xIsMonotonic");
/**
 * This function performs a quick sort of the x array while transforming the y array to preserve the coordinates.
 *
 * @param data - Object that contains property x (Array) and y (Array)
 */
function xySortX(data) {
    const { x, y } = data;
    if ((0, xIsMonotonic_1.xIsMonotonic)(x) && x.length > 1) {
        if (x[0] < x[1]) {
            return {
                x: Float64Array.from(x),
                y: Float64Array.from(y),
            };
        }
        else {
            return {
                x: Float64Array.from(x).reverse(),
                y: Float64Array.from(y).reverse(),
            };
        }
    }
    let xyObject = x
        .map((val, index) => ({
        x: val,
        y: y[index],
    }))
        .sort((a, b) => a.x - b.x);
    let response = {
        x: new Float64Array(x.length),
        y: new Float64Array(y.length),
    };
    for (let i = 0; i < x.length; i++) {
        response.x[i] = xyObject[i].x;
        response.y[i] = xyObject[i].y;
    }
    return response;
}
exports.xySortX = xySortX;

},{"../x/xIsMonotonic":263}],339:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyToXYArray = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * Convert a DataXY to an array of array containing x,y
 *
 * @param data - array of points {x,y}
 */
function xyToXYArray(data) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let objectArray = [];
    for (let i = 0; i < x.length; i++) {
        objectArray.push([x[i], y[i]]);
    }
    return objectArray;
}
exports.xyToXYArray = xyToXYArray;

},{"./xyCheck":306}],340:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyToXYObject = void 0;
const xyCheck_1 = require("./xyCheck");
/**
 * XyToXYObject.
 *
 * @param data - Array of points {x,y}.
 */
function xyToXYObject(data) {
    (0, xyCheck_1.xyCheck)(data);
    const { x, y } = data;
    let objectArray = [];
    for (let i = 0; i < x.length; i++) {
        objectArray.push({ x: x[i], y: y[i] });
    }
    return objectArray;
}
exports.xyToXYObject = xyToXYObject;

},{"./xyCheck":306}],341:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyUniqueX = void 0;
const xyCheck_1 = require("./xyCheck");
const xySortX_1 = require("./xySortX");
/**
 * Ensure x values are unique
 *
 * @param data - Object that contains property x (Array) and y (Array)
 * @param options - Object containing a property algorithm (can be 'sum' or 'average', the latter being the default value), and a property isSorted (boolean indicating if the x-array is sorted).
 */
function xyUniqueX(data, options = {}) {
    (0, xyCheck_1.xyCheck)(data);
    const { algorithm = 'average', isSorted = true } = options;
    if (!isSorted) {
        data = (0, xySortX_1.xySortX)(data);
    }
    switch (algorithm) {
        case 'average':
            return average(data);
        case 'sum':
            return sum(data);
        default:
            throw new Error(`xyUniqueX: unknown algorithm: ${algorithm}`);
    }
}
exports.xyUniqueX = xyUniqueX;
/**
 * Average.
 *
 * @param data - Input.
 * @returns Result.
 */
function average(data) {
    let x = [];
    let y = [];
    let cumulativeY = data.y[0];
    let divider = 1;
    for (let i = 1; i < data.x.length; i++) {
        if (!(data.x[i] === data.x[i - 1])) {
            x.push(data.x[i - 1]);
            y.push(cumulativeY / divider);
            cumulativeY = 0;
            divider = 0;
        }
        cumulativeY += data.y[i];
        divider++;
    }
    x.push(data.x[data.x.length - 1]);
    y.push(cumulativeY / divider);
    return { x, y };
}
/**
 * Sum.
 *
 * @param data - Input.
 * @returns Result.
 */
function sum(data) {
    let x = [];
    let y = [];
    let cumulativeY = data.y[0];
    for (let i = 1; i < data.x.length; i++) {
        if (!(data.x[i] === data.x[i - 1])) {
            x.push(data.x[i - 1]);
            y.push(cumulativeY);
            cumulativeY = 0;
        }
        cumulativeY += data.y[i];
    }
    x.push(data.x[data.x.length - 1]);
    y.push(cumulativeY);
    return { x, y };
}

},{"./xyCheck":306,"./xySortX":338}],342:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyWeightedMerge = void 0;
/**
 * Merge abscissas values on similar ordinates and weight the group of abscissas
 *
 * @param data - object containing 2 properties x and y
 * @param options - options
 * @return array of merged and weighted points
 */
function xyWeightedMerge(data, options = {}) {
    const { x, y } = data;
    const { groupWidth = 0.001 } = options;
    let merged = { x: [], y: [] };
    let weightedAbscissa = { x: [], y: [] };
    let size = 0;
    let index = 0;
    while (index < x.length) {
        if (size === 0 || x[index] - merged.x[size - 1] > groupWidth) {
            weightedAbscissa.x.push(x[index] * y[index]);
            weightedAbscissa.y.push(y[index]);
            merged.x.push(x[index]);
            merged.y.push(y[index]);
            index++;
            size++;
        }
        else {
            weightedAbscissa.x[size - 1] += x[index] * y[index];
            weightedAbscissa.y[size - 1] += y[index];
            merged.x[size - 1] = x[index];
            merged.y[size - 1] += y[index];
            index++;
        }
    }
    for (let i = 0; i < merged.x.length; i++) {
        merged.x[i] = weightedAbscissa.x[i] / weightedAbscissa.y[i];
    }
    return merged;
}
exports.xyWeightedMerge = xyWeightedMerge;

},{}],343:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xy2ToXY = void 0;
/**
 * Convert an array of XY arrays to a DataXY object containing x,y arrays
 *
 * @param data - array of arrays [[x,y],[x,y],...]
 */
function xy2ToXY(data) {
    const xy2 = { x: [], y: [] };
    for (let xyValue of data) {
        xy2.x.push(xyValue[0]);
        xy2.y.push(xyValue[1]);
    }
    return xy2;
}
exports.xy2ToXY = xy2ToXY;

},{}],344:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSlots = void 0;
/**
 * GetSlots.
 *
 * @param data - data.
 * @param options - Options.
 */
function getSlots(data, options = {}) {
    const { delta = 1 } = options;
    const deltaIsFunction = typeof delta === 'function';
    let possibleXs = Float64Array.from([].concat(...data.map((spectrum) => spectrum.x))).sort();
    if (possibleXs.length === 0) {
        throw new Error('xyArrayMerge can not process empty arrays');
    }
    let currentSlot = {
        from: possibleXs[0],
        to: possibleXs[0],
        average: possibleXs[0],
        sum: possibleXs[0],
        number: 1,
    };
    let slots = [currentSlot];
    for (let i = 1; i < possibleXs.length; i++) {
        let currentDelta = deltaIsFunction ? delta(possibleXs[i]) : delta;
        if (possibleXs[i] - currentSlot.to <= currentDelta) {
            currentSlot.to = possibleXs[i];
            currentSlot.number++;
            currentSlot.sum += possibleXs[i];
            currentSlot.average = currentSlot.sum / currentSlot.number;
        }
        else {
            currentSlot = {
                from: possibleXs[i],
                to: possibleXs[i],
                average: possibleXs[i],
                sum: possibleXs[i],
                number: 1,
            };
            slots.push(currentSlot);
        }
    }
    return slots;
}
exports.getSlots = getSlots;

},{}],345:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSlotsToFirst = void 0;
const xyArrayWeightedMerge_1 = require("../xyArrayWeightedMerge");
/**
 * GetSlotsToFirst.
 *
 * @param data - data.
 * @param options - Options.
 */
function getSlotsToFirst(data, options = {}) {
    const { delta = 1 } = options;
    const deltaIsFunction = typeof delta === 'function';
    let firstXs = data[0].x;
    let slots = [];
    // we first create the slots based on the first spectrum
    for (const element of firstXs) {
        let currentDelta = deltaIsFunction ? delta(element) : delta;
        slots.push({
            from: element - currentDelta,
            to: element + currentDelta,
            value: element,
        });
    }
    let otherXs = (0, xyArrayWeightedMerge_1.xyArrayWeightedMerge)(data.slice(1), options).x;
    let currentPosition = 0;
    for (let slot of slots) {
        while (otherXs[currentPosition] < slot.to &&
            currentPosition < otherXs.length) {
            if (otherXs[currentPosition] < slot.from) {
                let currentDelta = deltaIsFunction
                    ? delta(otherXs[currentPosition])
                    : delta;
                slots.push({
                    from: otherXs[currentPosition] - currentDelta,
                    to: otherXs[currentPosition] + currentDelta,
                    value: otherXs[currentPosition],
                });
            }
            currentPosition++;
        }
    }
    for (let i = currentPosition; i < otherXs.length; i++) {
        let currentDelta = deltaIsFunction ? delta(otherXs[i]) : delta;
        slots.push({
            from: otherXs[i] - currentDelta,
            to: otherXs[i] + currentDelta,
            value: otherXs[i],
        });
    }
    slots.sort((a, b) => a.value - b.value);
    // we prevent slots overlap in the first spectrum
    for (let i = 0; i < slots.length - 1; i++) {
        if (slots[i].to > slots[i + 1].from) {
            let middle = (slots[i].value + slots[i + 1].value) / 2;
            slots[i].to = middle;
            slots[i + 1].from = middle;
        }
    }
    return slots;
}
exports.getSlotsToFirst = getSlotsToFirst;

},{"../xyArrayWeightedMerge":349}],346:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyArrayAlign = void 0;
const xyJoinX_1 = require("../xy/xyJoinX");
const getSlots_1 = require("./utils/getSlots");
/**
 * Aligns data, can be used for spectra
 *
 * @param data - data
 * @param options - Options
 */
function xyArrayAlign(data, options = {}) {
    const { delta = 1, requiredY = false } = options;
    data = data.map((spectrum) => (0, xyJoinX_1.xyJoinX)(spectrum, { delta }));
    const slots = (0, getSlots_1.getSlots)(data, options);
    let x = Float64Array.from(slots.map((slot) => slot.average));
    let ys = new Array(data.length).fill(0).map(() => new Float64Array(x.length));
    let positions = new Uint32Array(data.length);
    for (let i = 0; i < slots.length; i++) {
        let slot = slots[i];
        for (let j = 0; j < data.length; j++) {
            let spectrum = data[j];
            while (positions[j] < spectrum.x.length &&
                spectrum.x[positions[j]] <= slot.to) {
                ys[j][i] += spectrum.y[positions[j]];
                positions[j]++;
            }
        }
    }
    if (requiredY)
        return filterRequiredY(x, ys);
    return { x, ys };
}
exports.xyArrayAlign = xyArrayAlign;
function filterRequiredY(x, ys) {
    const newX = [];
    const newYs = new Array(ys.length).fill(0).map(() => []);
    for (let i = 0; i < x.length; i++) {
        if (ys.every((y) => y[i] !== 0)) {
            newX.push(x[i]);
            for (let j = 0; j < ys.length; j++) {
                newYs[j].push(ys[j][i]);
            }
        }
    }
    return { x: newX, ys: newYs };
}

},{"../xy/xyJoinX":321,"./utils/getSlots":344}],347:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyArrayAlignToFirst = void 0;
const getSlotsToFirst_1 = require("./utils/getSlotsToFirst");
/**
 * We align all the data/spectra to the first array of X.
 * The alignment is based on the X values of the first spectrum and the `delta` error allowed. If some x values are missing in the first spectrum we will add them
 *
 * @param data data
 * @param options options
 */
function xyArrayAlignToFirst(data, options = {}) {
    const slots = (0, getSlotsToFirst_1.getSlotsToFirst)(data, options);
    let x = Float64Array.from(slots.map((slot) => slot.value));
    let ys = new Array(data.length).fill(0).map(() => new Float64Array(x.length));
    let positions = new Uint32Array(data.length);
    for (let i = 0; i < slots.length; i++) {
        let slot = slots[i];
        for (let j = 0; j < data.length; j++) {
            let spectrum = data[j];
            while (positions[j] < spectrum.x.length &&
                spectrum.x[positions[j]] < slot.to) {
                ys[j][i] += spectrum.y[positions[j]];
                positions[j]++;
            }
        }
    }
    return { x, ys };
}
exports.xyArrayAlignToFirst = xyArrayAlignToFirst;

},{"./utils/getSlotsToFirst":345}],348:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyArrayMerge = void 0;
const xyJoinX_1 = require("../xy/xyJoinX");
const getSlots_1 = require("./utils/getSlots");
/**
 * Merge DataXY
 * We have an array of DataXY and the goal is to merge all the values that are the closest possible
 *
 * @param data - data
 * @param options - Options
 */
function xyArrayMerge(data, options = {}) {
    const { delta = 1 } = options;
    // we start by checking that the data/spectra don't have peaks too close and we simplify them
    data = data.map((spectrum) => (0, xyJoinX_1.xyJoinX)(spectrum, { delta }));
    // at first we will calculate the X values (simple mean)
    let slots = (0, getSlots_1.getSlots)(data, options);
    let x = Float64Array.from(slots.map((slot) => slot.average));
    let y = new Float64Array(x.length);
    let positions = new Uint32Array(data.length);
    for (let i = 0; i < slots.length; i++) {
        let slot = slots[i];
        for (let j = 0; j < data.length; j++) {
            let spectrum = data[j];
            while (positions[j] < spectrum.x.length &&
                spectrum.x[positions[j]] <= slot.to) {
                y[i] += spectrum.y[positions[j]];
                positions[j]++;
            }
        }
    }
    return { x, y };
}
exports.xyArrayMerge = xyArrayMerge;

},{"../xy/xyJoinX":321,"./utils/getSlots":344}],349:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyArrayWeightedMerge = void 0;
/**
 * Merge DataXY
 * We have an array of DataXY and the goal is to merge all the values for which the deltaX is small or equal to delta.
 * X values are weighted average
 *
 * @param data - data
 * @param options - Options
 */
function xyArrayWeightedMerge(data, options = {}) {
    let { delta = 1 } = options;
    if (typeof delta === 'number') {
        let deltaNumber = delta;
        delta = () => deltaNumber;
    }
    data = data.filter((spectrum) => spectrum.x.length > 0);
    if (data.length === 0)
        return { x: [], y: [] };
    let x = [];
    let y = [];
    const positions = new Array(data.length).fill(0);
    const point = { x: 0, y: 0 };
    nextValue(data, positions, point);
    let slot = {
        maxX: point.x + delta(point.x),
        sumY: point.y,
        sumXY: point.y * point.x,
    };
    while (data.length > 0) {
        nextValue(data, positions, point);
        let sameSlot = point.x <= slot.maxX;
        if (!sameSlot) {
            if (slot.sumY > 0) {
                x.push(slot.sumXY / slot.sumY);
                y.push(slot.sumY);
            }
            slot.sumY = 0;
            slot.sumXY = 0;
        }
        slot.sumY += point.y;
        slot.sumXY += point.x * point.y;
        slot.maxX = point.x + delta(point.x);
        if (data.length === 0 && slot.sumY > 0) {
            x.push(slot.sumXY / slot.sumY);
            y.push(slot.sumY);
        }
    }
    return { x, y };
}
exports.xyArrayWeightedMerge = xyArrayWeightedMerge;
/**
 * NextValue.
 *
 * @param data - data.
 * @param positions - Positions array.
 * @param point - Point.
 */
function nextValue(data, positions, point) {
    let minIndex = 0;
    let minX = data[0].x[positions[0]];
    for (let i = 1; i < data.length; i++) {
        let currentX = data[i].x[positions[i]];
        if (currentX < minX) {
            minX = currentX;
            minIndex = i;
        }
    }
    point.x = minX;
    point.y = data[minIndex].y[positions[minIndex]];
    positions[minIndex]++;
    if (positions[minIndex] === data[minIndex].x.length) {
        positions.splice(minIndex, 1);
        data.splice(minIndex, 1);
    }
}

},{}],350:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectBestPoints = void 0;
const xyObjectMaxXPoint_1 = require("./xyObjectMaxXPoint");
const xyObjectMinXPoint_1 = require("./xyObjectMinXPoint");
/**
 * Filter the array by taking the higher points (max y value) and only.
 * Keep one per slot. There are 2 different slots, the smallest one will have the
 * new property `close` to true
 *
 * @param points - array of all the points
 * @param options - Options
 * @returns - copy of points with 'close' property
 */
function xyObjectBestPoints(points, options = {}) {
    const { from = (0, xyObjectMinXPoint_1.xyObjectMinXPoint)(points).x, to = (0, xyObjectMaxXPoint_1.xyObjectMaxXPoint)(points).x, limit = 20, threshold = 0.01, numberCloseSlots = 50, numberSlots = 10, } = options;
    let slot = (to - from) / numberSlots;
    let closeSlot = (to - from) / numberCloseSlots;
    let selected = points
        .filter((point) => point.x >= from && point.x <= to)
        .map((point) => {
        return {
            point,
            monoisotopic: false,
        };
    });
    selected = selected.sort((a, b) => {
        if (a.monoisotopic && !b.monoisotopic)
            return -1;
        if (b.monoisotopic && !a.monoisotopic)
            return 1;
        return b.point.y - a.point.y;
    });
    let toReturn = [];
    if (selected.length === 0)
        return [];
    let minY = selected[0].point.y * threshold;
    peakLoop: for (let item of selected) {
        if (item.point.y < minY) {
            if (item.monoisotopic) {
                continue;
            }
            else {
                break;
            }
        }
        let close = false;
        for (let existing of toReturn) {
            if (Math.abs(existing.x - item.point.x) < closeSlot) {
                continue peakLoop;
            }
            if (Math.abs(existing.x - item.point.x) < slot) {
                close = true;
            }
        }
        let newPeak = JSON.parse(JSON.stringify(item.point));
        newPeak.close = close;
        toReturn.push(newPeak);
        if (toReturn.length === limit)
            break;
    }
    return toReturn.sort((a, b) => a.x - b.x);
}
exports.xyObjectBestPoints = xyObjectBestPoints;

},{"./xyObjectMaxXPoint":353,"./xyObjectMinXPoint":355}],351:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectCheck = void 0;
/**
 * Throw an error in no an object of x,y arrays
 *
 * @param points - list of points
 */
function xyObjectCheck(points = []) {
    if (!Array.isArray(points)) {
        throw new Error('ArrayPoints must be an array of {x,y} object');
    }
    if (points.length > 0 &&
        (points[0].x === undefined || points[0].y === undefined)) {
        throw new Error('ArrayPoints must be an array of {x,y} object');
    }
}
exports.xyObjectCheck = xyObjectCheck;

},{}],352:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectJoinX = void 0;
/**
 * xyObjectJoinX.
 *
 * @param points - Array of growing points {x,y}.
 * @param options - Options.
 */
function xyObjectJoinX(points, options = {}) {
    const { xError = Number.EPSILON } = options;
    // when we join we will use the center of mass
    let result = [];
    let current = {
        x: Number.MIN_SAFE_INTEGER,
        y: 0,
    };
    for (let point of points) {
        if (point.x - current.x <= xError) {
            // weighted sum
            if (current.y !== 0 || point.y !== 0) {
                current.x =
                    (point.y / (current.y + point.y)) * (point.x - current.x) + current.x;
                current.y += point.y;
            }
        }
        else {
            current = {
                x: point.x,
                y: point.y,
            };
            result.push(current);
        }
    }
    return result;
}
exports.xyObjectJoinX = xyObjectJoinX;

},{}],353:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectMaxXPoint = void 0;
const xyObjectCheck_1 = require("./xyObjectCheck");
/**
 * Finds the max x value and return a {x,y,index} point
 *
 * @param points - Object that contains property x (an ordered increasing array) and y (an array)
 */
function xyObjectMaxXPoint(points = []) {
    (0, xyObjectCheck_1.xyObjectCheck)(points);
    if (points.length === 0)
        return { x: 0, y: 0 };
    let current = {
        x: points[0].x,
        y: points[0].y,
        index: 0,
    };
    for (let i = 1; i < points.length; i++) {
        if (points[i].x > current.x) {
            current = {
                x: points[i].x,
                y: points[i].y,
                index: i,
            };
        }
    }
    return current;
}
exports.xyObjectMaxXPoint = xyObjectMaxXPoint;

},{"./xyObjectCheck":351}],354:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectMaxYPoint = void 0;
const xyObjectCheck_1 = require("./xyObjectCheck");
/**
 * Finds the max y value and return a {x,y,index} point
 *
 * @param points - Object that contains property x (an ordered increasing array) and y (an array)
 */
function xyObjectMaxYPoint(points = []) {
    (0, xyObjectCheck_1.xyObjectCheck)(points);
    if (points.length === 0)
        return { x: 0, y: 0 };
    let current = {
        x: points[0].x,
        y: points[0].y,
        index: 0,
    };
    for (let i = 1; i < points.length; i++) {
        if (points[i].y > current.y) {
            current = {
                x: points[i].x,
                y: points[i].y,
                index: i,
            };
        }
    }
    return current;
}
exports.xyObjectMaxYPoint = xyObjectMaxYPoint;

},{"./xyObjectCheck":351}],355:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectMinXPoint = void 0;
const xyObjectCheck_1 = require("./xyObjectCheck");
/**
 * Finds the min x value and return a {x,y,index} point
 *
 * @param points - Object that contains property x (an ordered increasing array) and y (an array)
 */
function xyObjectMinXPoint(points = []) {
    (0, xyObjectCheck_1.xyObjectCheck)(points);
    if (points.length === 0)
        return { x: 0, y: 0 };
    let current = {
        x: points[0].x,
        y: points[0].y,
        index: 0,
    };
    for (let i = 1; i < points.length; i++) {
        if (points[i].x < current.x) {
            current = {
                x: points[i].x,
                y: points[i].y,
                index: i,
            };
        }
    }
    return current;
}
exports.xyObjectMinXPoint = xyObjectMinXPoint;

},{"./xyObjectCheck":351}],356:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectMinYPoint = void 0;
const xyObjectCheck_1 = require("./xyObjectCheck");
/**
 * Finds the min y value and return a {x,y,index} point
 *
 * @param points - Object that contains property x (an ordered increasing array) and y (an array)
 */
function xyObjectMinYPoint(points = []) {
    (0, xyObjectCheck_1.xyObjectCheck)(points);
    if (points.length === 0)
        return { x: 0, y: 0 };
    let current = {
        x: points[0].x,
        y: points[0].y,
        index: 0,
    };
    for (let i = 1; i < points.length; i++) {
        if (points[i].y < current.y) {
            current = {
                x: points[i].x,
                y: points[i].y,
                index: i,
            };
        }
    }
    return current;
}
exports.xyObjectMinYPoint = xyObjectMinYPoint;

},{"./xyObjectCheck":351}],357:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectSlotX = void 0;
/**
 * XyObjectSlotX
 *
 * @param points - Array of growing points {x,y}.
 * @param options - Options.
 */
function xyObjectSlotX(points, options = {}) {
    const { slotWidth = 1 } = options;
    const halfSlot = slotWidth / 2;
    // when we join we will use the center of mass
    let result = [];
    let current = {
        x: Number.NEGATIVE_INFINITY,
        y: 0,
    };
    for (let point of points) {
        let slot = point.x - ((point.x + halfSlot) % slotWidth) + halfSlot;
        if (Math.abs(current.x - slot) > Number.EPSILON) {
            current = {
                x: slot,
                y: 0,
            };
            result.push(current);
        }
        current.y += point.y;
    }
    return result;
}
exports.xyObjectSlotX = xyObjectSlotX;

},{}],358:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectSortX = void 0;
/**
 * Sorts an array of points
 *
 * @param points - array of points {x,y}
 * @returns - sorted array of points {x,y}
 */
function xyObjectSortX(points) {
    return points.sort((a, b) => a.x - b.x);
}
exports.xyObjectSortX = xyObjectSortX;

},{}],359:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectSumY = void 0;
const xyObjectCheck_1 = require("./xyObjectCheck");
/**
 * Calculate the sum of Y values
 *
 * @param points - Object that contains property x and y (an array)
 */
function xyObjectSumY(points = []) {
    (0, xyObjectCheck_1.xyObjectCheck)(points);
    let sum = 0;
    for (let point of points) {
        sum += point.y;
    }
    return sum;
}
exports.xyObjectSumY = xyObjectSumY;

},{"./xyObjectCheck":351}],360:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectToXY = void 0;
/**
 * XyObjectToXY.
 *
 * @param points - Array of points {x,y}.
 */
function xyObjectToXY(points) {
    return {
        x: points.map((entry) => entry.x),
        y: points.map((entry) => entry.y),
    };
}
exports.xyObjectToXY = xyObjectToXY;

},{}],361:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zoneToX = void 0;
/**
 * Deprecated !!! Should use utils/createFromToArray
 *
 * @param zone.
 * @param size - Size.
 * @returns - Array of float.
 */
function zoneToX(zone, size) {
    const { from, to } = zone;
    let array = new Float64Array(size);
    let step = (to - from) / (size - 1);
    for (let i = 0; i < size; i++) {
        array[i] = from + step * i;
    }
    return array;
}
exports.zoneToX = zoneToX;

},{}],362:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zonesNormalize = void 0;
/**
 * Normalize an array of zones:
 * - ensure than from < to
 * - merge overlapping zones
 * - deal with exclusions zones
 * - if no zones is specified add one between -Infinity and +Infinity
 * @param zones - array of zones
 * @param options - options
 * @returns array of zones
 */
function zonesNormalize(zones = [], options = {}) {
    let { from = Number.NEGATIVE_INFINITY, to = Number.POSITIVE_INFINITY, exclusions = [], } = options;
    if (from > to)
        [from, to] = [to, from];
    zones = JSON.parse(JSON.stringify(zones)).map((zone) => zone.from > zone.to ? { from: zone.to, to: zone.from } : zone);
    zones = zones.sort((a, b) => {
        if (a.from !== b.from)
            return a.from - b.from;
        return a.to - b.to;
    });
    if (zones.length === 0) {
        zones.push({ from, to });
    }
    for (const zone of zones) {
        if (from > zone.from)
            zone.from = from;
        if (to < zone.to)
            zone.to = to;
    }
    zones = zones.filter((zone) => zone.from <= zone.to);
    if (zones.length === 0)
        return [];
    let currentZone = zones[0];
    let beforeExclusionsZones = [currentZone];
    for (let i = 1; i < zones.length; i++) {
        let zone = zones[i];
        if (zone.from <= currentZone.to) {
            if (currentZone.to < zone.to) {
                currentZone.to = zone.to;
            }
        }
        else {
            currentZone = zone;
            beforeExclusionsZones.push(currentZone);
        }
    }
    if (exclusions.length === 0)
        return beforeExclusionsZones;
    const normalizedExclusions = zonesNormalize(exclusions);
    let currentExclusionIndex = 0;
    const results = [];
    let counter = 0;
    for (let zoneIndex = 0; zoneIndex < beforeExclusionsZones.length; zoneIndex++) {
        if (counter++ > 5)
            break;
        const zone = beforeExclusionsZones[zoneIndex];
        if (currentExclusionIndex === normalizedExclusions.length) {
            // we analysed all the exclusion zones
            results.push(zone);
            continue;
        }
        while (currentExclusionIndex < normalizedExclusions.length &&
            normalizedExclusions[currentExclusionIndex].to <= zone.from) {
            currentExclusionIndex++;
        }
        if (currentExclusionIndex === normalizedExclusions.length) {
            // we analysed all the exclusion zones
            results.push(zone);
            continue;
        }
        if (zone.to < normalizedExclusions[currentExclusionIndex].from) {
            // no problems, not yet in exclusion
            results.push(zone);
            continue;
        }
        if (normalizedExclusions[currentExclusionIndex].to >= zone.to) {
            // could be totally excluded
            if (normalizedExclusions[currentExclusionIndex].from <= zone.from) {
                continue;
            }
            results.push({
                from: normalizedExclusions[currentExclusionIndex].to,
                to: zone.to,
            });
        }
        // we cut in the middle, we need to create more zones, annoying !
        if (normalizedExclusions[currentExclusionIndex].from > zone.from) {
            results.push({
                from: zone.from,
                to: normalizedExclusions[currentExclusionIndex].from,
            });
        }
        zone.from = normalizedExclusions[currentExclusionIndex].to;
        zoneIndex--;
    }
    return results;
}
exports.zonesNormalize = zonesNormalize;

},{}],363:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zonesWithPoints = void 0;
const zonesNormalize_1 = require("./zonesNormalize");
/**
 * Add the number of points per zone to reach a specified total
 *
 * @param zones - array of zones
 * @param numberOfPoints - total number of points to distribute between zones
 * @param options - options
 * @returns array of zones with points
 */
function zonesWithPoints(zones = [], 
/**
 * total number of points to distribute between zones
 * @default 10
 */
numberOfPoints = 10, options = {}) {
    if (zones.length === 0)
        return zones;
    let returnZones = (0, zonesNormalize_1.zonesNormalize)(zones, options);
    const totalSize = returnZones.reduce((previous, current) => {
        return previous + (current.to - current.from);
    }, 0);
    let unitsPerPoint = totalSize / numberOfPoints;
    let currentTotal = 0;
    for (let i = 0; i < returnZones.length - 1; i++) {
        let zone = returnZones[i];
        zone.numberOfPoints = Math.min(Math.round((zone.to - zone.from) / unitsPerPoint), numberOfPoints - currentTotal);
        currentTotal += zone.numberOfPoints;
    }
    let zone = returnZones[returnZones.length - 1];
    zone.numberOfPoints = numberOfPoints - currentTotal;
    return returnZones;
}
exports.zonesWithPoints = zonesWithPoints;

},{"./zonesNormalize":362}],364:[function(require,module,exports){
'use strict';
/**
 * Created by acastillo on 9/3/16.
 */

class TreeSet{

    constructor(compatator){
        this.length = 0;
        this.elements = [];
        if(compatator)
            this.compatator = compatator;
        else
            this.compatator = function(a, b){ return a - b };
    }

    size(){
        return this.elements.length;
    }

    last(){
        return this.elements[this.length-1];
    }

    first(){
        return this.elements[0];
    }

    isEmpty(){
        return this.size()===0;
    }

    pollLast(){
        if(this.length>0){
            this.length--;
            return this.elements.splice(this.length, 1);
        }
        return null;
    }

    pollFirst(){
        if(this.length>0) {
            this.length--;
            return this.elements.splice(0, 1);
        }
        return null;
    }

    add(element){
        let index = this.binarySearch(element);
        if(index < 0){
            index = -index-1;
        }
        this.elements.splice(index, 0, element);
        this.length++;
    }

    /**
     * Performs a binary search of value in array
     * @param {number[]} array - Array in which value will be searched. It must be sorted.
     * @param {number} value - Value to search in array
     * @return {number} If value is found, returns its index in array. Otherwise, returns a negative number indicating where the value should be inserted: -(index + 1)
     */
    binarySearch(value) {
        var low = 0;
        var high = this.elements.length - 1;

        while (low <= high) {
            var mid = (low + high) >>> 1;
            var midValue = this.elements[mid];
            var cmp = this.compatator(midValue, value);
            if (cmp < 0) {
                low = mid + 1;
            } else if (cmp > 0) {
                high = mid - 1;
            } else {
                return mid;
            }
        }

        return -(low + 1);
    }
}

module.exports = TreeSet;
},{}],365:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LOOP = 8;
const FLOAT_MUL = 1 / 16777216;
const sh1 = 15;
const sh2 = 18;
const sh3 = 11;
function multiply_uint32(n, m) {
    n >>>= 0;
    m >>>= 0;
    const nlo = n & 0xffff;
    const nhi = n - nlo;
    return (((nhi * m) >>> 0) + nlo * m) >>> 0;
}
class XSadd {
    constructor(seed = Date.now()) {
        this.state = new Uint32Array(4);
        this.init(seed);
        this.random = this.getFloat.bind(this);
    }
    /**
     * Returns a 32-bit integer r (0 <= r < 2^32)
     */
    getUint32() {
        this.nextState();
        return (this.state[3] + this.state[2]) >>> 0;
    }
    /**
     * Returns a floating point number r (0.0 <= r < 1.0)
     */
    getFloat() {
        return (this.getUint32() >>> 8) * FLOAT_MUL;
    }
    init(seed) {
        if (!Number.isInteger(seed)) {
            throw new TypeError('seed must be an integer');
        }
        this.state[0] = seed;
        this.state[1] = 0;
        this.state[2] = 0;
        this.state[3] = 0;
        for (let i = 1; i < LOOP; i++) {
            this.state[i & 3] ^=
                (i +
                    multiply_uint32(1812433253, this.state[(i - 1) & 3] ^ ((this.state[(i - 1) & 3] >>> 30) >>> 0))) >>>
                    0;
        }
        this.periodCertification();
        for (let i = 0; i < LOOP; i++) {
            this.nextState();
        }
    }
    periodCertification() {
        if (this.state[0] === 0 &&
            this.state[1] === 0 &&
            this.state[2] === 0 &&
            this.state[3] === 0) {
            this.state[0] = 88; // X
            this.state[1] = 83; // S
            this.state[2] = 65; // A
            this.state[3] = 68; // D
        }
    }
    nextState() {
        let t = this.state[0];
        t ^= t << sh1;
        t ^= t >>> sh2;
        t ^= this.state[3] << sh3;
        this.state[0] = this.state[1];
        this.state[1] = this.state[2];
        this.state[2] = this.state[3];
        this.state[3] = t;
    }
}
exports.default = XSadd;

},{}],366:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCorrelationData = void 0;
const buildState_1 = require("../utilities/build/buildState");
const buildValues_1 = require("../utilities/build/buildValues");
/**
 * Builds the correlation data from spectra data and some options.
 *
 * @param {Spectra} spectra
 * @param {Options} options
 */
function buildCorrelationData(spectra, options) {
    const values = spectra ? (0, buildValues_1.buildValues)(spectra, options) : [];
    delete options.values;
    delete options.skipDataUpdate;
    return {
        values,
        options,
        state: (0, buildState_1.buildState)(values, options.mf || ''),
    };
}
exports.buildCorrelationData = buildCorrelationData;

},{"../utilities/build/buildState":371,"../utilities/build/buildValues":372}],367:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.allowedSignalKinds = void 0;
const allowedSignalKinds = ['signal'];
exports.allowedSignalKinds = allowedSignalKinds;

},{}],368:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./build/buildCorrelationData"), exports);
__exportStar(require("./utilities/build/buildValues"), exports);
__exportStar(require("./utilities/build/buildState"), exports);
__exportStar(require("./utilities/correlation/addLink"), exports);
__exportStar(require("./utilities/correlation/buildCorrelation"), exports);
__exportStar(require("./utilities/correlation/buildLink"), exports);
__exportStar(require("./utilities/correlation/removeLink"), exports);
__exportStar(require("./utilities/correlation/setCorrelation"), exports);
__exportStar(require("./utilities/general/checkMatch"), exports);
__exportStar(require("./utilities/general/findLinkedCorrelationsBySignalID"), exports);
__exportStar(require("./utilities/general/findLinksBySignalID"), exports);
__exportStar(require("./utilities/general/getAtomCounts"), exports);
__exportStar(require("./utilities/general/getAtomTypeFromNucleus"), exports);
__exportStar(require("./utilities/general/getCorrelationDelta"), exports);
__exportStar(require("./utilities/general/getCorrelationIndex"), exports);
__exportStar(require("./utilities/general/getCorrelationsByAtomType"), exports);
__exportStar(require("./utilities/general/getLabel"), exports);
__exportStar(require("./utilities/general/getLabels"), exports);
__exportStar(require("./utilities/general/getLinkDelta"), exports);
__exportStar(require("./utilities/general/getLinkDim"), exports);
__exportStar(require("./utilities/general/isEditedHSQC"), exports);
__exportStar(require("./utilities/general/setPathLength"), exports);

},{"./build/buildCorrelationData":366,"./utilities/build/buildState":371,"./utilities/build/buildValues":372,"./utilities/correlation/addLink":384,"./utilities/correlation/buildCorrelation":386,"./utilities/correlation/buildLink":387,"./utilities/correlation/removeLink":392,"./utilities/correlation/setCorrelation":395,"./utilities/general/checkMatch":401,"./utilities/general/findLinkedCorrelationsBySignalID":402,"./utilities/general/findLinksBySignalID":403,"./utilities/general/getAtomCounts":405,"./utilities/general/getAtomTypeFromNucleus":406,"./utilities/general/getCorrelationDelta":407,"./utilities/general/getCorrelationIndex":408,"./utilities/general/getCorrelationsByAtomType":409,"./utilities/general/getLabel":410,"./utilities/general/getLabels":411,"./utilities/general/getLinkDelta":412,"./utilities/general/getLinkDim":413,"./utilities/general/isEditedHSQC":414,"./utilities/general/setPathLength":415}],369:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFromData = void 0;
const buildLink_1 = require("../correlation/buildLink");
const checkMatch_1 = require("../general/checkMatch");
const findLinkedCorrelationsBySignalID_1 = require("../general/findLinkedCorrelationsBySignalID");
const getCorrelationDelta_1 = require("../general/getCorrelationDelta");
const addSignal_1 = require("./addSignal");
/**
 * Adds new correlations from 1D and 2D data or adds links to already existing ones.
 *
 * @param {Values} correlations
 * * @param {Experiment1DSignals} signals1D
 * @param {Experiment2DSignals} signals2D
 * @param {Tolerance} tolerance
 */
function addFromData(correlations, signals1D, signals2D, tolerance) {
    // remove non-pseudo correlation objects without links
    correlations = correlations.filter((correlation) => correlation.link.length > 0 || correlation.pseudo);
    // add from 1D data
    Object.keys(signals1D).forEach((atomType) => {
        signals1D[atomType].forEach((signal1D) => {
            const linkedCorrelations = (0, findLinkedCorrelationsBySignalID_1.findLinkedCorrelationsBySignalID)(correlations, signal1D.signal.id || '');
            if (linkedCorrelations.length === 0) {
                const matchedCorrelationIndices = correlations
                    .map((correlation, k) => {
                    const correlationDelta = (0, getCorrelationDelta_1.getCorrelationDelta)(correlation);
                    return !correlation.pseudo &&
                        correlation.atomType === atomType &&
                        correlationDelta !== undefined &&
                        (0, checkMatch_1.checkMatch)(correlationDelta, signal1D.signal.delta, tolerance[atomType])
                        ? k
                        : -1;
                })
                    .filter((index) => index >= 0)
                    .filter((index, i, a) => a.indexOf(index) === i);
                const link = (0, buildLink_1.buildLink)({
                    experimentType: signal1D.experimentType,
                    experimentID: signal1D.experimentID,
                    signal: signal1D.signal,
                    atomType: [atomType],
                });
                (0, addSignal_1.addSignal)(matchedCorrelationIndices, atomType, link, correlations);
            }
        });
    });
    // add from 2D
    // add potential new correlations and push new links via shift matches between 1D vs. 2D and 2D vs. 2D
    Object.keys(signals2D).forEach((experimentType) => signals2D[experimentType].forEach((signal2D) => {
        const linkedCorrelations = (0, findLinkedCorrelationsBySignalID_1.findLinkedCorrelationsBySignalID)(correlations, signal2D.signal.id || '');
        if (linkedCorrelations.length === 0) {
            signal2D.atomType.forEach((atomType, dim) => {
                const axis = dim === 0 ? 'x' : 'y';
                const matchedCorrelationIndices = correlations
                    .map((correlation, k) => {
                    const correlationDelta = (0, getCorrelationDelta_1.getCorrelationDelta)(correlation);
                    return !correlation.pseudo &&
                        correlation.atomType === atomType &&
                        correlationDelta !== undefined &&
                        (0, checkMatch_1.checkMatch)(correlationDelta, signal2D.signal[axis].delta, tolerance[atomType])
                        ? k
                        : -1;
                })
                    .filter((index) => index >= 0)
                    .filter((index, i, a) => a.indexOf(index) === i);
                const link = (0, buildLink_1.buildLink)({
                    experimentType: signal2D.experimentType,
                    experimentID: signal2D.experimentID,
                    signal: signal2D.signal,
                    axis,
                    atomType: signal2D.atomType,
                });
                (0, addSignal_1.addSignal)(matchedCorrelationIndices, atomType, link, correlations);
            });
        }
    }));
    return correlations;
}
exports.addFromData = addFromData;

},{"../correlation/buildLink":387,"../general/checkMatch":401,"../general/findLinkedCorrelationsBySignalID":402,"../general/getCorrelationDelta":407,"./addSignal":370}],370:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSignal = void 0;
const __1 = require("../..");
const containsLink_1 = require("../correlation/containsLink");
const hasLinks_1 = require("../correlation/hasLinks");
function addSignal(matchedCorrelationIndices, atomType, link, correlations) {
    if (matchedCorrelationIndices.length === 0) {
        // in case of no signal match -> add new signal from 2D
        const newCorrelation = (0, __1.buildCorrelation)({
            atomType,
        });
        (0, __1.addLink)(newCorrelation, link);
        const pseudoIndex = correlations.findIndex((correlation) => correlation.atomType === atomType &&
            correlation.pseudo &&
            !(0, hasLinks_1.hasLinks)(correlation));
        if (pseudoIndex >= 0) {
            correlations[pseudoIndex] = newCorrelation;
        }
        else {
            correlations.push(newCorrelation);
        }
    }
    else if (!(0, containsLink_1.containsLink)(correlations[matchedCorrelationIndices[0]], link)) {
        // if allowed then add links from 2D data in first match only
        (0, __1.addLink)(correlations[matchedCorrelationIndices[0]], link);
    }
}
exports.addSignal = addSignal;

},{"../..":368,"../correlation/containsLink":388,"../correlation/hasLinks":390}],371:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildState = void 0;
const getAtomCounts_1 = require("../general/getAtomCounts");
const getCorrelationIndex_1 = require("../general/getCorrelationIndex");
const getCorrelationsByAtomType_1 = require("../general/getCorrelationsByAtomType");
/**
 * Builds a state from current values and an optional molecular formula.
 *
 * @param {Values} values
 * @param {string} mf
 */
function buildState(values, mf) {
    const state = {};
    const atoms = (0, getAtomCounts_1.getAtomCounts)(mf);
    const atomTypesInCorrelations = values.reduce((array, correlation) => array.includes(correlation.atomType)
        ? array
        : array.concat(correlation.atomType), []);
    atomTypesInCorrelations.forEach((atomType) => {
        const correlationsAtomType = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(values, atomType);
        // create state for specific atom type only if there is at least one real correlation
        if (correlationsAtomType.some((correlation) => !correlation.pseudo)) {
            // create state error
            const stateAtomTypeError = {};
            const atomCount = atoms[atomType];
            let atomCountAtomType = correlationsAtomType.reduce((sum, correlation) => !correlation.pseudo ? sum + correlation.equivalence : sum, 0);
            if (atomType === 'H') {
                // add protons count from pseudo correlations without any pseudo HSQC correlation
                values.forEach((correlation) => {
                    if (correlation.pseudo &&
                        correlation.atomType !== 'H' &&
                        correlation.protonsCount.length === 1 &&
                        !correlation.link.some((link) => link.experimentType === 'hsqc')) {
                        atomCountAtomType += correlation.protonsCount[0];
                    }
                });
                // determine the number of pseudo correlations
                const pseudoCorrelationCount = correlationsAtomType.reduce((sum, correlation) => (correlation.pseudo ? sum + 1 : sum), 0);
                // determine the not attached protons
                const notAttached = correlationsAtomType.reduce((array, correlation) => Object.keys(correlation.attachment).length === 0
                    ? array.concat((0, getCorrelationIndex_1.getCorrelationIndex)(values, correlation))
                    : array, []);
                if (notAttached.length > 0) {
                    stateAtomTypeError.notAttached = notAttached;
                }
                atomCountAtomType -= notAttached.length - pseudoCorrelationCount;
                if (atomCountAtomType < 0) {
                    atomCountAtomType = 0;
                }
                // determine the ambiguous attached protons
                const ambiguousAttachment = correlationsAtomType.reduce((array, correlation) => Object.keys(correlation.attachment).length > 1 ||
                    Object.keys(correlation.attachment).some((otherAtomType) => correlation.attachment[otherAtomType].length > 1)
                    ? array.concat((0, getCorrelationIndex_1.getCorrelationIndex)(values, correlation))
                    : array, []);
                if (ambiguousAttachment.length > 0) {
                    stateAtomTypeError.ambiguousAttachment = ambiguousAttachment;
                }
            }
            if (atomCount !== undefined) {
                const outOfLimit = correlationsAtomType.some((correlation, k) => !correlation.pseudo &&
                    correlation.atomType === atomType &&
                    k >= atomCount);
                if (outOfLimit) {
                    stateAtomTypeError.outOfLimit = true;
                }
            }
            const complete = atomCount === undefined ? undefined : atomCountAtomType === atomCount;
            if (complete === false) {
                stateAtomTypeError.incomplete = true;
            }
            state[atomType] = {
                current: atomCountAtomType,
                total: atomCount,
                complete,
                error: stateAtomTypeError,
            };
        }
    });
    return state;
}
exports.buildState = buildState;

},{"../general/getAtomCounts":405,"../general/getCorrelationIndex":408,"../general/getCorrelationsByAtomType":409}],372:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildValues = void 0;
const setProtonsCountFromData_1 = require("../protonsCount/setProtonsCountFromData");
const getSignals_1 = require("../signals/getSignals");
const addFromData_1 = require("./addFromData");
const updatePseudoCorrelations_1 = require("./pseudo/updatePseudoCorrelations");
const removeObsoleteLinksAndNotLinkedCorrelations_1 = require("./removeObsoleteLinksAndNotLinkedCorrelations");
const setAttachmentsAndProtonEquivalences_1 = require("./setAttachmentsAndProtonEquivalences");
const setLabels_1 = require("./setLabels");
const setMatches_1 = require("./setMatches");
const sortCorrelations_1 = require("./sortCorrelations");
/**
 * Builds the correlation data values from given input spectra and options.
 * @param {Spectra} spectra
 * @param {Options} options
 */
function buildValues(spectra, options) {
    const { tolerance = {}, mf = '', values: prevValues = [] } = options;
    const signals = (0, getSignals_1.getSignals)(spectra);
    let _correlations = prevValues ? prevValues.slice() : [];
    if (options.skipDataUpdate !== true) {
        // remove obsolete links/correlations
        _correlations = (0, removeObsoleteLinksAndNotLinkedCorrelations_1.removeObsoleteLinksAndNotLinkedCorrelations)(_correlations, signals.signals1D, signals.signals2D);
        // add signals from either 1D or 2D if not already existing as correlation
        // if a signal already exists then add a link within matched correlation
        _correlations = (0, addFromData_1.addFromData)(_correlations, signals.signals1D, signals.signals2D, tolerance);
    }
    else {
        // in case an external movement has led to en empty link array within a correlation
        _correlations = _correlations.filter((correlation) => correlation.link.length > 0 || correlation.pseudo);
    }
    // set the number of attached protons via DEPT or edited HSQC
    _correlations = (0, setProtonsCountFromData_1.setProtonsCountFromData)(_correlations, signals.signalsDEPT, signals.signals2D, tolerance);
    // sort by atom type and shift value
    _correlations = (0, sortCorrelations_1.sortCorrelations)(_correlations);
    // link signals via matches to same 2D signal: e.g. 13C -> HSQC <- 1H
    (0, setMatches_1.setMatches)(_correlations);
    // set attachments via HSQC or HMQC
    (0, setAttachmentsAndProtonEquivalences_1.setAttachmentsAndProtonEquivalences)(_correlations);
    // update pseudo correlation
    _correlations = (0, updatePseudoCorrelations_1.updatePseudoCorrelations)(_correlations, mf);
    // set labels
    (0, setLabels_1.setLabels)(_correlations);
    return _correlations;
}
exports.buildValues = buildValues;

},{"../protonsCount/setProtonsCountFromData":419,"../signals/getSignals":421,"./addFromData":369,"./pseudo/updatePseudoCorrelations":376,"./removeObsoleteLinksAndNotLinkedCorrelations":377,"./setAttachmentsAndProtonEquivalences":378,"./setLabels":379,"./setMatches":380,"./sortCorrelations":381}],373:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPseudoCorrelations = void 0;
const buildCorrelation_1 = require("../../correlation/buildCorrelation");
const getCorrelationsByAtomType_1 = require("../../general/getCorrelationsByAtomType");
function addPseudoCorrelations(correlations, atoms) {
    for (const atomType in atoms) {
        const atomTypeCount = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, atomType).reduce((sum, correlation) => sum + correlation.equivalence, 0);
        // add missing pseudo correlations
        for (let i = atomTypeCount; i < atoms[atomType]; i++) {
            correlations.push((0, buildCorrelation_1.buildCorrelation)({
                atomType,
                pseudo: true,
            }));
        }
    }
    return correlations;
}
exports.addPseudoCorrelations = addPseudoCorrelations;

},{"../../correlation/buildCorrelation":386,"../../general/getCorrelationsByAtomType":409}],374:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPseudoCorrelations = void 0;
const hasLinks_1 = require("../../correlation/hasLinks");
const removeLink_1 = require("../../correlation/removeLink");
const removeMatch_1 = require("../../correlation/removeMatch");
const getCorrelationIndex_1 = require("../../general/getCorrelationIndex");
const getCorrelationsByAtomType_1 = require("../../general/getCorrelationsByAtomType");
function checkPseudoCorrelations(correlations, atoms) {
    for (const atomType in atoms) {
        // consider also pseudo correlations
        const correlationsAtomType = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, atomType);
        if (correlationsAtomType.length > atoms[atomType]) {
            // remove pseudo correlations which are out of limit and not linked
            const pseudoCorrelationsAtomType = correlationsAtomType.filter((correlation) => correlation.pseudo &&
                correlation.equivalence === 1 &&
                !(0, hasLinks_1.hasLinks)(correlation));
            for (let i = correlationsAtomType.length - 1; i >= atoms[atomType]; i--) {
                if (pseudoCorrelationsAtomType.length === 0) {
                    break;
                }
                const pseudoCorrelationToRemove = pseudoCorrelationsAtomType.pop();
                if (pseudoCorrelationToRemove) {
                    correlations.splice(correlations.indexOf(pseudoCorrelationToRemove), 1);
                }
            }
        }
    }
    // check for deleted links and correct proton counts if no HSQC link exists
    for (const pseudoCorrelation of correlations) {
        if (!pseudoCorrelation.pseudo ||
            pseudoCorrelation.equivalence > 1 ||
            (0, hasLinks_1.hasLinks)(pseudoCorrelation)) {
            continue;
        }
        // remove wrong (old) match indices and empty links
        const linksToRemove = [];
        const pseudoCorrelationIndex = (0, getCorrelationIndex_1.getCorrelationIndex)(correlations, pseudoCorrelation);
        for (const pseudoLink of pseudoCorrelation.link) {
            for (const matchIndex of pseudoLink.match) {
                if (!correlations[matchIndex] ||
                    !correlations[matchIndex].link.some((_link) => _link.match.includes(pseudoCorrelationIndex))) {
                    (0, removeMatch_1.removeMatch)(pseudoLink, matchIndex);
                }
            }
            if (pseudoLink.match.length === 0) {
                linksToRemove.push(pseudoLink);
            }
        }
        for (const pseudoLink of linksToRemove) {
            (0, removeLink_1.removeLink)(pseudoCorrelation, pseudoLink.id);
        }
        // correct protons count if no HSQC link was found anymore and the field was not edited manually
        if (!pseudoCorrelation.edited.protonsCount &&
            !pseudoCorrelation.link.some((pseudoLink) => pseudoLink.experimentType === 'hsqc')) {
            pseudoCorrelation.protonsCount = [];
        }
    }
    // filter out correlations with unknown atom types from previous molecular formula
    return Object.keys(atoms).length > 0
        ? correlations.filter((correlation) => Object.keys(atoms).includes(correlation.atomType))
        : correlations;
}
exports.checkPseudoCorrelations = checkPseudoCorrelations;

},{"../../correlation/hasLinks":390,"../../correlation/removeLink":392,"../../correlation/removeMatch":393,"../../general/getCorrelationIndex":408,"../../general/getCorrelationsByAtomType":409}],375:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replacePseudoCorrelationsByEquivalences = void 0;
const hasLinks_1 = require("../../correlation/hasLinks");
const getCorrelationsByAtomType_1 = require("../../general/getCorrelationsByAtomType");
function replacePseudoCorrelationsByEquivalences(correlations, atoms) {
    for (const atomType in atoms) {
        // remove pseudo correlations to be replaced by equivalences, starting at the end
        const correlationsAtomType = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, atomType);
        const validCorrelationsAtomType = correlationsAtomType.filter((correlation) => !correlation.pseudo ||
            correlation.equivalence > 1 ||
            (0, hasLinks_1.hasLinks)(correlation));
        const atomTypeEquivalencesCount = validCorrelationsAtomType.reduce((sum, correlation) => sum + (correlation.equivalence - 1), 0);
        const pseudoCorrelationsAtomType = correlationsAtomType.filter((correlation) => correlation.pseudo &&
            !validCorrelationsAtomType.some((validCorrelation) => validCorrelation.id === correlation.id));
        for (let i = 0; i <
            correlationsAtomType.length -
                (atoms[atomType] - atomTypeEquivalencesCount); i++) {
            if (pseudoCorrelationsAtomType.length === 0) {
                break;
            }
            const pseudoCorrelationToRemove = pseudoCorrelationsAtomType.pop();
            if (pseudoCorrelationToRemove) {
                correlations.splice(correlations.indexOf(pseudoCorrelationToRemove), 1);
            }
        }
    }
    return correlations;
}
exports.replacePseudoCorrelationsByEquivalences = replacePseudoCorrelationsByEquivalences;

},{"../../correlation/hasLinks":390,"../../general/getCorrelationsByAtomType":409}],376:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePseudoCorrelations = void 0;
const getAtomCounts_1 = require("../../general/getAtomCounts");
const addPseudoCorrelations_1 = require("./addPseudoCorrelations");
const checkPseudoCorrelations_1 = require("./checkPseudoCorrelations");
const replacePseudoCorrelationsByEquivalences_1 = require("./replacePseudoCorrelationsByEquivalences");
/**
 * Adds pseudo correlations if needed, checks for replacement
 * by equivalent atoms and cleanup.
 * @param {Values} correlations
 * @param {string} mf
 */
function updatePseudoCorrelations(correlations, mf) {
    const atoms = (0, getAtomCounts_1.getAtomCounts)(mf);
    if (Object.keys(atoms).length === 0) {
        correlations = correlations.filter((correlation) => !correlation.pseudo);
    }
    // add pseudo correlations
    correlations = (0, addPseudoCorrelations_1.addPseudoCorrelations)(correlations, atoms);
    // remove pseudo correlations to be replaced by equivalences
    correlations = (0, replacePseudoCorrelationsByEquivalences_1.replacePseudoCorrelationsByEquivalences)(correlations, atoms);
    // remove pseudo correlations which are out of limit, clean up links and proton counts
    correlations = (0, checkPseudoCorrelations_1.checkPseudoCorrelations)(correlations, atoms);
    return correlations;
}
exports.updatePseudoCorrelations = updatePseudoCorrelations;

},{"../../general/getAtomCounts":405,"./addPseudoCorrelations":373,"./checkPseudoCorrelations":374,"./replacePseudoCorrelationsByEquivalences":375}],377:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeObsoleteLinksAndNotLinkedCorrelations = void 0;
const get_1 = __importDefault(require("lodash/get"));
const __1 = require("../..");
/**
 * Removes non-pseudo correlations which signal id can not be found or have no links anymore.
 *
 * @param {Values} values
 * @param {Experiment1DSignals} signals1D
 * @param {Experiment2DSignals} signals2D
 */
function removeObsoleteLinksAndNotLinkedCorrelations(correlations, signals1D, signals2D) {
    const _correlations = correlations.filter((correlation) => !correlation.pseudo);
    const removeList = _correlations.slice();
    _correlations.forEach((correlation) => {
        for (const link of correlation.link) {
            if (link.experimentType === '1d') {
                // search in 1D data
                if ((0, get_1.default)(signals1D, link.atomType[0], []).some((signal1D) => signal1D.signal.id === link.signal.id)) {
                    const index = removeList.indexOf(correlation);
                    if (index >= 0) {
                        removeList.splice(index, 1);
                    }
                }
                else if (!link.pseudo) {
                    // remove obsolete link to not anymore existing signal
                    (0, __1.removeLink)(correlation, link.id);
                }
            }
            else if ((0, get_1.default)(signals2D, `${link.experimentType}`, []).some((signal2D) => signal2D.signal.id === link.signal.id)) {
                // search in 2D data
                const index = removeList.indexOf(correlation);
                if (index >= 0) {
                    removeList.splice(index, 1);
                }
            }
            else if (!link.pseudo) {
                // remove obsolete link to not anymore existing signal
                (0, __1.removeLink)(correlation, link.id);
            }
        }
    });
    removeList.forEach((correlation) => {
        const index = correlations.indexOf(correlation); // in case we already removed previously
        if (index >= 0) {
            correlations.splice(index, 1);
        }
    });
    return correlations;
}
exports.removeObsoleteLinksAndNotLinkedCorrelations = removeObsoleteLinksAndNotLinkedCorrelations;

},{"../..":368,"lodash/get":130}],378:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setAttachmentsAndProtonEquivalences = void 0;
const addAttachment_1 = require("../correlation/addAttachment");
const hasAttachmentAtomType_1 = require("../correlation/hasAttachmentAtomType");
const removeAttachments_1 = require("../correlation/removeAttachments");
/**
 * Sets the attachment information (indices of attached atoms).
 * And from that, the equivalence value for protons can be set too.
 *
 * @param {Values} values
 */
function setAttachmentsAndProtonEquivalences(correlations) {
    // update attachment information between heavy atoms and protons via HSQC or HMQC
    for (const correlation of correlations) {
        // remove previous set attachments
        (0, removeAttachments_1.removeAttachments)(correlation);
        // add attachments
        const linksFiltered = correlation.link.filter((link) => link.experimentType === 'hsqc' || link.experimentType === 'hmqc');
        for (const link of linksFiltered) {
            const otherAtomType = link.atomType[link.axis === 'x' ? 1 : 0];
            for (let matchIndex of link.match) {
                (0, addAttachment_1.addAttachment)(correlation, otherAtomType, matchIndex);
            }
        }
    }
    // set previously set equivalences of protons to 0
    for (const correlation of correlations) {
        if (correlation.atomType === 'H') {
            correlation.equivalence = 0;
        }
    }
    // reset previously set proton equivalences and set new ones
    // check heavy atoms with an unambiguous protons count
    for (const correlation of correlations) {
        if (correlation.atomType !== 'H' &&
            correlation.protonsCount.length === 1 &&
            (0, hasAttachmentAtomType_1.hasAttachmentAtomType)(correlation, 'H')) {
            const { equivalence, protonsCount } = correlation;
            let equivalences = 1;
            if (protonsCount[0] === 3) {
                equivalences = 3;
            }
            else if (protonsCount[0] === 2) {
                equivalences = 2;
            }
            const sharedEquivalences = (equivalence * equivalences) / correlation.attachment.H.length;
            for (const attachedProtonIndex of correlation.attachment.H) {
                correlations[attachedProtonIndex].equivalence += sharedEquivalences;
            }
        }
    }
    // set unchanged equivalence of protons back to 1
    for (const correlation of correlations) {
        if (correlation.atomType === 'H' && correlation.equivalence === 0) {
            correlation.equivalence = 1;
        }
    }
    return correlations;
}
exports.setAttachmentsAndProtonEquivalences = setAttachmentsAndProtonEquivalences;

},{"../correlation/addAttachment":382,"../correlation/hasAttachmentAtomType":389,"../correlation/removeAttachments":391}],379:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLabels = void 0;
const get_1 = __importDefault(require("lodash/get"));
/**
 * Sets the origin (default) label for each correlation, e.g. C1 or H2, depending on its order.
 *
 * @param {Values} values
 */
function setLabels(correlations) {
    const atomTypeCounts = {};
    correlations.forEach((correlation) => {
        if (!(0, get_1.default)(atomTypeCounts, correlation.atomType, false)) {
            atomTypeCounts[correlation.atomType] = 0;
        }
        atomTypeCounts[correlation.atomType]++;
        correlation.label.origin = `${correlation.atomType}${atomTypeCounts[correlation.atomType]}`;
    });
    return correlations;
}
exports.setLabels = setLabels;

},{"lodash/get":130}],380:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMatches = void 0;
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const addMatch_1 = require("../correlation/addMatch");
const removeLink_1 = require("../correlation/removeLink");
const removeMatches_1 = require("../correlation/removeMatches");
const getCorrelationIndex_1 = require("../general/getCorrelationIndex");
const getCorrelationsByAtomType_1 = require("../general/getCorrelationsByAtomType");
/**
 * Sets the match indices for each link within a correlation.
 *
 * @param {Values} values
 */
function setMatches(correlations) {
    correlations.forEach((correlation) => {
        correlation.link.forEach((link) => {
            // remove previously added matches
            (0, removeMatches_1.removeMatches)(link);
            // add matches
            const otherAtomType = link.axis === 'x' ? link.atomType[1] : link.atomType[0];
            (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, otherAtomType).forEach((correlationOtherAtomType) => {
                if (correlation.id !== correlationOtherAtomType.id) {
                    const correlationIndexOtherAtomType = (0, getCorrelationIndex_1.getCorrelationIndex)(correlations, correlationOtherAtomType);
                    correlationOtherAtomType.link.forEach((linkOtherAtomType) => {
                        // check for correlation match and avoid possible duplicates
                        if (linkOtherAtomType.experimentType === link.experimentType &&
                            linkOtherAtomType.experimentID === link.experimentID &&
                            (0, isEqual_1.default)(linkOtherAtomType.atomType, link.atomType) &&
                            linkOtherAtomType.signal.id === link.signal.id &&
                            linkOtherAtomType.axis !== link.axis) {
                            (0, addMatch_1.addMatch)(link, correlationIndexOtherAtomType);
                        }
                    });
                }
            });
        });
    });
    // remove links without any matches
    correlations.forEach((correlation) => {
        const linksToRemove = correlation.link.filter((link) => {
            var _a;
            return link.match.length === 0 &&
                link.experimentType !== '1d' &&
                !((_a = link.edited) === null || _a === void 0 ? void 0 : _a.moved);
        });
        linksToRemove.forEach((link) => (0, removeLink_1.removeLink)(correlation, link.id));
    });
    return correlations;
}
exports.setMatches = setMatches;

},{"../correlation/addMatch":385,"../correlation/removeLink":392,"../correlation/removeMatches":394,"../general/getCorrelationIndex":408,"../general/getCorrelationsByAtomType":409,"lodash/isEqual":135}],381:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortCorrelations = void 0;
const getCorrelationDelta_1 = require("../general/getCorrelationDelta");
const getCorrelationsByAtomType_1 = require("../general/getCorrelationsByAtomType");
/**
 * Sorts the correlations according to its atom type value and signal delta.
 *
 * @param {Values} values
 */
function sortCorrelations(correlations) {
    const compareAtomTypes = (atomType1, atomType2) => {
        // C and H highest priority
        if (atomType1 === 'C') {
            return -1;
        }
        if (atomType2 === 'C') {
            return 1;
        }
        if (atomType1 === 'H') {
            return -1;
        }
        if (atomType2 === 'H') {
            return 1;
        }
        // alphabetical sort
        if (atomType1 < atomType2) {
            return -1;
        }
        if (atomType1 > atomType2) {
            return 1;
        }
        return 0;
    };
    const compareCorrelations = (corr1, corr2) => {
        if (!corr1.pseudo &&
            !corr2.pseudo &&
            corr1.link.length > 0 &&
            corr2.link.length > 0) {
            const corr1Delta = (0, getCorrelationDelta_1.getCorrelationDelta)(corr1);
            const corr2Delta = (0, getCorrelationDelta_1.getCorrelationDelta)(corr2);
            if (corr1Delta !== undefined && corr2Delta !== undefined) {
                if (corr1Delta < corr2Delta) {
                    return -1;
                }
                else if (corr1Delta > corr2Delta) {
                    return 1;
                }
            }
        }
        if (!corr1.pseudo && corr2.pseudo) {
            return -1;
        }
        if (corr1.pseudo && !corr2.pseudo) {
            return 1;
        }
        if (corr1.label.origin < corr2.label.origin) {
            return -1;
        }
        if (corr1.label.origin > corr2.label.origin) {
            return 1;
        }
        return 0;
    };
    let sortedCorrelations = [];
    const atomTypes = correlations
        .map((correlation) => correlation.atomType)
        .filter((atomType, i, a) => a.indexOf(atomType) === i);
    atomTypes.sort(compareAtomTypes);
    atomTypes.forEach((atomType) => {
        const correlationsAtomType = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, atomType);
        correlationsAtomType.sort(compareCorrelations);
        sortedCorrelations = sortedCorrelations.concat(correlationsAtomType);
    });
    return sortedCorrelations;
}
exports.sortCorrelations = sortCorrelations;

},{"../general/getCorrelationDelta":407,"../general/getCorrelationsByAtomType":409}],382:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addAttachment = void 0;
const addAttachmentAtomType_1 = require("./addAttachmentAtomType");
/**
 * Adds an attachment for a certain atom type to a correlation.
 *
 * @param {Correlation} correlation
 * @param {string} atomType
 * @param {number} attachment
 */
function addAttachment(correlation, atomType, attachment) {
    (0, addAttachmentAtomType_1.addAttachmentAtomType)(correlation, atomType);
    if (!correlation.attachment[atomType].includes(attachment)) {
        correlation.attachment[atomType].push(attachment);
    }
    return correlation;
}
exports.addAttachment = addAttachment;

},{"./addAttachmentAtomType":383}],383:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addAttachmentAtomType = void 0;
const hasAttachmentAtomType_1 = require("./hasAttachmentAtomType");
/**
 * Creates an attachment array for a certain atom type in a correlation.
 *
 * @param {Correlation} correlation
 * @param {string} atomType
 */
function addAttachmentAtomType(correlation, atomType) {
    if (!(0, hasAttachmentAtomType_1.hasAttachmentAtomType)(correlation, atomType)) {
        correlation.attachment[atomType] = [];
    }
    return correlation;
}
exports.addAttachmentAtomType = addAttachmentAtomType;

},{"./hasAttachmentAtomType":389}],384:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLink = void 0;
/**
 * Adds a link to a correlation.
 *
 * @param {Correlation} correlation
 * @param {Link} link
 */
function addLink(correlation, link) {
    correlation.link.push(link);
    return correlation;
}
exports.addLink = addLink;

},{}],385:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMatch = void 0;
/**
 * Adds an index to the match array of a link.
 *
 * @param {Link} link
 * @param {number} index
 */
function addMatch(link, index) {
    if (!link.match.includes(index)) {
        link.match.push(index);
    }
    return link;
}
exports.addMatch = addMatch;

},{}],386:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCorrelation = void 0;
const generateID_1 = require("../general/generateID");
/**
 * Builds a correlation object with some existing default values.
 *
 * @param {CorrelationOptions} options
 */
function buildCorrelation(options) {
    return {
        id: options.id || (0, generateID_1.generateID)(),
        atomType: options.atomType,
        label: options.label || {},
        link: options.link || [],
        equivalence: options.equivalence || 1,
        attachment: options.attachment || {},
        protonsCount: options.protonsCount || [],
        hybridization: options.hybridization || [],
        pseudo: options.pseudo || false,
        edited: options.edited || {},
    };
}
exports.buildCorrelation = buildCorrelation;

},{"../general/generateID":404}],387:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildLink = void 0;
const generateID_1 = require("../general/generateID");
/**
 * Builds a link object with some existing default values.
 *
 * @param {LinkOptions} options
 */
function buildLink(options) {
    return {
        id: options.id || (0, generateID_1.generateID)(),
        experimentType: options.experimentType,
        experimentID: options.experimentID,
        atomType: options.atomType,
        signal: options.signal,
        axis: options.axis,
        match: options.match || [],
        experimentLabel: options.experimentLabel || '',
        pseudo: options.pseudo || false,
        edited: options.edited || {},
    };
}
exports.buildLink = buildLink;

},{"../general/generateID":404}],388:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsLink = void 0;
const isEqual_1 = __importDefault(require("lodash/isEqual"));
/**
 * Checks whether a correlation contains a link by id search.
 *
 * @param {Correlation} correlation
 * @param {Link} link
 */
function containsLink(correlation, link) {
    return correlation.link.some((_link) => _link.experimentType === link.experimentType &&
        _link.experimentID === link.experimentID &&
        (0, isEqual_1.default)(_link.atomType, link.atomType) &&
        _link.signal.id === link.signal.id &&
        _link.axis === link.axis);
}
exports.containsLink = containsLink;

},{"lodash/isEqual":135}],389:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasAttachmentAtomType = void 0;
/**
 * Checks whether an atom type key in attachments already exists.
 *
 * @param {Correlation} correlation
 * @param {string} atomType
 */
function hasAttachmentAtomType(correlation, atomType) {
    return Boolean(correlation.attachment[atomType] &&
        correlation.attachment[atomType].length > 0);
}
exports.hasAttachmentAtomType = hasAttachmentAtomType;

},{}],390:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasLinks = void 0;
/**
 * Checks whether a correlation has links.
 *
 * @param {Correlation} correlation
 */
function hasLinks(correlation) {
    return correlation.link.length > 0;
}
exports.hasLinks = hasLinks;

},{}],391:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAttachments = void 0;
/**
 * Removes all attachments of a correlation.
 *
 * @param {Correlation} correlation
 */
function removeAttachments(correlation) {
    correlation.attachment = {};
    return correlation;
}
exports.removeAttachments = removeAttachments;

},{}],392:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeLink = void 0;
/**
 * Removes a link by id search.
 *
 * @param {Correlation} correlation
 * @param {string} id
 */
function removeLink(correlation, id) {
    correlation.link = correlation.link.filter((_link) => _link.id !== id);
    return correlation;
}
exports.removeLink = removeLink;

},{}],393:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMatch = void 0;
/**
 * Removes a match index from a link.
 *
 * @param {Link} link
 * @param {number} index
 */
function removeMatch(link, index) {
    const indexOf = link.match.indexOf(index);
    if (indexOf >= 0) {
        link.match.splice(indexOf, 1);
    }
    return link;
}
exports.removeMatch = removeMatch;

},{}],394:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMatches = void 0;
/**
 * Removes all match indices in a link.
 *
 * @param {Link} link
 */
function removeMatches(link) {
    link.match = [];
    return link;
}
exports.removeMatches = removeMatches;

},{}],395:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCorrelation = void 0;
const buildCorrelation_1 = require("./buildCorrelation");
/**
 * Searches for a correlation index by id in correlation data and replaces it with a given correlation.
 *
 * @param {CorrelationData} data
 * @param {string} id
 * @param {Correlation} correlation
 */
function setCorrelation(data, id, correlation) {
    const _values = data.values.slice();
    const correlationIndex = _values.findIndex((_correlation) => _correlation.id === id);
    if (correlationIndex >= 0) {
        _values.splice(correlationIndex, 1, (0, buildCorrelation_1.buildCorrelation)({ ...correlation }));
    }
    else {
        _values.push(correlation);
    }
    return {
        values: _values,
        state: data.state,
        options: data.options,
    };
}
exports.setCorrelation = setCorrelation;

},{"./buildCorrelation":386}],396:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToExperiments = void 0;
const get_1 = __importDefault(require("lodash/get"));
const getAtomTypeFromNucleus_1 = require("../general/getAtomTypeFromNucleus");
/**
 * Add experiment of certain type to experiments.
 *
 * @param {Experiments} experiments
 * @param {ExperimentsType} experimentsType
 * @param {string} type
 * @param {boolean} checkAtomType
 * @param {string} experimentKey
 */
function addToExperiments(experiments, experimentsType, type, checkAtomType, experimentKey) {
    const _experiments = (0, get_1.default)(experiments, `${type}`, []) // don't consider DEPT etc. here
        .filter((_experiment) => {
        const hasValues = (0, get_1.default)(_experiment, type.includes('1D') ? 'ranges.values' : 'zones.values', []).length > 0;
        return checkAtomType
            ? (0, getAtomTypeFromNucleus_1.getAtomTypeFromNucleus)(_experiment.info.nucleus) ===
                experimentKey && hasValues
            : hasValues;
    });
    if (_experiments.length > 0) {
        experimentsType[experimentKey] = _experiments;
    }
}
exports.addToExperiments = addToExperiments;

},{"../general/getAtomTypeFromNucleus":406,"lodash/get":130}],397:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperiments = void 0;
/**
 * Get all different experiments from spectra data.
 *
 * @param {Spectra} spectraData
 */
function getExperiments(spectraData) {
    if (!spectraData)
        return {};
    const experiments = {};
    for (const spectrum of spectraData) {
        if (spectrum.info.isFid)
            continue;
        if (!experiments[`${spectrum.info.dimension}D`]) {
            experiments[`${spectrum.info.dimension}D`] = {};
        }
        const experiment = spectrum.info.experiment;
        if (!experiments[`${spectrum.info.dimension}D`][`${experiment}`]) {
            experiments[`${spectrum.info.dimension}D`][`${experiment}`] = [];
        }
        experiments[`${spectrum.info.dimension}D`][`${experiment}`].push(spectrum);
    }
    return experiments;
}
exports.getExperiments = getExperiments;

},{}],398:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperiments1D = void 0;
const get_1 = __importDefault(require("lodash/get"));
const getAtomTypeFromNucleus_1 = require("../general/getAtomTypeFromNucleus");
const addToExperiments_1 = require("./addToExperiments");
/**
 * Get "plain" 1D experiments containing ranges, i.e. without DEPT etc..
 *
 * @param {Spectra} spectraData
 */
function getExperiments1D(experiments) {
    const _experiments1D = {};
    (0, get_1.default)(experiments, '1D.1d', [])
        .map((experiment) => (0, getAtomTypeFromNucleus_1.getAtomTypeFromNucleus)(experiment.info.nucleus))
        .forEach((atomType) => {
        (0, addToExperiments_1.addToExperiments)(experiments, _experiments1D, '1D.1d', true, atomType);
    });
    return _experiments1D;
}
exports.getExperiments1D = getExperiments1D;

},{"../general/getAtomTypeFromNucleus":406,"./addToExperiments":396,"lodash/get":130}],399:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperiments1DExtra = void 0;
const get_1 = __importDefault(require("lodash/get"));
const addToExperiments_1 = require("./addToExperiments");
/**
 * Get "extra" 1D experiments containing ranges, e.g. DEPT.
 *
 * @param {Spectra} spectraData
 */
function getExperiments1DExtra(experiments) {
    const _experiments1DExtra = {};
    Object.keys((0, get_1.default)(experiments, `1D`, {}))
        .filter((experimentType) => experimentType !== '1d') // don't consider "plain" 1D experiments here
        .forEach((experimentType) => {
        (0, addToExperiments_1.addToExperiments)(experiments, _experiments1DExtra, `1D.${experimentType}`, false, experimentType);
    });
    return _experiments1DExtra;
}
exports.getExperiments1DExtra = getExperiments1DExtra;

},{"./addToExperiments":396,"lodash/get":130}],400:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperiments2D = void 0;
const get_1 = __importDefault(require("lodash/get"));
const addToExperiments_1 = require("./addToExperiments");
/**
 * Get 2D experiments containing zones.
 *
 * @param {Spectra} spectraData
 */
function getExperiments2D(experiments) {
    const _experiments2D = {};
    Object.keys((0, get_1.default)(experiments, '2D', {})).forEach((experimentType) => {
        (0, addToExperiments_1.addToExperiments)(experiments, _experiments2D, `2D.${experimentType}`, false, experimentType);
    });
    return _experiments2D;
}
exports.getExperiments2D = getExperiments2D;

},{"./addToExperiments":396,"lodash/get":130}],401:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkMatch = void 0;
/**
 * Checks for a numeric match within a certain tolerance.
 *
 * @param {number} value1
 * @param {number} value2
 * @param {number} tolerance
 */
function checkMatch(value1, value2, tolerance) {
    return value1 - tolerance <= value2 && value2 <= value1 + tolerance;
}
exports.checkMatch = checkMatch;

},{}],402:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLinkedCorrelationsBySignalID = void 0;
function findLinkedCorrelationsBySignalID(correlations, signalID) {
    return correlations.filter((_correlation) => _correlation.link.some((_link) => _link.signal.id === signalID));
}
exports.findLinkedCorrelationsBySignalID = findLinkedCorrelationsBySignalID;

},{}],403:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLinksBySignalID = void 0;
function findLinksBySignalID(correlations, signalID) {
    let links = [];
    correlations.forEach((_correlation) => {
        links = links.concat(_correlation.link.filter((_link) => _link.signal.id === signalID));
    });
    return links;
}
exports.findLinksBySignalID = findLinksBySignalID;

},{}],404:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateID = void 0;
const BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
const LENGTH = 8;
function generateID() {
    let id = '';
    for (let i = 0; i < LENGTH; i++) {
        id += BASE62.charAt(Math.floor(Math.random() * 62));
    }
    return id;
}
exports.generateID = generateID;

},{}],405:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomCounts = void 0;
/**
 * Returns the number of atoms per atom type for a given molecular formula.
 *
 * @param {string} mf
 */
function getAtomCounts(mf) {
    const elements = mf ? mf.match(/[A-Z][a-z]{0,1}/g) : [];
    const counts = {};
    if (elements) {
        elements.forEach((elem) => {
            const regex = new RegExp(`(${elem}\\d+)`, 'g');
            const match = regex.exec(mf);
            let count = 1;
            if (match) {
                count = Number(match[0].split(elem)[1]);
            }
            counts[elem] = count;
        });
    }
    return counts;
}
exports.getAtomCounts = getAtomCounts;

},{}],406:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomTypeFromNucleus = void 0;
/**
 * Returns the atom type from nucleus.
 * @param {string} nucleus
 */
function getAtomTypeFromNucleus(nucleus) {
    return nucleus.length > 0 ? nucleus.split(/\d+/)[1] : '';
}
exports.getAtomTypeFromNucleus = getAtomTypeFromNucleus;

},{}],407:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCorrelationDelta = void 0;
const getLinkDelta_1 = require("./getLinkDelta");
function getCorrelationDelta(correlation) {
    if (correlation.link.length > 0)
        return (0, getLinkDelta_1.getLinkDelta)(correlation.link[0]);
}
exports.getCorrelationDelta = getCorrelationDelta;

},{"./getLinkDelta":412}],408:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCorrelationIndex = void 0;
/**
 * Returns the array index of a correlation.
 *
 * @param {Values} correlations
 * @param {Correlation} correlation
 */
function getCorrelationIndex(correlations, correlation) {
    return correlations.findIndex((_correlation) => _correlation.id === correlation.id);
}
exports.getCorrelationIndex = getCorrelationIndex;

},{}],409:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCorrelationsByAtomType = void 0;
/**
 * Returns all correlations of a certain atom type.
 *
 * @param {Values} correlations
 * @param {string} atomType
 */
function getCorrelationsByAtomType(correlations, atomType) {
    return correlations
        ? correlations.filter((correlation) => correlation.atomType === atomType)
        : [];
}
exports.getCorrelationsByAtomType = getCorrelationsByAtomType;

},{}],410:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLabel = void 0;
function getLabel(correlations, correlation) {
    const label = Object.keys(correlation.attachment)
        .map((otherAtomType) => correlation.attachment[otherAtomType]
        .map((index) => {
        var _a;
        return ((_a = correlations[index]) === null || _a === void 0 ? void 0 : _a.label)
            ? correlation.label[correlations[index].label.origin]
            : '';
    })
        .filter((_label) => _label && _label.length > 0))
        .flat()
        .filter((_label, i, a) => a.indexOf(_label) === i)
        .sort((a, b) => Number(a.split(/[a-z]+/i)[1]) - Number(b.split(/[a-z]+/i)[1]) < 0
        ? -1
        : Number(a.split(/[a-z]+/i)[1]) - Number(b.split(/[a-z]+/i)[1]) === 0 &&
            a.split(/\d+/)[1] < b.split(/\d+/)[1]
            ? -1
            : 1)
        .join('/');
    if (label.length > 0) {
        return label;
    }
    return correlation.label.origin;
}
exports.getLabel = getLabel;

},{}],411:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLabels = void 0;
const getLabel_1 = require("./getLabel");
const sortLabels_1 = require("./sortLabels");
function getLabels(correlations, correlation, experimentType) {
    const labels = correlation.link
        .filter((link) => link.experimentType === experimentType)
        .map((link) => link.match
        .map((match) => {
        const matchingCorrelation = correlations[match];
        return (0, getLabel_1.getLabel)(correlations, matchingCorrelation);
    })
        .flat())
        .flat()
        .filter((label, i, a) => label.length > 0 && a.indexOf(label) === i);
    return (0, sortLabels_1.sortLabels)(labels);
}
exports.getLabels = getLabels;

},{"./getLabel":410,"./sortLabels":416}],412:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLinkDelta = void 0;
const getLinkDim_1 = require("./getLinkDim");
function getLinkDelta(link) {
    if (!link.pseudo) {
        return (0, getLinkDim_1.getLinkDim)(link) === 1
            ? link.signal.delta
            : link.axis === 'x'
                ? link.signal.x.delta
                : link.signal.y.delta;
    }
}
exports.getLinkDelta = getLinkDelta;

},{"./getLinkDim":413}],413:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLinkDim = void 0;
function getLinkDim(link) {
    return link.experimentType === '1d' ? 1 : 2;
}
exports.getLinkDim = getLinkDim;

},{}],414:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEditedHSQC = void 0;
function isEditedHSQC(experiment) {
    // detection whether experiment is an edited HSQC
    return experiment.info.pulseSequence.includes('hsqced');
}
exports.isEditedHSQC = isEditedHSQC;

},{}],415:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setPathLength = void 0;
const findLinksBySignalID_1 = require("./findLinksBySignalID");
function setPathLength(correlations, signalID, pathLength) {
    const links = (0, findLinksBySignalID_1.findLinksBySignalID)(correlations, signalID);
    links.forEach((link) => {
        var _a;
        const signal = link.signal;
        if (pathLength) {
            if (!signal.j) {
                signal.j = { pathLength };
            }
            else {
                signal.j.pathLength = pathLength;
            }
        }
        else {
            (_a = signal.j) === null || _a === void 0 ? true : delete _a.pathLength;
        }
    });
    return correlations;
}
exports.setPathLength = setPathLength;

},{"./findLinksBySignalID":403}],416:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortLabels = void 0;
function sortLabels(labels) {
    return labels.sort((a, b) => Number(a.split(/[a-z]+/i)[1]) - Number(b.split(/[a-z]+/i)[1]) < 0
        ? -1
        : Number(a.split(/[a-z]+/i)[1]) - Number(b.split(/[a-z]+/i)[1]) === 0 &&
            a.split(/\d+/)[1] < b.split(/\d+/)[1]
            ? -1
            : 1);
}
exports.sortLabels = sortLabels;

},{}],417:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setProtonsCount = void 0;
const checkMatch_1 = require("../general/checkMatch");
const getCorrelationDelta_1 = require("../general/getCorrelationDelta");
/**
 * Sets proton counts from DEPT90 signals and DEPT135/edited HSQC signals.
 *
 * @param {Values} correlations
 * @param {Array<{ delta: number }>} signals90
 * @param {Array<{ delta: number; sign?: number }>} signals135
 * @param {number} toleranceAtomType
 */
function setProtonsCount(correlations, signals90, signals135, toleranceAtomType) {
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < correlations.length; i++) {
        const correlation = correlations[i];
        if (correlation.edited.protonsCount) {
            // do not overwrite a manually edited value
            continue;
        }
        const correlationDelta = (0, getCorrelationDelta_1.getCorrelationDelta)(correlation);
        const match = [-1, -1];
        for (let k = 0; k < signals90.length; k++) {
            if (
            // signals90[k].sign === 1 &&
            correlationDelta !== undefined &&
                (0, checkMatch_1.checkMatch)(correlationDelta, signals90[k].delta, toleranceAtomType)) {
                match[0] = k;
                break;
            }
        }
        for (let k = 0; k < signals135.length; k++) {
            if (correlationDelta !== undefined &&
                (0, checkMatch_1.checkMatch)(correlationDelta, signals135[k].delta, toleranceAtomType)) {
                match[1] = k;
                break;
            }
        }
        if (match[0] >= 0) {
            // signal match in DEPT90
            // CH
            correlation.protonsCount = [1];
            continue;
        }
        // no signal match in DEPT90
        if (match[1] >= 0) {
            // signal match in DEPT135
            if (signals135[match[1]].sign === 1) {
                // positive signal
                if (signals90.length > 0) {
                    // in case of both DEPT90 and DEPT135 are given
                    // CH3
                    correlation.protonsCount = [3];
                }
                else {
                    // in case of DEPT135 is given only
                    // CH or CH3
                    correlation.protonsCount = [1, 3];
                }
            }
            else {
                // negative signal
                // CH2
                correlation.protonsCount = [2];
            }
        }
        else if (signals135.length > 0) {
            // no signal match in both spectra
            // qC
            correlation.protonsCount = [0];
        }
        else {
            // no information
            correlation.protonsCount = [];
        }
    }
    return correlations;
}
exports.setProtonsCount = setProtonsCount;

},{"../general/checkMatch":401,"../general/getCorrelationDelta":407}],418:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setProtonsCountFromDEPT = void 0;
const get_1 = __importDefault(require("lodash/get"));
const getCorrelationsByAtomType_1 = require("../general/getCorrelationsByAtomType");
const setProtonsCount_1 = require("./setProtonsCount");
/**
 * Sets proton counts from DEPT90 signals and DEPT135 signals.
 *
 * @param {Values} correlations
 * @param {Experiment1DSignals} signalsDEPT
 * @param {Tolerance} tolerance
 * @param {string} atomType
 */
function setProtonsCountFromDEPT(correlations, signalsDEPT, tolerance, atomType) {
    const correlationsAtomType = (0, getCorrelationsByAtomType_1.getCorrelationsByAtomType)(correlations, atomType).filter((correlation) => !correlation.pseudo);
    const signalsDEPT90 = (0, get_1.default)(signalsDEPT, '90', [])
        .filter((signalDEPT90) => signalDEPT90.atomType === atomType)
        .map((signalDEPT90) => signalDEPT90.signal);
    const signalsDEPT135 = (0, get_1.default)(signalsDEPT, '135', [])
        .filter((signalDEPT135) => signalDEPT135.atomType === atomType)
        .map((signalDEPT135) => signalDEPT135.signal);
    (0, setProtonsCount_1.setProtonsCount)(correlationsAtomType, signalsDEPT90, signalsDEPT135, tolerance[atomType]);
    return correlations;
}
exports.setProtonsCountFromDEPT = setProtonsCountFromDEPT;

},{"../general/getCorrelationsByAtomType":409,"./setProtonsCount":417,"lodash/get":130}],419:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setProtonsCountFromData = void 0;
const setProtonsCountFromDEPT_1 = require("./setProtonsCountFromDEPT");
const setProtonsCountFromEditedHSQC_1 = require("./setProtonsCountFromEditedHSQC");
/**
 * Sets proton counts from DEPT90 and/or DEPT135/edited HSQC signals, depending on what spectra data is given.
 *
 * @param {Values} correlations
 * @param {Experiment1DSignals} signalsDEPT
 * @param {Experiment2DSignals} signals2D
 * @param {Tolerance} tolerance
 */
function setProtonsCountFromData(correlations, signalsDEPT, signals2D, tolerance) {
    const heavyAtomTypes = [];
    correlations.forEach((correlation) => {
        if (!correlation.pseudo &&
            correlation.atomType !== 'H' &&
            !heavyAtomTypes.includes(correlation.atomType)) {
            heavyAtomTypes.push(correlation.atomType);
            if (Object.keys(signalsDEPT).length > 0) {
                (0, setProtonsCountFromDEPT_1.setProtonsCountFromDEPT)(correlations, signalsDEPT, tolerance, correlation.atomType);
            }
            else {
                (0, setProtonsCountFromEditedHSQC_1.setProtonsCountFromEditedHSQC)(correlations, signals2D, tolerance, correlation.atomType);
            }
        }
    });
    return correlations;
}
exports.setProtonsCountFromData = setProtonsCountFromData;

},{"./setProtonsCountFromDEPT":418,"./setProtonsCountFromEditedHSQC":420}],420:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setProtonsCountFromEditedHSQC = void 0;
const get_1 = __importDefault(require("lodash/get"));
const setProtonsCount_1 = require("./setProtonsCount");
/**
 * Sets proton counts from edited HSQC signals.
 *
 * @param {Values} correlations
 * @param {Experiment2DSignals} signals2D
 * @param {Tolerance} tolerance
 * @param {string} heavyAtomType
 */
function setProtonsCountFromEditedHSQC(correlations, signals2D, tolerance, heavyAtomType) {
    const correlationsAtomTypeHSQC = correlations.filter((correlation) => !correlation.pseudo && correlation.atomType === heavyAtomType);
    const signalsEditedHSQC = (0, get_1.default)(signals2D, 'hsqc', [])
        .filter((signal2D) => signal2D.atomType[1] === heavyAtomType && signal2D.signal.sign !== 0)
        .map((signal2D) => {
        return { delta: signal2D.signal.y.delta, sign: signal2D.signal.sign };
    });
    (0, setProtonsCount_1.setProtonsCount)(correlationsAtomTypeHSQC, [], signalsEditedHSQC, tolerance[heavyAtomType]);
    return correlations;
}
exports.setProtonsCountFromEditedHSQC = setProtonsCountFromEditedHSQC;

},{"./setProtonsCount":417,"lodash/get":130}],421:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignals = void 0;
const getExperiments_1 = require("../experiment/getExperiments");
const getExperiments1D_1 = require("../experiment/getExperiments1D");
const getExperiments1DExtra_1 = require("../experiment/getExperiments1DExtra");
const getExperiments2D_1 = require("../experiment/getExperiments2D");
const getSignals1D_1 = require("./getSignals1D");
const getSignals2D_1 = require("./getSignals2D");
const getSignalsDEPT_1 = require("./getSignalsDEPT");
// general remark for all experiment types:
// build an array of experiments, because one could have more than
// one spectrum in spectra list for one atom type or experiment type
/**
 * Get all signals from experiments with allowed signal kinds in "signalKindsToInclude".
 *
 * @param {Spectra} spectraData
 */
function getSignals(spectraData) {
    const experiments = (0, getExperiments_1.getExperiments)(spectraData);
    const experiments1D = (0, getExperiments1D_1.getExperiments1D)(experiments);
    const experiments1DExtra = (0, getExperiments1DExtra_1.getExperiments1DExtra)(experiments);
    const experiments2D = (0, getExperiments2D_1.getExperiments2D)(experiments);
    const signals1D = (0, getSignals1D_1.getSignals1D)(experiments1D);
    const signals2D = (0, getSignals2D_1.getSignals2D)(experiments2D);
    const signalsDEPT = (0, getSignalsDEPT_1.getSignalsDEPT)(experiments1DExtra);
    return {
        signals1D,
        signals2D,
        signalsDEPT,
    };
}
exports.getSignals = getSignals;

},{"../experiment/getExperiments":397,"../experiment/getExperiments1D":398,"../experiment/getExperiments1DExtra":399,"../experiment/getExperiments2D":400,"./getSignals1D":422,"./getSignals2D":423,"./getSignalsDEPT":424}],422:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignals1D = void 0;
const allowedSignalKinds_1 = require("../../constants/allowedSignalKinds");
const checkMatch_1 = require("../general/checkMatch");
/**
 * Get all different 1D signals from experiments with allowed signal kinds in "signalKindsToInclude".
 *
 * @param {ExperimentsType} experiments1D
 */
function getSignals1D(experiments1D) {
    // store valid signals from 1D experiments
    const signals1DByAtomType = {};
    for (const atomType in experiments1D) {
        const signals = [];
        const experiment = experiments1D[`${atomType}`] || [];
        if (experiment.length === 0)
            continue;
        const index = 0;
        const spectrum1D = experiment[index];
        for (const range of spectrum1D.ranges.values) {
            for (const signal of range.signals) {
                if (!signal.kind || !allowedSignalKinds_1.allowedSignalKinds.includes(signal.kind))
                    continue;
                if (!checkExistence(signal, signals)) {
                    signals.push({
                        experimentType: '1d',
                        experimentID: spectrum1D.id,
                        integration: signal.integration
                            ? signal.integration
                            : range.integration,
                        atomType,
                        signal: { ...signal },
                    });
                }
            }
        }
        signals1DByAtomType[atomType] = signals;
    }
    return signals1DByAtomType;
}
exports.getSignals1D = getSignals1D;
function checkExistence(current, group) {
    for (const element of group) {
        if ((0, checkMatch_1.checkMatch)(element.signal.delta, current.delta, 0.0)) {
            return true;
        }
    }
    return false;
}

},{"../../constants/allowedSignalKinds":367,"../general/checkMatch":401}],423:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignals2D = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const allowedSignalKinds_1 = require("../../constants/allowedSignalKinds");
const checkMatch_1 = require("../general/checkMatch");
const getAtomTypeFromNucleus_1 = require("../general/getAtomTypeFromNucleus");
const isEditedHSQC_1 = require("../general/isEditedHSQC");
/**
 * Get all different 2D signals from experiments with allowed signal kinds in "signalKindsToInclude".
 *
 * @param {ExperimentsType} experiments1D
 */
function getSignals2D(experiments2D) {
    // store valid signals from 2D experiments
    const _signals2D = {};
    Object.keys(experiments2D).forEach((experimentType) => {
        const _signals = [];
        // for now we use the first occurring spectrum only, for each experiment type (current loop) and nuclei combination
        const indices = [];
        const nuclei = [];
        experiments2D[experimentType].forEach((_experiment, i) => {
            const experiment = _experiment;
            if (!nuclei.some((_nuclei) => (0, isEqual_1.default)(_nuclei, experiment.info.nucleus))) {
                nuclei.push(experiment.info.nucleus);
                indices.push(i);
            }
        });
        indices.forEach((index) => {
            const spectrum2D = experiments2D[experimentType][index];
            const atomType = spectrum2D.info.nucleus.map((nucleus) => (0, getAtomTypeFromNucleus_1.getAtomTypeFromNucleus)(nucleus));
            const __signals = spectrum2D.zones.values
                .map((zone) => zone.signals.filter((signal) => signal.kind && allowedSignalKinds_1.allowedSignalKinds.includes(signal.kind)))
                .flat();
            __signals.forEach((signal) => {
                if (!_signals.some((_signal) => (0, checkMatch_1.checkMatch)(_signal.signal.x.delta, signal.x.delta, 0.0) &&
                    (0, checkMatch_1.checkMatch)(_signal.signal.y.delta, signal.y.delta, 0.0))) {
                    _signals.push({
                        experimentType,
                        experimentID: spectrum2D.id,
                        atomType,
                        // @TODO here we assume that only one peak exists for the signal and its intensity indicates the sign
                        signal: {
                            ...(0, cloneDeep_1.default)(signal),
                            sign: (0, isEditedHSQC_1.isEditedHSQC)(spectrum2D) && signal.peaks
                                ? signal.peaks[0].z >= 0
                                    ? 1
                                    : -1
                                : 0,
                        },
                    });
                }
            });
        });
        _signals2D[experimentType] = _signals;
    });
    return _signals2D;
}
exports.getSignals2D = getSignals2D;

},{"../../constants/allowedSignalKinds":367,"../general/checkMatch":401,"../general/getAtomTypeFromNucleus":406,"../general/isEditedHSQC":414,"lodash/cloneDeep":128,"lodash/isEqual":135}],424:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignalsDEPT = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const allowedSignalKinds_1 = require("../../constants/allowedSignalKinds");
const checkMatch_1 = require("../general/checkMatch");
const getAtomTypeFromNucleus_1 = require("../general/getAtomTypeFromNucleus");
/**
 * Get all DEPT signals from experiments with allowed signal kinds in "signalKindsToInclude".
 *
 * @param {ExperimentsType} experiments1DExtra
 */
function getSignalsDEPT(experiments1DExtra) {
    // store valid signals from 1D extra experiments, e.g. DEPT, APT
    const _signalsDEPT = {};
    // store valid signals from 2D experiments
    Object.keys(experiments1DExtra)
        .filter((experimentType) => experimentType === 'dept')
        .forEach((experimentType) => experiments1DExtra[experimentType].forEach((_experimentDEPT) => {
        const experimentDEPT = _experimentDEPT;
        const _signals = [];
        const match = experimentDEPT.info.pulseSequence.match(/\d/g);
        if (match) {
            const mode = match.reduce((_mode, digit) => _mode + digit);
            const atomType = (0, getAtomTypeFromNucleus_1.getAtomTypeFromNucleus)(experimentDEPT.info.nucleus);
            const __signals = experimentDEPT.ranges.values
                .map((range) => range.signals
                .filter((signal) => signal.kind && allowedSignalKinds_1.allowedSignalKinds.includes(signal.kind))
                .map((signal) => {
                return { ...signal, sign: range.absolute > 0 ? 1 : -1 };
            }))
                .flat();
            __signals.forEach((signal) => {
                if (!_signals.some((_signal) => (0, checkMatch_1.checkMatch)(_signal.signal.delta, signal.delta, 0.0))) {
                    _signals.push({
                        experimentType,
                        experimentID: experimentDEPT.id,
                        mode,
                        atomType,
                        signal: (0, cloneDeep_1.default)(signal),
                    });
                }
            });
            _signalsDEPT[mode] = _signals;
        }
    }));
    return _signalsDEPT;
}
exports.getSignalsDEPT = getSignalsDEPT;

},{"../../constants/allowedSignalKinds":367,"../general/checkMatch":401,"../general/getAtomTypeFromNucleus":406,"lodash/cloneDeep":128}],425:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.apodization = void 0;
const applyWindow_1 = require("./applyWindow");
const compose_1 = require("./compose");
function apodization(data, options) {
    const { compose: composeOptions, pointsToShift } = options;
    const windowData = (0, compose_1.compose)(composeOptions);
    const applyWindowOptions = {
        windowData,
        pointsToShift,
    };
    const re = (0, applyWindow_1.applyWindow)(data.re, applyWindowOptions);
    const im = (0, applyWindow_1.applyWindow)(data.im, applyWindowOptions);
    return { re, im, windowData };
}
exports.apodization = apodization;

},{"./applyWindow":426,"./compose":427}],426:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyWindow = void 0;
/**
 * pure function that applies a window function to the input data.
 */
function applyWindow(data, options) {
    const dataLength = data.length;
    const { windowData, start = 0, length = dataLength, pointsToShift = 0, output = new Float64Array(data), } = options;
    const firstEndPoint = Math.min(start + length, dataLength - pointsToShift);
    for (let i = start, j = 0; i < firstEndPoint; i++) {
        output[i] *= windowData[j++];
    }
    for (let i = dataLength - 1, j = 0; i > dataLength - pointsToShift - 1; i--) {
        output[i] *= windowData[j++];
    }
    return output;
}
exports.applyWindow = applyWindow;

},{}],427:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compose = void 0;
const applyWindow_1 = require("./applyWindow");
const getFunction_1 = require("./getFunction");
const getData_1 = require("./utils/getData");
function compose(shapeOptions) {
    const { length: dataLength, shapes = [] } = shapeOptions;
    let data = new Float64Array(dataLength).fill(1);
    shapes.forEach((options) => {
        const { shape, start = 0 } = options;
        const { options: shapeOptions } = shape;
        const length = 'length' in shapeOptions ? shapeOptions.length : dataLength - start;
        const windowData = (0, getData_1.getData)((0, getFunction_1.getFunction)(shape), length);
        (0, applyWindow_1.applyWindow)(data, {
            windowData,
            length,
            start,
            output: data,
        });
    });
    return data;
}
exports.compose = compose;

},{"./applyWindow":426,"./getFunction":428,"./utils/getData":431}],428:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunction = void 0;
const exponential_1 = require("./shapes/exponential");
const lorentzToGauss_1 = require("./shapes/lorentzToGauss");
function getFunction(shape) {
    const { kind, options } = shape;
    switch (kind) {
        case 'exponential':
            return (0, exponential_1.exponential)(options);
        case 'lorentzToGauss':
            return (0, lorentzToGauss_1.lorentzToGauss)(options);
        default:
            throw Error(`Unknown distribution ${kind}`);
    }
}
exports.getFunction = getFunction;

},{"./shapes/exponential":429,"./shapes/lorentzToGauss":430}],429:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exponential = void 0;
function exponential(options) {
    const { lb, dw } = options;
    const coefExp = -lb * Math.PI * dw;
    return (i) => Math.exp(coefExp * i);
}
exports.exponential = exponential;

},{}],430:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lorentzToGauss = void 0;
function lorentzToGauss(options) {
    const { dw, length, gaussianHz = 0, exponentialHz = 0, center = 0 } = options;
    if (center > 1 || center < 0) {
        throw new Error('The center of gaussian shape should be inside of the window function: 0 - 1');
    }
    const C5 = Math.pow(0.6 * Math.PI * gaussianHz * dw, 2);
    const C2 = center * (length - 1);
    const C6 = Math.PI * dw * exponentialHz;
    return (i) => Math.exp(i * C6 - Math.pow(C2 - i, 2) * C5);
}
exports.lorentzToGauss = lorentzToGauss;

},{}],431:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getData = void 0;
/**
 * generate and scale the data of a window function
 */
function getData(func, length) {
    const data = new Float64Array(length);
    let max = Number.MIN_SAFE_INTEGER;
    for (let i = 0; i < length; i++) {
        const value = func(i);
        data[i] = value;
        if (value > max)
            max = value;
    }
    for (let i = 0; i < length; i++)
        data[i] /= max;
    return data;
}
exports.getData = getData;

},{}],432:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get13CAssignments = void 0;
const uuid_1 = require("@lukeed/uuid");
const openchemlib_utils_1 = require("openchemlib-utils");
const predictCarbon_1 = require("../prediction/predictCarbon");
const buildAssignments_1 = require("./utils/buildAssignments");
function checkAtomsAndDiaIDs(signals) {
    for (const signal of signals) {
        if (!signal.atoms)
            throw new Error('signal has not atoms property');
        if (!signal.diaIDs)
            throw new Error('signal has not diaIDs property');
        if (!signal.nbAtoms)
            throw new Error('signal has not nbAtoms property');
    }
}
function checkIntegration(ranges) {
    for (let range of ranges) {
        if (range.integration === undefined)
            range.integration = 0;
    }
    return ranges;
}
async function get13CAssignments(ranges, molecule, options = {}) {
    let { restrictionByCS = {}, minScore = 1, maxSolutions = 10, nbAllowedUnAssigned = 0, timeout = 6000, predictionOptions = {}, } = options;
    if (!molecule) {
        throw new Error('It is needed a OCL molecule instance to assign');
    }
    (0, openchemlib_utils_1.addDiastereotopicMissingChirality)(molecule);
    const { joinedSignals } = await (0, predictCarbon_1.predictCarbon)(molecule, predictionOptions);
    checkAtomsAndDiaIDs(joinedSignals);
    const copyRanges = checkIntegration(ranges);
    const targets = {};
    for (const range of copyRanges) {
        const { id = (0, uuid_1.v4)() } = range;
        targets[id] = JSON.parse(JSON.stringify(range));
    }
    return (0, buildAssignments_1.buildAssignments)({
        restrictionByCS,
        timeout,
        minScore,
        nbAllowedUnAssigned,
        maxSolutions,
        targets,
        joinedSignals,
        useIntegrationRestriction: false,
    });
}
exports.get13CAssignments = get13CAssignments;

},{"../prediction/predictCarbon":474,"./utils/buildAssignments":435,"@lukeed/uuid":1,"openchemlib-utils":525}],433:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get1HAssignments = void 0;
const uuid_1 = require("@lukeed/uuid");
const openchemlib_utils_1 = require("openchemlib-utils");
const predictProton_1 = require("../prediction/predictProton");
const buildAssignments_1 = require("./utils/buildAssignments");
function checkAtomsAndDiaIDs(signals) {
    for (const signal of signals) {
        if (!signal.atoms)
            throw new Error('signal has not atoms property');
        if (!signal.diaIDs)
            throw new Error('signal has not diaIDs property');
        if (!signal.nbAtoms)
            throw new Error('signal has not nbAtoms property');
    }
}
function checkForIntegration(ranges) {
    for (let range of ranges) {
        if (range.integration === undefined) {
            throw new Error('ranges has not integration property');
        }
    }
}
async function get1HAssignments(ranges, molecule, options = {}) {
    let { restrictionByCS, minScore = 1, maxSolutions = 10, nbAllowedUnAssigned = 0, timeout = 6000, predictionOptions = {}, } = options;
    if (!molecule) {
        throw new Error('It is needed a OCL molecule instance to assign');
    }
    molecule.addImplicitHydrogens();
    (0, openchemlib_utils_1.addDiastereotopicMissingChirality)(molecule);
    const { joinedSignals } = await (0, predictProton_1.predictProton)(molecule, predictionOptions);
    checkForIntegration(ranges);
    checkAtomsAndDiaIDs(joinedSignals);
    const targets = {};
    for (const range of ranges) {
        const { id = (0, uuid_1.v4)() } = range;
        targets[id] = JSON.parse(JSON.stringify(range));
    }
    return (0, buildAssignments_1.buildAssignments)({
        restrictionByCS,
        timeout,
        minScore,
        nbAllowedUnAssigned,
        maxSolutions,
        targets,
        joinedSignals,
        useIntegrationRestriction: true,
    });
}
exports.get1HAssignments = get1HAssignments;

},{"../prediction/predictProton":477,"./utils/buildAssignments":435,"@lukeed/uuid":1,"openchemlib-utils":525}],434:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssignments = void 0;
const openchemlib_utils_1 = require("openchemlib-utils");
const buildAssignments_1 = require("./utils/getAssignment/buildAssignments");
const checkIDs_1 = require("./utils/getAssignment/checkIDs");
const getTargetsAndCorrelations_1 = require("./utils/getAssignment/getTargetsAndCorrelations");
const getWorkFlow_1 = __importDefault(require("./utils/getAssignment/getWorkFlow"));
async function getAssignments(input, options = {}) {
    let { restrictionByCS = {}, justAssign, minScore = 0.01, maxSolutions = 10, nbAllowedUnAssigned, timeout = 6000, predictionOptions = {}, predictions = {}, correlation: correlationOptions = {}, } = options;
    const { tolerance = { H: 0.2, C: 1 }, useChemicalShiftScore = false, chemicalShiftRestriction = true, } = restrictionByCS;
    const molecule = input.molecule;
    if (!molecule)
        throw new Error('It is needed a molecule to assign');
    molecule.addImplicitHydrogens();
    (0, openchemlib_utils_1.addDiastereotopicMissingChirality)(molecule);
    const spectra = (0, checkIDs_1.checkIDs)(input.spectra);
    const { targets, correlations } = (0, getTargetsAndCorrelations_1.getTargetsAndCorrelations)(spectra, correlationOptions);
    const { assignmentOrder } = (0, getWorkFlow_1.default)(correlations, justAssign);
    const solutions = await (0, buildAssignments_1.buildAssignments)({
        restrictionByCS: {
            tolerance,
            useChemicalShiftScore,
            chemicalShiftRestriction,
        },
        spectra,
        molecule,
        timeout,
        minScore,
        maxSolutions,
        assignmentOrder,
        nbAllowedUnAssigned,
        correlations,
        targets,
        predictionOptions,
        predictions,
    });
    return solutions;
}
exports.getAssignments = getAssignments;

},{"./utils/getAssignment/buildAssignments":438,"./utils/getAssignment/checkIDs":439,"./utils/getAssignment/getTargetsAndCorrelations":444,"./utils/getAssignment/getWorkFlow":445,"openchemlib-utils":525}],435:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAssignments = void 0;
const ml_tree_set_1 = __importDefault(require("ml-tree-set"));
const createMapPossibleAssignments_1 = require("./createMapPossibleAssignments");
const exploreTreeRec_1 = require("./exploreTreeRec");
const comparator = (a, b) => {
    return b.score - a.score;
};
async function buildAssignments(props) {
    const { restrictionByCS = {}, useIntegrationRestriction, timeout, minScore, nbAllowedUnAssigned, maxSolutions, targets, joinedSignals, } = props;
    const { tolerance = 1, useChemicalShiftScore = false, chemicalShiftRestriction = true, } = restrictionByCS;
    let store = {
        solutions: new ml_tree_set_1.default(comparator),
        nSolutions: 0,
    };
    let nSources = joinedSignals.length;
    const predictions = {};
    for (let prediction of joinedSignals) {
        const diaID = prediction.diaIDs[0];
        const index = prediction.atoms[0];
        predictions[diaID] = {
            ...prediction,
            diaIDIndex: index,
            allHydrogens: prediction.nbAtoms,
        };
    }
    const possibleAssignmentMap = (0, createMapPossibleAssignments_1.createMapPossibleAssignments)({
        restrictionByCS: {
            tolerance,
            useChemicalShiftScore,
            chemicalShiftRestriction,
        },
        useIntegrationRestriction,
        predictions,
        targets,
    });
    const diaIDPeerPossibleAssignment = Object.keys(possibleAssignmentMap);
    let partial = fillPartial(nSources);
    store = {
        solutions: new ml_tree_set_1.default(comparator),
        nSolutions: 0,
    };
    const timeStart = Date.now();
    (0, exploreTreeRec_1.exploreTreeRec)({
        nSources,
        restrictionByCS: {
            tolerance,
            useChemicalShiftScore,
            chemicalShiftRestriction,
        },
        timeout,
        timeStart,
        targets,
        predictions,
        maxSolutions,
        lowerBoundScore: minScore,
        nbAllowedUnAssigned,
        possibleAssignmentMap,
        diaIDPeerPossibleAssignment,
        useIntegrationRestriction,
    }, 0, partial, store);
    const assignments = [];
    for (const solution of store.solutions.elements) {
        const { assignment, score } = solution;
        const currentAssignment = JSON.parse(JSON.stringify(targets));
        for (let i = 0; i < assignment.length; i++) {
            let range = currentAssignment[assignment[i]];
            if (!range.diaIDs)
                range.diaIDs = [];
            if (assignment[i])
                range.diaIDs.push(diaIDPeerPossibleAssignment[i]);
        }
        assignments.push({
            score,
            assignment: Object.values(currentAssignment),
        });
    }
    return assignments;
}
exports.buildAssignments = buildAssignments;
function fillPartial(nSources, value = null) {
    const partial = new Array(nSources);
    for (let i = 0; i < nSources; i++) {
        partial[i] = value;
    }
    return partial;
}

},{"./createMapPossibleAssignments":436,"./exploreTreeRec":437,"ml-tree-set":364}],436:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMapPossibleAssignments = void 0;
function createMapPossibleAssignments(props) {
    const { restrictionByCS, predictions, targets, useIntegrationRestriction } = props;
    const { tolerance: toleranceCS, chemicalShiftRestriction } = restrictionByCS;
    let errorAbs = Math.abs(toleranceCS);
    const expandMap = {};
    for (const diaID in predictions) {
        let prediction = predictions[diaID];
        if (prediction.error)
            prediction.error = Math.abs(prediction.error);
        expandMap[diaID] = [];
        if (targets) {
            for (const targetID in targets) {
                let target = targets[targetID];
                const { nbAtoms } = prediction;
                const { integration } = target;
                const couldBeAssigned = useIntegrationRestriction
                    ? integration > 0
                        ? nbAtoms - integration < 1
                        : true
                    : true;
                if (couldBeAssigned) {
                    if (!chemicalShiftRestriction ||
                        typeof prediction.delta === 'undefined') {
                        // Chemical shift is not a restriction
                        expandMap[diaID].push(targetID);
                    }
                    else {
                        let error = errorAbs;
                        if (prediction.error) {
                            error = Math.max(error, prediction.error);
                        }
                        const delta = target.signals && target.signals.length > 0
                            ? target.signals[0].delta
                            : (target.to + target.from) / 2;
                        let distAfterLimit = Math.abs(prediction.delta - delta - errorAbs);
                        if (distAfterLimit < 4 * errorAbs) {
                            expandMap[diaID].push(targetID);
                        }
                    }
                }
            }
        }
        expandMap[diaID].push('*');
    }
    return expandMap;
}
exports.createMapPossibleAssignments = createMapPossibleAssignments;

},{}],437:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exploreTreeRec = void 0;
const partialScore_1 = require("./partialScore");
function exploreTreeRec(props, currentIndex, partial, store) {
    const { nSources, restrictionByCS, timeout, timeStart, maxSolutions, targets, predictions, lowerBoundScore, nbAllowedUnAssigned, possibleAssignmentMap, useIntegrationRestriction, diaIDPeerPossibleAssignment, } = props;
    if (Date.now() - timeStart > timeout) {
        new Error('timeout expired');
        return store;
    }
    const diaID = diaIDPeerPossibleAssignment[currentIndex];
    const possibleAssignments = possibleAssignmentMap[diaID];
    for (let targetID of possibleAssignments) {
        partial[currentIndex] = targetID;
        let score = (0, partialScore_1.partialScore)(partial, {
            useIntegrationRestriction,
            diaIDPeerPossibleAssignment,
            nbAllowedUnAssigned,
            restrictionByCS,
            predictions,
            targets,
        });
        if (score === 0) {
            if (targetID === '*') {
                partial[currentIndex] = null;
            }
            continue;
        }
        if (currentIndex === nSources - 1 && score >= lowerBoundScore) {
            addSolution(store, { predictions, partial, score, maxSolutions });
        }
        else if (currentIndex < nSources - 1) {
            exploreTreeRec({
                nSources,
                restrictionByCS,
                timeout,
                timeStart,
                maxSolutions,
                targets,
                predictions,
                lowerBoundScore,
                nbAllowedUnAssigned,
                possibleAssignmentMap,
                useIntegrationRestriction,
                diaIDPeerPossibleAssignment,
            }, currentIndex + 1, JSON.parse(JSON.stringify(partial)), store);
        }
    }
}
exports.exploreTreeRec = exploreTreeRec;
function addSolution(store, props) {
    let { score, maxSolutions, partial, predictions } = props;
    score /= doubleAssignmentPenalty(partial, predictions);
    store.nSolutions++;
    let solution = {
        assignment: JSON.parse(JSON.stringify(partial)),
        score,
    };
    if (store.nSolutions >= maxSolutions) {
        if (solution.score > store.solutions.last().score) {
            store.solutions.pollLast();
            store.solutions.add(solution);
        }
    }
    else {
        store.solutions.add(solution);
        store.nSolutions++;
    }
}
function doubleAssignmentPenalty(partial, predictions) {
    const nbSources = Object.keys(predictions).length;
    let assignments = new Set(partial);
    let nbDoubleAssignment = nbSources - assignments.size;
    return nbDoubleAssignment > 0 ? 2 * nbDoubleAssignment : 1;
}

},{"./partialScore":450}],438:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAssignments = exports.getAllHydrogens = void 0;
const ml_tree_set_1 = __importDefault(require("ml-tree-set"));
const openchemlib_utils_1 = require("openchemlib-utils");
const predictCarbon_1 = require("../../../prediction/predictCarbon");
const predictProton_1 = require("../../../prediction/predictProton");
const createMapPossibleAssignment_1 = require("./createMapPossibleAssignment");
const exploreTree_1 = require("./exploreTree");
const isSpectraData1D_1 = require("./isSpectraData1D");
const searchIndices_1 = require("./searchIndices");
const comparator = (a, b) => {
    return b.score - a.score;
};
const predictor = { H: predictProton_1.predictProton, C: predictCarbon_1.predictCarbon };
function checkNMRSignal1D(signals) {
    const keys = [
        'nbAtoms',
        'diaIDs',
        'atoms',
    ];
    for (const signal of signals) {
        for (let key of keys) {
            if (!signal[key])
                throw new Error(`property ${key} does not exist`);
        }
    }
}
exports.getAllHydrogens = {
    C: (m, i) => m.getAllHydrogens(i),
    H: () => 1,
};
async function buildAssignments(props) {
    const { spectra, molecule, restrictionByCS, timeout, minScore, nbAllowedUnAssigned = {}, maxSolutions, correlations, assignmentOrder, predictionOptions, predictions: inputPrediction = {}, targets, } = props;
    let lowerBoundScore = minScore;
    let store = {
        solutions: new ml_tree_set_1.default(comparator),
        nSolutions: 0,
    };
    const pathLengthMatrix = (0, openchemlib_utils_1.getConnectivityMatrix)(molecule, {
        pathLength: true,
    });
    let infoByAtomType = {};
    const predictions = {};
    let possibleAssignmentMap = {};
    let diaIDPeerPossibleAssignment = {};
    for (const atomTypesToPredict of assignmentOrder) {
        for (const atomType of atomTypesToPredict) {
            const options = predictionOptions[atomType];
            const predictedSignals = inputPrediction[atomType];
            let { joinedSignals } = predictedSignals
                ? { joinedSignals: predictedSignals }
                : await predictor[atomType](molecule, options);
            checkNMRSignal1D(joinedSignals);
            if (!predictions[atomType])
                predictions[atomType] = {};
            let totalHydrogens = 0;
            for (let prediction of joinedSignals) {
                const diaID = prediction.diaIDs[0];
                const index = prediction.atoms[0];
                const allHydrogens = exports.getAllHydrogens[atomType](molecule, index);
                totalHydrogens += prediction.nbAtoms * allHydrogens;
                predictions[atomType][diaID] = {
                    ...prediction,
                    diaIDIndex: index,
                    allHydrogens: prediction.nbAtoms * allHydrogens,
                    protonsCount: allHydrogens,
                    pathLength: pathLengthMatrix[index],
                };
            }
            for (let diaID in predictions[atomType]) {
                predictions[atomType][diaID].allHydrogens *= 100 / totalHydrogens;
            }
            infoByAtomType[atomType] = {
                nSources: joinedSignals.length,
                currentIndex: 0,
                nbAllowedUnAssigned: nbAllowedUnAssigned[atomType] || 0,
            };
        }
        possibleAssignmentMap = (0, createMapPossibleAssignment_1.createMapPossibleAssignment)(possibleAssignmentMap, {
            restrictionByCS,
            predictions,
            targets,
        });
        diaIDPeerPossibleAssignment = {};
        for (const atomType in possibleAssignmentMap) {
            diaIDPeerPossibleAssignment[atomType] = Object.keys(possibleAssignmentMap[atomType]);
        }
        let sourceOfPartials = getSourceOfPartials(store, infoByAtomType, atomTypesToPredict);
        store = {
            solutions: new ml_tree_set_1.default(comparator),
            nSolutions: 0,
        };
        const timeStart = Date.now();
        for (let partial of sourceOfPartials) {
            (0, exploreTree_1.exploreTree)({
                currentAtomTypes: atomTypesToPredict,
                restrictionByCS,
                timeout,
                timeStart,
                targets,
                predictions,
                correlations,
                maxSolutions,
                lowerBoundScore,
                possibleAssignmentMap,
                diaIDPeerPossibleAssignment,
            }, infoByAtomType, partial, store);
        }
    }
    return annotateSpectraData({
        store,
        spectra,
        diaIDPeerPossibleAssignment,
        targets,
    });
}
exports.buildAssignments = buildAssignments;
function annotateSpectraData(input) {
    var _a, _b;
    const { store, spectra, diaIDPeerPossibleAssignment, targets } = input;
    const { solutions } = store;
    const mapSignalId = {};
    const atomTypes = Object.keys(targets);
    for (const atomType of atomTypes) {
        const targetByAtomType = targets[atomType];
        for (const targetId in targetByAtomType) {
            let target = targetByAtomType[targetId];
            for (const link of target.link) {
                const signalId = link.signal.id;
                if (mapSignalId[signalId])
                    continue;
                mapSignalId[link.signal.id] = (0, searchIndices_1.searchIndices)(signalId, spectra);
            }
        }
    }
    const result = [];
    for (let solution of solutions.elements) {
        const spectraResult = JSON.parse(JSON.stringify(spectra));
        const { assignment, score } = solution;
        const atomTypes = Object.keys(assignment);
        for (const atomType of atomTypes) {
            const targetByAtomType = targets[atomType];
            const assignmentPeerAtomType = assignment[atomType];
            for (let index = 0; index < assignmentPeerAtomType.length; index++) {
                const targetID = assignmentPeerAtomType[index];
                if (targetID === '*' || !targetID)
                    continue;
                const target = targetByAtomType[targetID];
                const diaId = diaIDPeerPossibleAssignment[atomType][index];
                for (let link of target.link) {
                    const { spectrumIndex, elementIndex, signalIndex } = mapSignalId[link.signal.id];
                    const spectrum = spectraResult[spectrumIndex];
                    if ((0, isSpectraData1D_1.isSpectraData1D)(spectrum)) {
                        let { ranges } = spectrum;
                        let range = ranges[elementIndex];
                        let signal = range.signals[signalIndex];
                        if (!signal.diaIDs)
                            signal.diaIDs = [];
                        if (signal.diaIDs.includes(diaId))
                            continue;
                        signal.diaIDs.push(diaId);
                    }
                    else {
                        const axis = link.axis;
                        const signal = spectrum.zones[elementIndex].signals[signalIndex];
                        if (!signal[axis].diaIDs)
                            signal[axis].diaIDs = [];
                        if ((_a = signal[axis].diaIDs) === null || _a === void 0 ? void 0 : _a.includes(diaId))
                            continue;
                        (_b = signal[axis].diaIDs) === null || _b === void 0 ? void 0 : _b.push(diaId);
                    }
                }
            }
        }
        result.push({
            score,
            assignment: spectraResult,
        });
    }
    return result;
}
function getSourceOfPartials(store, infoByAtomType, currentAtoms) {
    return store.nSolutions > 0
        ? store.solutions.elements.map((e) => {
            let currentAssignment = e.assignment;
            for (const atom of currentAtoms) {
                currentAssignment[atom] = fillPartial(infoByAtomType[atom].nSources);
            }
            return currentAssignment;
        })
        : initializePartials(infoByAtomType, currentAtoms);
}
function initializePartials(infoByAtomType, currentAtoms) {
    const partial = {};
    const atomsType = Object.keys(infoByAtomType);
    for (const atom of atomsType) {
        const value = currentAtoms.includes(atom) ? null : '*';
        partial[atom] = fillPartial(infoByAtomType[atom].nSources, value);
    }
    return [partial];
}
function fillPartial(nSources, value = null) {
    const partial = new Array(nSources);
    for (let i = 0; i < nSources; i++) {
        partial[i] = value;
    }
    return partial;
}

},{"../../../prediction/predictCarbon":474,"../../../prediction/predictProton":477,"./createMapPossibleAssignment":440,"./exploreTree":441,"./isSpectraData1D":447,"./searchIndices":449,"ml-tree-set":364,"openchemlib-utils":525}],439:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addIDs = exports.hasIDs = exports.checkIDs = void 0;
const uuid_1 = require("@lukeed/uuid");
const isSpectraData1D_1 = require("./isSpectraData1D");
function checkIDs(input = []) {
    let inputClone = JSON.parse(JSON.stringify(input));
    let spectra = [];
    for (const spectraData of inputClone) {
        if (!('info' in spectraData)) {
            throw new Error('each spectrum should contain info properties with nucleus information');
        }
        const { info, id } = spectraData;
        if ((0, isSpectraData1D_1.isSpectraData1D)(spectraData)) {
            let ranges = addIDs(spectraData.ranges);
            spectra.push({ id, info, ranges });
        }
        else {
            let data = addIDs(spectraData.zones);
            spectra.push({ id, info, zones: data });
        }
    }
    return spectra;
}
exports.checkIDs = checkIDs;
function hasIDs(data) {
    for (const element of data) {
        if (!element.id)
            throw new Error('A range/zone has not an ID');
        for (let signal of element.signals || []) {
            if (!signal.id)
                throw new Error('A signal has not an ID');
        }
    }
}
exports.hasIDs = hasIDs;
function addIDs(data) {
    for (const element of data) {
        if (!element.id)
            element.id = (0, uuid_1.v4)();
        for (let signal of element.signals || []) {
            if (!signal.id)
                signal.id = (0, uuid_1.v4)();
        }
    }
    hasIDs(data);
    return data;
}
exports.addIDs = addIDs;

},{"./isSpectraData1D":447,"@lukeed/uuid":1}],440:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMapPossibleAssignment = void 0;
const nmr_correlation_1 = require("nmr-correlation");
function createMapPossibleAssignment(expandMap, props) {
    const { restrictionByCS, predictions, targets } = props;
    const { tolerance: toleranceCS, chemicalShiftRestriction } = restrictionByCS;
    const atomTypes = Object.keys(predictions);
    for (const atomType of atomTypes) {
        let errorAbs = toleranceCS[atomType];
        let predictionByAtomType = predictions[atomType];
        let targetByAtomType = targets[atomType];
        if (!expandMap[atomType])
            expandMap[atomType] = {};
        for (const diaID in predictionByAtomType) {
            let prediction = predictionByAtomType[diaID];
            expandMap[atomType][diaID] = [];
            if (targetByAtomType) {
                for (const targetID in targetByAtomType) {
                    let target = targetByAtomType[targetID];
                    const { nbAtoms, protonsCount: protonsCountFromPrediction } = prediction;
                    const { integration, protonsCount } = target;
                    const couldBeAssigned = !integration
                        ? true
                        : atomType === 'H'
                            ? nbAtoms - integration < 1
                            : protonsCount.length > 0
                                ? protonsCount.some((count) => protonsCountFromPrediction === count)
                                : true;
                    if (couldBeAssigned) {
                        if (!chemicalShiftRestriction ||
                            typeof prediction.delta === 'undefined') {
                            // Chemical shift is not a restriction
                            expandMap[atomType][diaID].push(targetID);
                        }
                        else {
                            let targetDelta = (0, nmr_correlation_1.getCorrelationDelta)(target);
                            if (targetDelta === undefined) {
                                throw new Error(`Correlation has not delta`);
                            }
                            let distAfterLimit = Math.abs(prediction.delta - targetDelta - errorAbs);
                            if (distAfterLimit < 4 * errorAbs) {
                                expandMap[atomType][diaID].push(targetID);
                            }
                        }
                    }
                }
            }
            expandMap[atomType][diaID].push('*');
        }
    }
    return expandMap;
}
exports.createMapPossibleAssignment = createMapPossibleAssignment;

},{"nmr-correlation":368}],441:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exploreTree = void 0;
const partialScore_1 = require("./partialScore");
function exploreTree(props, infoByAtomTypes, partial, store) {
    const { currentAtomTypes, restrictionByCS, timeout, timeStart, maxSolutions, targets, predictions, correlations, lowerBoundScore, possibleAssignmentMap, diaIDPeerPossibleAssignment, } = props;
    if (Date.now() - timeStart > timeout) {
        new Error('timeout expired');
        return store;
    }
    for (const atomType of currentAtomTypes) {
        const { currentIndex, nSources } = infoByAtomTypes[atomType];
        if (currentIndex >= nSources - 1 &&
            partial[atomType][currentIndex] !== null) {
            continue;
        }
        const diaID = diaIDPeerPossibleAssignment[atomType][currentIndex];
        const possibleAssignments = possibleAssignmentMap[atomType][diaID];
        for (let targetID of possibleAssignments) {
            partial[atomType][currentIndex] = targetID;
            let score = (0, partialScore_1.partialScore)(partial, {
                diaIDPeerPossibleAssignment,
                infoByAtomTypes,
                restrictionByCS,
                predictions,
                correlations,
                targets,
            });
            if (score === 0) {
                continue;
            }
            if (isLastOne(currentAtomTypes, infoByAtomTypes) &&
                score >= lowerBoundScore) {
                addSolution(store, { predictions, partial, score, maxSolutions });
            }
            else {
                const newInfo = JSON.parse(JSON.stringify(infoByAtomTypes));
                newInfo[atomType].currentIndex += 1;
                exploreTree({
                    currentAtomTypes,
                    restrictionByCS,
                    timeout,
                    timeStart,
                    maxSolutions,
                    targets,
                    predictions,
                    correlations,
                    lowerBoundScore,
                    possibleAssignmentMap,
                    diaIDPeerPossibleAssignment,
                }, newInfo, JSON.parse(JSON.stringify(partial)), store);
            }
        }
    }
}
exports.exploreTree = exploreTree;
function addSolution(store, props) {
    let { score, maxSolutions, partial, predictions } = props;
    score /= doubleAssignmentPenalty(partial, predictions);
    let solution = {
        assignment: JSON.parse(JSON.stringify(partial)),
        score,
    };
    if (store.nSolutions >= maxSolutions) {
        if (solution.score > store.solutions.last().score) {
            store.solutions.pollLast();
            store.solutions.add(solution);
        }
    }
    else {
        store.solutions.add(solution);
        store.nSolutions++;
    }
}
function isLastOne(currentAtomTypes, infoByAtomTypes) {
    let lastOne = true;
    for (const atomType of currentAtomTypes) {
        const { currentIndex, nSources } = infoByAtomTypes[atomType];
        lastOne = lastOne && currentIndex >= nSources - 1;
    }
    return lastOne;
}
function doubleAssignmentPenalty(partial, predictions) {
    let nbDoubleAssignment = 0;
    for (const atomType in predictions) {
        const nbSources = Object.keys(predictions[atomType]).length;
        let assignments = new Set(partial[atomType]);
        nbDoubleAssignment += nbSources - assignments.size;
    }
    return nbDoubleAssignment > 0 ? 2 * nbDoubleAssignment : 1;
}

},{"./partialScore":448}],442:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatData = void 0;
const isSpectraData1D_1 = require("./isSpectraData1D");
function formatData(input = []) {
    let inputClone = JSON.parse(JSON.stringify(input));
    let spectra = [];
    for (const spectraData of inputClone) {
        const { id, info } = spectraData;
        if ((0, isSpectraData1D_1.isSpectraData1D)(spectraData)) {
            const ranges = rescaleIntegration({
                id,
                info,
                ranges: spectraData.ranges,
            });
            spectra.push({ id, info, ranges: { values: ranges } });
        }
        else {
            spectra.push({ id, info, zones: { values: spectraData.zones } });
        }
    }
    return spectra;
}
exports.formatData = formatData;
function rescaleIntegration(spectrum) {
    if (spectrum.info.nucleus !== '1H')
        return spectrum.ranges;
    let totalIntegration = spectrum.ranges.reduce((total, range) => (range.integration ? total + range.integration : total), 0);
    for (let range of spectrum.ranges) {
        if (range.integration) {
            range.integration *= 100 / totalIntegration;
            if (range.signals) {
                const totalSignalIntegration = range.signals.reduce((total, signal) => signal.integration ? total + signal.integration : total, 0);
                for (let signal of range.signals) {
                    if (signal.integration) {
                        signal.integration *= range.integration / totalSignalIntegration;
                    }
                    else {
                        signal.integration = range.integration;
                    }
                }
            }
        }
    }
    return spectrum.ranges;
}

},{"./isSpectraData1D":447}],443:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIntegrationOfAttachedProtons = void 0;
function getIntegrationOfAttachedProtons(target, correlations) {
    const { H: attachment = [] } = target.attachment;
    let integration = 0;
    for (const match of attachment) {
        const correlation = correlations[match];
        integration += Number(correlation.link[0].signal.integration);
    }
    return integration;
}
exports.getIntegrationOfAttachedProtons = getIntegrationOfAttachedProtons;

},{}],444:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetsAndCorrelations = void 0;
const nmr_correlation_1 = require("nmr-correlation");
const formatData_1 = require("./formatData");
const getIntegrationOfAttachedProtons_1 = require("./getIntegrationOfAttachedProtons");
function getTargetsAndCorrelations(spectra, options = {}) {
    //add indirect links, if a carbon C1 is attached to a proton H1 that correlating
    //with carbon C2, so the carbon C1 and C2 are also correlating
    const { tolerance = { C: 0.25, H: 0.05 } } = options;
    const spectraData = (0, formatData_1.formatData)(spectra);
    const { values: correlations } = (0, nmr_correlation_1.buildCorrelationData)(spectraData, {
        tolerance,
    });
    let targets = {};
    for (const correlation of correlations) {
        if (correlation.pseudo)
            continue;
        const { id: targetID, atomType } = correlation;
        if (!targets[atomType])
            targets[atomType] = {};
        targets[atomType][targetID] = correlation;
        if (atomType === 'H') {
            targets[atomType][targetID].integration =
                correlation.link[0].signal.integration;
        }
        else {
            targets[atomType][targetID].integration = (0, getIntegrationOfAttachedProtons_1.getIntegrationOfAttachedProtons)(correlation, correlations);
        }
    }
    return {
        targets,
        correlations,
    };
}
exports.getTargetsAndCorrelations = getTargetsAndCorrelations;

},{"./formatData":442,"./getIntegrationOfAttachedProtons":443,"nmr-correlation":368}],445:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * if hsqc is present in experimentTypes we can just predict 13C
 * spectrum and try to assign the carbons first.
 * @param {*} correlations
 * @param {*} justAssign
 */
function getWorkFlow(correlations, justAssign = []) {
    const experimentTypes = extractExperimentType(correlations);
    const { hasHSQC, types } = experimentTypes;
    if (justAssign.length > 0) {
        return { assignmentOrder: justAssign, experimentTypes };
    }
    const assignmentOrder = [];
    if (hasHSQC) {
        assignmentOrder.push(['C'], ['H']);
    }
    else {
        assignmentOrder.push(types.filter((type) => type === 'H' || type === 'C'));
    }
    return { assignmentOrder, experimentTypes };
}
exports.default = getWorkFlow;
function extractExperimentType(correlations) {
    const types = [];
    for (const correlation of correlations) {
        let experimentType = correlation.experimentType;
        if (experimentType === '1d') {
            experimentType = `${correlation.atomType.toUpperCase()}`;
        }
        if (!types.includes(experimentType)) {
            types.push(experimentType);
        }
        for (const link of correlation.link) {
            experimentType = link.experimentType;
            if (experimentType === '1d') {
                experimentType = `${link.atomType[0].toUpperCase()}`;
            }
            if (!types.includes(experimentType)) {
                types.push(experimentType);
            }
        }
    }
    return {
        types,
        hasProton: types.includes('H'),
        hasCarbon: types.includes('C'),
        hasHSQC: types.includes('hsqc'),
    };
}

},{}],446:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function groupCarbonTargetByIntegrationZone(activeDomainOnTarget, targets, correlations) {
    let targetID = activeDomainOnTarget[0];
    let { H: attachments = [] } = targets[targetID].attachment;
    let targetByIntegral = [
        { targetIDs: [targetID], attachments: new Set(attachments) },
    ];
    for (let i = 1; i < activeDomainOnTarget.length; i++) {
        let targetID = activeDomainOnTarget[i];
        let target = targets[targetID];
        let { H: attachments = [] } = target.attachment;
        let alone = true;
        for (let group of targetByIntegral) {
            const pertain = attachments.some((attachment) => group.attachments.has(attachment));
            if (pertain) {
                alone = false;
                group.targetIDs.push(targetID);
                for (let attachment of attachments) {
                    group.attachments.add(attachment);
                }
                break;
            }
        }
        if (alone) {
            targetByIntegral.push({
                targetIDs: [targetID],
                attachments: new Set(attachments),
            });
        }
    }
    return targetByIntegral.map((t) => ({
        atomType: 'C',
        targetIDs: t.targetIDs,
        integration: correlations
            ? Array.from(t.attachments).reduce((sum, index) => {
                return correlations[index].integration + sum;
            }, 0)
            : 0,
    }));
}
exports.default = groupCarbonTargetByIntegrationZone;

},{}],447:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSpectraData1D = void 0;
function isSpectraData1D(spectrum) {
    return 'ranges' in spectrum;
}
exports.isSpectraData1D = isSpectraData1D;

},{}],448:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.partialScore = void 0;
const nmr_correlation_1 = require("nmr-correlation");
const groupCarbonTargetByIntegrationZone_1 = __importDefault(require("./groupCarbonTargetByIntegrationZone"));
function partialScore(partial, props) {
    const { diaIDPeerPossibleAssignment, infoByAtomTypes, restrictionByCS, predictions, targets, correlations, } = props;
    const { tolerance: toleranceCS, useChemicalShiftScore } = restrictionByCS;
    let totalStarts = 0;
    let totalPartial = 0;
    let partialInverse = {};
    let activeDomainOnPrediction = {};
    const atomTypes = Object.keys(partial);
    for (const atomType of atomTypes) {
        let countStars = 0;
        const { nbAllowedUnAssigned } = infoByAtomTypes[atomType];
        const currentPartialInverse = {};
        const partialAssignment = partial[atomType] || [];
        partialInverse[atomType] = currentPartialInverse;
        activeDomainOnPrediction[atomType] = [];
        totalPartial += partialAssignment.length;
        for (let i = 0; i < partialAssignment.length; i++) {
            const targetID = partialAssignment[i];
            if (targetID && targetID !== '*') {
                activeDomainOnPrediction[atomType].push(i);
                if (!currentPartialInverse[targetID]) {
                    currentPartialInverse[targetID] = [];
                }
                currentPartialInverse[targetID].push(diaIDPeerPossibleAssignment[atomType][i]);
            }
            if (targetID === '*')
                countStars++;
        }
        if (countStars > nbAllowedUnAssigned)
            return 0;
        totalStarts += countStars;
    }
    const activeDomainOnTarget = {};
    for (const atomType in partialInverse) {
        activeDomainOnTarget[atomType] = Object.keys(partialInverse[atomType]);
    }
    const valuesActiveDomainOnTarget = Object.values(activeDomainOnTarget);
    if (valuesActiveDomainOnTarget.reduce((sum, e) => (e.length === 0 ? sum + 1 : sum), 0) === valuesActiveDomainOnTarget.length) {
        return 0;
    }
    const getPredictionByDiaID = getPrediction.bind({}, predictions);
    // check the integration
    const targetByIntegral = [];
    for (const atomType in partial) {
        if (atomType === 'C' && activeDomainOnTarget[atomType].length > 0) {
            targetByIntegral.push(...(0, groupCarbonTargetByIntegrationZone_1.default)(activeDomainOnTarget[atomType], targets[atomType], correlations));
        }
        else {
            for (let targetID of activeDomainOnTarget[atomType]) {
                targetByIntegral.push({
                    atomType,
                    targetIDs: [targetID],
                    integration: targets.H[targetID].integration,
                });
            }
        }
    }
    for (const group of targetByIntegral) {
        const { integration, atomType } = group;
        if (integration === undefined || isNaN(integration))
            continue;
        let total = 0;
        for (let targetID of group.targetIDs) {
            let targetToSource = partialInverse[atomType][targetID];
            for (const diaID of targetToSource) {
                const { prediction, atomType: atomOfPrediction } = getPredictionByDiaID(diaID);
                if (atomType === atomOfPrediction)
                    total += prediction.allHydrogens;
            }
        }
        if (total - integration >= 5) {
            return 0;
        }
    }
    //chemical shift score
    let count = 1;
    let chemicalShiftScore = 1;
    if (useChemicalShiftScore) {
        chemicalShiftScore = 0;
        count = 0;
        for (const atomType of Object.keys(partial)) {
            const partialPeerAtomType = partial[atomType];
            const targetsPeerAtomType = targets[atomType];
            for (let index = 0; index < partialPeerAtomType.length; index++) {
                const targetID = partialPeerAtomType[index];
                if (targetID && targetID !== '*') {
                    count++;
                    let diaID = diaIDPeerPossibleAssignment[atomType][index];
                    let source = predictions[atomType][diaID];
                    let target = targetsPeerAtomType[targetID];
                    let error = toleranceCS[atomType];
                    // if (source.error) {
                    //   error = Math.max(source.error, toleranceCS);
                    // }
                    if (typeof source.delta === 'undefined') {
                        // Chemical shift is not a restriction
                        chemicalShiftScore += 1;
                    }
                    else {
                        const targetDelta = (0, nmr_correlation_1.getCorrelationDelta)(target);
                        if (targetDelta === undefined) {
                            throw new Error('correlation has not delta');
                        }
                        let diff = Math.abs(source.delta - targetDelta);
                        if (diff < error) {
                            //@TODO: check for a better discriminant
                            chemicalShiftScore += 1;
                        }
                        else {
                            diff = Math.abs(diff - error);
                            chemicalShiftScore += (-0.25 / error) * diff + 1;
                        }
                    }
                }
            }
        }
        if (count > 0) {
            chemicalShiftScore /= count;
        }
    }
    let scoreOn2D = 0;
    if (howManyActived(activeDomainOnTarget) > 1) {
        let andConstrains = {};
        let activeDomain = [];
        for (const atomType of Object.keys(activeDomainOnPrediction)) {
            activeDomain = activeDomain.concat(activeDomainOnPrediction[atomType].map((e) => ({ index: e, atomType })));
        }
        for (let i = 0; i < activeDomain.length; i++) {
            const { atomType: atomTypeI, index: indexI } = activeDomain[i];
            const predictionI = predictions[atomTypeI][diaIDPeerPossibleAssignment[atomTypeI][indexI]];
            for (let j = i + 1; j < activeDomain.length; j++) {
                const { atomType: atomTypeJ, index: indexJ } = activeDomain[j];
                const predictionJ = predictions[atomTypeJ][diaIDPeerPossibleAssignment[atomTypeJ][indexJ]];
                let pathLength = predictionI.pathLength[predictionJ.diaIDIndex];
                let isPossible = pathLength < 5;
                let partialI = partial[atomTypeI][indexI];
                let partialJ = partial[atomTypeJ][indexJ];
                if (!partialI || !partialJ)
                    continue;
                let keyOnTargertMap = partialI > partialJ
                    ? `${partialJ} ${partialI}`
                    : `${partialI} ${partialJ}`;
                let areLinked = checkLinking({
                    from: {
                        targetID: partialI,
                        atomType: atomTypeI,
                    },
                    to: {
                        targetID: partialJ,
                        atomType: atomTypeJ,
                    },
                }, targets);
                let partialScore2D = isPossible
                    ? areLinked
                        ? 1
                        : 0
                    : !areLinked
                        ? 1
                        : 0;
                andConstrains[keyOnTargertMap] = andConstrains[keyOnTargertMap]
                    ? Math.max(andConstrains[keyOnTargertMap], partialScore2D)
                    : partialScore2D;
            }
        }
        let sumAnd = 0;
        for (let key in andConstrains) {
            sumAnd += andConstrains[key];
        }
        scoreOn2D =
            sumAnd / ((activeDomain.length * (activeDomain.length - 1)) / 2);
    }
    const penaltyByStarts = totalStarts / totalPartial;
    if (chemicalShiftScore === 0)
        return scoreOn2D - penaltyByStarts;
    if (scoreOn2D === 0)
        return chemicalShiftScore - penaltyByStarts;
    return (chemicalShiftScore + scoreOn2D) / 2 - penaltyByStarts;
}
exports.partialScore = partialScore;
function checkLinking(partials, correlations) {
    const { from, to } = partials;
    if (from.targetID === to.targetID)
        return true;
    let correlationI = correlations[from.atomType][from.targetID];
    let correlationJ = correlations[to.atomType][to.targetID];
    for (const linkJ of correlationJ.link) {
        for (const link of correlationI.link) {
            if (link.signal.id === linkJ.signal.id)
                return true;
        }
    }
    return false;
}
function getPrediction(predictions, diaID) {
    const atomTypes = Object.keys(predictions);
    for (const atomType of atomTypes) {
        const predictionByAtomType = predictions[atomType];
        if (!predictionByAtomType)
            throw new Error(`prediction by ${atomType}`);
        if (predictionByAtomType[diaID]) {
            return { atomType, prediction: predictionByAtomType[diaID] };
        }
    }
    throw new Error(`There is not prediction for ${diaID}`);
}
function howManyActived(actived) {
    let sum = 0;
    for (const atom in actived) {
        sum += actived[atom].length;
    }
    return sum;
}

},{"./groupCarbonTargetByIntegrationZone":446,"nmr-correlation":368}],449:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchIndices = void 0;
const isSpectraData1D_1 = require("./isSpectraData1D");
function searchIndices(signalId, spectra) {
    for (let spectrumIndex = 0; spectrumIndex < spectra.length; spectrumIndex++) {
        const spectrum = spectra[spectrumIndex];
        const data = (0, isSpectraData1D_1.isSpectraData1D)(spectrum) ? spectrum.ranges : spectrum.zones;
        for (let elementIndex = 0; elementIndex < data.length; elementIndex++) {
            const signals = data[elementIndex].signals || [];
            for (let signalIndex = 0; signalIndex < signals.length; signalIndex++) {
                if (signalId === signals[signalIndex].id) {
                    return { spectrumIndex, signalIndex, elementIndex };
                }
            }
        }
    }
    throw new Error(`There is not a signal with ${signalId} ID`);
}
exports.searchIndices = searchIndices;

},{"./isSpectraData1D":447}],450:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.partialScore = void 0;
function partialScore(partial, options) {
    const { useIntegrationRestriction, diaIDPeerPossibleAssignment, nbAllowedUnAssigned, restrictionByCS, predictions, targets, } = options;
    const { useChemicalShiftScore } = restrictionByCS;
    let countStars = 0;
    let totalPartial = partial.length;
    let partialInverse = {};
    let activeDomainOnPrediction = [];
    for (let i = 0; i < partial.length; i++) {
        const targetID = partial[i];
        if (targetID && targetID !== '*') {
            activeDomainOnPrediction.push(i);
            if (!partialInverse[targetID]) {
                partialInverse[targetID] = [];
            }
            partialInverse[targetID].push(diaIDPeerPossibleAssignment[i]);
        }
        if (targetID === '*')
            countStars++;
    }
    if (countStars > nbAllowedUnAssigned)
        return 0;
    const activeDomainOnTarget = Object.keys(partialInverse);
    if (activeDomainOnTarget.length === 0) {
        return 0;
    }
    if (useIntegrationRestriction) {
        for (let targetID of activeDomainOnTarget) {
            let targetToSource = partialInverse[targetID];
            let total = 0;
            for (const diaID of targetToSource) {
                const prediction = predictions[diaID];
                total += prediction.allHydrogens;
            }
            const { integration } = targets[targetID];
            if (total - integration >= 0.5) {
                return 0;
            }
        }
    }
    //chemical shift score
    let chemicalShiftScore = useChemicalShiftScore
        ? chemicalShiftScoring(partial, options)
        : 1;
    const penaltyByStarts = countStars / totalPartial;
    return chemicalShiftScore - penaltyByStarts;
}
exports.partialScore = partialScore;
function chemicalShiftScoring(partial, options) {
    const { tolerance } = options.restrictionByCS;
    const { diaIDPeerPossibleAssignment, predictions, targets } = options;
    let chemicalShiftScore = 0;
    let count = 0;
    for (let index = 0; index < partial.length; index++) {
        const targetID = partial[index];
        if (targetID && targetID !== '*') {
            count++;
            let diaID = diaIDPeerPossibleAssignment[index];
            let source = predictions[diaID];
            let target = targets[targetID];
            let error = tolerance;
            if (source.error) {
                error = Math.max(source.error, tolerance);
            }
            if (typeof source.delta === 'undefined') {
                // Chemical shift is not a restriction
                chemicalShiftScore += 1;
            }
            else {
                const delta = target.signals && target.signals.length > 0
                    ? target.signals[0].delta
                    : (target.to + target.from) / 2;
                let diff = Math.abs(source.delta - delta);
                if (diff < error) {
                    chemicalShiftScore += 1;
                }
                else {
                    diff = Math.abs(diff - error);
                    chemicalShiftScore += (-0.25 / error) * diff + 1;
                }
            }
        }
    }
    if (count > 0) {
        chemicalShiftScore /= count;
    }
    return chemicalShiftScore;
}

},{}],451:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.couplingPatterns = void 0;
exports.couplingPatterns = [
    's',
    'd',
    't',
    'q',
    'quint',
    'h',
    'sept',
    'o',
    'n',
];

},{}],452:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.couplingValues = void 0;
exports.couplingValues = {
    s: 0,
    d: 1,
    t: 2,
    q: 3,
    quint: 4,
    h: 5,
    hex: 5,
    hept: 6,
    sept: 6,
    oct: 7,
    o: 7,
    non: 8,
    n: 8,
};

},{}],453:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.impurities = void 0;
/* eslint-disable camelcase */
exports.impurities = {
    cdcl3: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: 'ds',
                shift: 7.26,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 'bs',
                shift: 1.56,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.1,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.17,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.1,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.36,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.28,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.19,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.22,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.98,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 5.01,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.27,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.43,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.26,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.43,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.73,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 5.3,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.21,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.48,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.65,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.57,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.39,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.4,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.55,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.09,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.02,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.94,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 8.02,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.96,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.88,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.62,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.71,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.25,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.72,
            },
            {
                proton: 'OH',
                coupling: 5,
                multiplicity: 's,t',
                shift: 1.32,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.05,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.12,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.26,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.14,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.46,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.06,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.76,
            },
        ],
        'grease^f': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 'm',
                shift: 0.86,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'br_s',
                shift: 1.26,
            },
        ],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.88,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.26,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.65,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.49,
            },
            {
                proton: 'OH',
                coupling: 0,
                multiplicity: 's',
                shift: 1.09,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.33,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 7,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.27,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.22,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 4.04,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.62,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.29,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.68,
            },
        ],
        silicone_greasei: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 0.07,
            },
        ],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.85,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.76,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.36,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.17,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.25,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.03,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.53,
            },
        ],
    },
    '(cd3)2co': {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 2.05,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 's',
                shift: 2.84,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.96,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.09,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.05,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.36,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.18,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.13,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.13,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.96,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.22,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.41,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 8.02,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.43,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.87,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 5.63,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.11,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.41,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.56,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.47,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.28,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.28,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.46,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.97,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.83,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.96,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.94,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.78,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.52,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.59,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.12,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.57,
            },
            {
                proton: 'OH',
                coupling: 5,
                multiplicity: 's,t',
                shift: 3.39,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.97,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.05,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.2,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.07,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.45,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.28,
            },
        ],
        'grease^f': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 'm',
                shift: 0.87,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'br_s',
                shift: 1.29,
            },
        ],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.88,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.28,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.59,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.31,
            },
            {
                proton: 'OH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.12,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.43,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.88,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.27,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.1,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 3.9,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.58,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.35,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.76,
            },
        ],
        silicone_greasei: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 0.13,
            },
        ],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.79,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.63,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.32,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.5,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.5,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.45,
            },
        ],
    },
    dmso: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: 'quint',
                shift: 2.5,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 's',
                shift: 3.33,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.91,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.09,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.07,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.37,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.11,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 4.19,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.11,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.08,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.87,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 6.65,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.18,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.36,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 8.32,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.4,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.9,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 5.76,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.09,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.38,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.51,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.38,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.24,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.24,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.43,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.96,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.94,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.78,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.95,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.89,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.73,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.54,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.57,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.06,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.44,
            },
            {
                proton: 'OH',
                coupling: 5,
                multiplicity: 's,t',
                shift: 4.63,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.99,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.03,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.17,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.07,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.43,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.91,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.34,
            },
        ],
        'grease^f': [],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.86,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.25,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.53,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.16,
            },
            {
                proton: 'OH',
                coupling: 0,
                multiplicity: 's',
                shift: 4.01,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.42,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.88,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.27,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.04,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 3.78,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.58,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.39,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.79,
            },
        ],
        silicone_greasei: [],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.76,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.6,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.3,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.18,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.25,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.93,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.43,
            },
        ],
    },
    c6d6: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 7.16,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 's',
                shift: 0.4,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.55,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.55,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.55,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.15,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.05,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 1.55,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.07,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.04,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.05,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 4.79,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.24,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.38,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.15,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.4,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 2.9,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 4.27,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.11,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.26,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.46,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.34,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.11,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.12,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.33,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.6,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.57,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.05,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.63,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.36,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.86,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.68,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.35,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.34,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.65,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.89,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.92,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.58,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 1.81,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.85,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.41,
            },
        ],
        'grease^f': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 'm',
                shift: 0.92,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'br_s',
                shift: 1.36,
            },
        ],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.89,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.24,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.4,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.07,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.94,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.86,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.23,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 0.95,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 3.67,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.53,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 6.66,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 6.98,
            },
        ],
        silicone_greasei: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 0.29,
            },
        ],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.4,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.57,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.11,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.02,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.13,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.4,
            },
        ],
    },
    cd3cn: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 1.94,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 's',
                shift: 2.13,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.96,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.08,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.96,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.37,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.16,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 2.18,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.14,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.13,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.97,
            },
            {
                proton: 'OHc',
                coupling: 0,
                multiplicity: 's',
                shift: 5.2,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.22,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.39,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.58,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.44,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.81,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 5.44,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.12,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.42,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.53,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.45,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.29,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.28,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.45,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.97,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.96,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.83,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.92,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.89,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.77,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.5,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.6,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.12,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.54,
            },
            {
                proton: 'OH',
                coupling: 5,
                multiplicity: 's,t',
                shift: 2.47,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 1.97,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.06,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.2,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.06,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.43,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.51,
            },
        ],
        'grease^f': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 'm',
                shift: 0.86,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'br_s',
                shift: 1.27,
            },
        ],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.89,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.28,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.57,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.28,
            },
            {
                proton: 'OH',
                coupling: 0,
                multiplicity: 's',
                shift: 2.16,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.31,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.87,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.29,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.09,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 3.87,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.57,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.33,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.73,
            },
        ],
        silicone_greasei: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 0.08,
            },
        ],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.8,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.64,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.33,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.2,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.2,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.96,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.45,
            },
        ],
    },
    cd3od: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 3.31,
            },
        ],
        h2o: [
            {
                proton: 'H2O',
                coupling: 0,
                multiplicity: 's',
                shift: 4.87,
            },
        ],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.99,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.15,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.03,
            },
        ],
        benzene: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.33,
            },
        ],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.4,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.15,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.2,
            },
        ],
        bhtb: [
            {
                proton: 'ArH',
                coupling: 0,
                multiplicity: 's',
                shift: 6.92,
            },
            {
                proton: 'ArCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.21,
            },
            {
                proton: 'ArC(CH3)3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.4,
            },
        ],
        chloroform: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.9,
            },
        ],
        cyclohexane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 1.45,
            },
        ],
        '1,2-dichloroethane': [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.78,
            },
        ],
        dichloromethane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 5.49,
            },
        ],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.18,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.49,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.61,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.58,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.35,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.35,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.52,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.07,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.31,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.92,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.97,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.99,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.86,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.65,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.66,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.19,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.6,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.01,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.09,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.24,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.12,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.5,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.01,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.59,
            },
        ],
        'grease^f': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 'm',
                shift: 0.88,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'br_s',
                shift: 1.29,
            },
        ],
        'n-hexane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 't',
                shift: 0.9,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.29,
            },
        ],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.64,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.34,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.34,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.89,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.29,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.5,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 3.92,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.53,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.44,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.85,
            },
        ],
        silicone_greasei: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 0.1,
            },
        ],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.87,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.71,
            },
        ],
        toluene: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.32,
            },
            {
                proton: 'CH(o/p)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.16,
            },
            {
                proton: 'CH(m)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.16,
            },
        ],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.05,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.58,
            },
        ],
    },
    d2o: {
        tms: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 0,
            },
        ],
        solvent: [
            {
                proton: 'X',
                coupling: 0,
                multiplicity: '',
                shift: 4.79,
            },
        ],
        h2o: [],
        acetic_acid: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.08,
            },
        ],
        acetone: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.22,
            },
        ],
        acetonitrile: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.06,
            },
        ],
        benzene: [],
        'tert-butyl_alcohol': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.24,
            },
        ],
        'tert-butyl_methyl_ether': [
            {
                proton: 'CCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 1.21,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.22,
            },
        ],
        bhtb: [],
        chloroform: [],
        cyclohexane: [],
        '1,2-dichloroethane': [],
        dichloromethane: [],
        diethyl_ether: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.17,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.56,
            },
        ],
        diglyme: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.67,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.61,
            },
            {
                proton: 'OCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.37,
            },
        ],
        '1,2-dimethoxyethane': [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.37,
            },
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.6,
            },
        ],
        dimethylacetamide: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.08,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.06,
            },
            {
                proton: 'NCH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.9,
            },
        ],
        dimethylformamide: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 7.92,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.01,
            },
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.85,
            },
        ],
        dimethyl_sulfoxide: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 2.71,
            },
        ],
        dioxane: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 's',
                shift: 3.75,
            },
        ],
        ethanol: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.17,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.65,
            },
        ],
        ethyl_acetate: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.07,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 4.14,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.24,
            },
        ],
        ethyl_methyl_ketone: [
            {
                proton: 'CH3CO',
                coupling: 0,
                multiplicity: 's',
                shift: 2.19,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 'q',
                shift: 3.18,
            },
            {
                proton: 'CH2CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 1.26,
            },
        ],
        ethylene_glycol: [
            {
                proton: 'CH',
                coupling: 0,
                multiplicity: 's',
                shift: 3.65,
            },
        ],
        'grease^f': [],
        'n-hexane': [],
        hmpag: [
            {
                proton: 'CH3',
                coupling: 9.5,
                multiplicity: 'd',
                shift: 2.61,
            },
        ],
        methanol: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 3.34,
            },
        ],
        nitromethane: [
            {
                proton: 'CH3',
                coupling: 0,
                multiplicity: 's',
                shift: 4.4,
            },
        ],
        'n-pentane': [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.9,
            },
        ],
        '2-propanol': [
            {
                proton: 'CH3',
                coupling: 6,
                multiplicity: 'd',
                shift: 1.17,
            },
            {
                proton: 'CH',
                coupling: 6,
                multiplicity: 'sep',
                shift: 4.02,
            },
        ],
        pyridine: [
            {
                proton: 'CH(2)',
                coupling: 0,
                multiplicity: 'm',
                shift: 8.52,
            },
            {
                proton: 'CH(3)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.45,
            },
            {
                proton: 'CH(4)',
                coupling: 0,
                multiplicity: 'm',
                shift: 7.87,
            },
        ],
        silicone_greasei: [],
        tetrahydrofuran: [
            {
                proton: 'CH2',
                coupling: 0,
                multiplicity: 'm',
                shift: 1.88,
            },
            {
                proton: 'CH2O',
                coupling: 0,
                multiplicity: 'm',
                shift: 3.74,
            },
        ],
        toluene: [],
        triethylamine: [
            {
                proton: 'CH3',
                coupling: 7,
                multiplicity: 't',
                shift: 0.99,
            },
            {
                proton: 'CH2',
                coupling: 7,
                multiplicity: 'q',
                shift: 2.57,
            },
        ],
    },
};

},{}],454:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.carbonImpurities = void 0;
exports.carbonImpurities = [
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 171.69,
                        assignment: 'CO',
                    },
                ],
                from: 171.68625,
                to: 171.69375,
            },
            {
                signals: [
                    {
                        delta: 20.13,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.12625,
                to: 20.13375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 204.19,
                        assignment: 'CO',
                    },
                ],
                from: 204.18625,
                to: 204.19375,
            },
            {
                signals: [
                    {
                        delta: 30.17,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.16625,
                to: 30.173750000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 116.79,
                        assignment: 'CN',
                    },
                ],
                from: 116.78625000000001,
                to: 116.79375,
            },
            {
                signals: [
                    {
                        delta: 0.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.44625000000000004,
                to: 0.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.84,
                        assignment: 'CH',
                    },
                ],
                from: 128.83625,
                to: 128.84375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.5,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 67.49625,
                to: 67.50375,
            },
            {
                signals: [
                    {
                        delta: 30.57,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.56625,
                to: 30.57375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 125.69,
                        assignment: 'CO₂',
                    },
                ],
                from: 125.68625,
                to: 125.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 193.37,
                        assignment: 'CS₂',
                    },
                ],
                from: 193.36625,
                to: 193.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.89,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.88625,
                to: 96.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 79.24,
                        assignment: 'CH',
                    },
                ],
                from: 79.23625,
                to: 79.24374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 71.34,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.33625,
                to: 71.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.58,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.576249999999998,
                to: 27.58375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 44.64,
                        assignment: 'CH₂',
                    },
                ],
                from: 44.636250000000004,
                to: 44.64375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.67,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.666250000000005,
                to: 54.67375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.49,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.48625,
                to: 15.49375,
            },
            {
                signals: [
                    {
                        delta: 66.14,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.13625,
                to: 66.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.72,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.71625,
                to: 58.723749999999995,
            },
            {
                signals: [
                    {
                        delta: 71.17,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.16625,
                to: 71.17375,
            },
            {
                signals: [
                    {
                        delta: 72.72,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.71625,
                to: 72.72375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 161.96,
                        assignment: 'CH',
                    },
                ],
                from: 161.95625,
                to: 161.96375,
            },
            {
                signals: [
                    {
                        delta: 35.65,
                        assignment: 'CH₃',
                    },
                ],
                from: 35.64625,
                to: 35.653749999999995,
            },
            {
                signals: [
                    {
                        delta: 30.7,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.69625,
                to: 30.70375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.65,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.64625000000001,
                to: 67.65375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.72,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.71625,
                to: 58.723749999999995,
            },
            {
                signals: [
                    {
                        delta: 72.58,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.57625,
                to: 72.58375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.79,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.78625,
                to: 6.79375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.9,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.89625,
                to: 18.90375,
            },
            {
                signals: [
                    {
                        delta: 57.6,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.596250000000005,
                to: 57.60375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.45,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.44625,
                to: 20.45375,
            },
            {
                signals: [
                    {
                        delta: 170.32,
                        assignment: 'CO',
                    },
                ],
                from: 170.31625,
                to: 170.32375,
            },
            {
                signals: [
                    {
                        delta: 60.3,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.29625,
                to: 60.303749999999994,
            },
            {
                signals: [
                    {
                        delta: 14.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.366249999999999,
                to: 14.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.09,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.08625,
                to: 123.09375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.35,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.34625,
                to: 64.35374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 30.45,
                        assignment: 'CH₂',
                    },
                ],
                from: 30.44625,
                to: 30.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 131.88,
                        assignment: 'C',
                    },
                ],
                from: 131.87625,
                to: 131.88375,
            },
            {
                signals: [
                    {
                        delta: 16.71,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.70625,
                to: 16.71375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.22,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.21625,
                to: 14.22375,
            },
            {
                signals: [
                    {
                        delta: 23.33,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.326249999999998,
                to: 23.33375,
            },
            {
                signals: [
                    {
                        delta: 32.34,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.33625000000001,
                to: 32.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.83,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.8262500000000002,
                to: 1.83375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.886250000000004,
                to: 36.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.72,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.71625,
                to: 135.72375,
            },
            {
                signals: [
                    {
                        delta: 122.2,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.19625,
                to: 122.20375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.9,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.9037500000000005,
                to: -4.89625,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.64,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.636250000000004,
                to: 49.64375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 62.49,
                        assignment: 'CH₃',
                    },
                ],
                from: 62.486250000000005,
                to: 62.49375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.18,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.17625,
                to: 14.18375,
            },
            {
                signals: [
                    {
                        delta: 23,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.99625,
                to: 23.00375,
            },
            {
                signals: [
                    {
                        delta: 34.87,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.86625,
                to: 34.873749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.6,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.59625,
                to: 16.60375,
            },
            {
                signals: [
                    {
                        delta: 16.82,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.81625,
                to: 16.82375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.7,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.69625,
                to: 25.70375,
            },
            {
                signals: [
                    {
                        delta: 66.14,
                        assignment: 'CH',
                    },
                ],
                from: 66.13625,
                to: 66.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.27,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.26625,
                to: 19.27375,
            },
            {
                signals: [
                    {
                        delta: 115.74,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.73625,
                to: 115.74374999999999,
            },
            {
                signals: [
                    {
                        delta: 134.02,
                        assignment: 'CH',
                    },
                ],
                from: 134.01625,
                to: 134.02375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.57,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.56625,
                to: 150.57375,
            },
            {
                signals: [
                    {
                        delta: 124.08,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 124.07625,
                to: 124.08375,
            },
            {
                signals: [
                    {
                        delta: 135.99,
                        assignment: 'CH(4)',
                    },
                ],
                from: 135.98625,
                to: 135.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.03,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 118.02625,
                to: 118.03375,
            },
            {
                signals: [
                    {
                        delta: 107.74,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 107.73625,
                to: 107.74374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.82,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 45.816250000000004,
                to: 45.82375,
            },
            {
                signals: [
                    {
                        delta: 26.17,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.16625,
                to: 26.173750000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.2,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.19625,
                to: 1.2037499999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.03,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.02625,
                to: 68.03375,
            },
            {
                signals: [
                    {
                        delta: 26.19,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.18625,
                to: 26.19375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.29,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.28625,
                to: 21.29375,
            },
            {
                signals: [
                    {
                        delta: 138.24,
                        assignment: 'C(1)',
                    },
                ],
                from: 138.23625,
                to: 138.24375,
            },
            {
                signals: [
                    {
                        delta: 129.47,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.46625,
                to: 129.47375,
            },
            {
                signals: [
                    {
                        delta: 128.71,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.70625,
                to: 128.71375,
            },
            {
                signals: [
                    {
                        delta: 125.84,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.83625,
                to: 125.84375,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.51,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.50625,
                to: 12.51375,
            },
            {
                signals: [
                    {
                        delta: 47.18,
                        assignment: 'CH₂',
                    },
                ],
                from: 47.17625,
                to: 47.183749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.85,
                        assignment: 'CO',
                    },
                ],
                from: 175.84625,
                to: 175.85375,
            },
            {
                signals: [
                    {
                        delta: 20.91,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.90625,
                to: 20.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 206.78,
                        assignment: 'CO',
                    },
                ],
                from: 206.77625,
                to: 206.78375,
            },
            {
                signals: [
                    {
                        delta: 31,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.99625,
                to: 31.00375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 116.92,
                        assignment: 'CN',
                    },
                ],
                from: 116.91625,
                to: 116.92375,
            },
            {
                signals: [
                    {
                        delta: 2.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.0262499999999997,
                to: 2.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.68,
                        assignment: 'CH',
                    },
                ],
                from: 128.67625,
                to: 128.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 69.11,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 69.10625,
                to: 69.11375,
            },
            {
                signals: [
                    {
                        delta: 31.46,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 31.45625,
                to: 31.46375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 125.26,
                        assignment: 'CO₂',
                    },
                ],
                from: 125.25625000000001,
                to: 125.26375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.95,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.94625,
                to: 192.95374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.52,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.51625,
                to: 96.52374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 77.99,
                        assignment: 'CH',
                    },
                ],
                from: 77.98625,
                to: 77.99374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.46625,
                to: 70.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.38,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.37625,
                to: 27.38375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 44.35,
                        assignment: 'CH₂',
                    },
                ],
                from: 44.346250000000005,
                to: 44.35375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.24,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.236250000000005,
                to: 54.24375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.44,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.43625,
                to: 15.44375,
            },
            {
                signals: [
                    {
                        delta: 66.11,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.10625,
                to: 66.11375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.95,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.946250000000006,
                to: 58.95375,
            },
            {
                signals: [
                    {
                        delta: 70.7,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.69625,
                to: 70.70375,
            },
            {
                signals: [
                    {
                        delta: 72.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.24625,
                to: 72.25375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.57,
                        assignment: 'CH',
                    },
                ],
                from: 162.56625,
                to: 162.57375,
            },
            {
                signals: [
                    {
                        delta: 36.56,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.556250000000006,
                to: 36.56375,
            },
            {
                signals: [
                    {
                        delta: 31.39,
                        assignment: 'CH₃',
                    },
                ],
                from: 31.38625,
                to: 31.39375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.46625,
                to: 67.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.02,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.01625000000001,
                to: 59.02375,
            },
            {
                signals: [
                    {
                        delta: 72.24,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.23625,
                to: 72.24374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.91,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.90625,
                to: 6.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.69,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.68625,
                to: 18.69375,
            },
            {
                signals: [
                    {
                        delta: 58.57,
                        assignment: 'CH₂',
                    },
                ],
                from: 58.566250000000004,
                to: 58.57375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.15,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 21.14625,
                to: 21.15375,
            },
            {
                signals: [
                    {
                        delta: 171.24,
                        assignment: 'CO',
                    },
                ],
                from: 171.23625,
                to: 171.24375,
            },
            {
                signals: [
                    {
                        delta: 60.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.626250000000006,
                to: 60.63375,
            },
            {
                signals: [
                    {
                        delta: 14.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.366249999999999,
                to: 14.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.2,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.19625,
                to: 123.20375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.08,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.07625,
                to: 64.08375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 30.14,
                        assignment: 'CH₂',
                    },
                ],
                from: 30.13625,
                to: 30.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 132.09,
                        assignment: 'C',
                    },
                ],
                from: 132.08625,
                to: 132.09375,
            },
            {
                signals: [
                    {
                        delta: 16.93,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.92625,
                to: 16.93375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.28,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.27625,
                to: 14.28375,
            },
            {
                signals: [
                    {
                        delta: 23.07,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.06625,
                to: 23.07375,
            },
            {
                signals: [
                    {
                        delta: 32.01,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.00625,
                to: 32.013749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.96,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.99,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.986250000000005,
                to: 36.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.76,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.75625,
                to: 135.76375,
            },
            {
                signals: [
                    {
                        delta: 122.16,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.15625,
                to: 122.16375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.33,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.33375,
                to: -4.32625,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 50.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 50.446250000000006,
                to: 50.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.026250000000005,
                to: 63.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.24,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.23625,
                to: 14.24375,
            },
            {
                signals: [
                    {
                        delta: 22.77,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.76625,
                to: 22.77375,
            },
            {
                signals: [
                    {
                        delta: 34.57,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.566250000000004,
                to: 34.57375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.62625,
                to: 16.63375,
            },
            {
                signals: [
                    {
                        delta: 16.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.62625,
                to: 16.63375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.43,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.42625,
                to: 25.43375,
            },
            {
                signals: [
                    {
                        delta: 64.67,
                        assignment: 'CH',
                    },
                ],
                from: 64.66625,
                to: 64.67375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.47,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.46625,
                to: 19.47375,
            },
            {
                signals: [
                    {
                        delta: 115.7,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.69625,
                to: 115.70375,
            },
            {
                signals: [
                    {
                        delta: 134.21,
                        assignment: 'CH',
                    },
                ],
                from: 134.20625,
                to: 134.21375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.27,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.26625,
                to: 150.27375,
            },
            {
                signals: [
                    {
                        delta: 124.06,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 124.05625,
                to: 124.06375,
            },
            {
                signals: [
                    {
                        delta: 136.16,
                        assignment: 'CH(4)',
                    },
                ],
                from: 136.15625,
                to: 136.16375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.93,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.92625000000001,
                to: 117.93375,
            },
            {
                signals: [
                    {
                        delta: 108.02,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.01625,
                to: 108.02374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 47.02,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 47.01625000000001,
                to: 47.02375,
            },
            {
                signals: [
                    {
                        delta: 25.83,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.826249999999998,
                to: 25.83375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.22,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.21625,
                to: 1.22375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.16,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.15625,
                to: 68.16375,
            },
            {
                signals: [
                    {
                        delta: 25.98,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.97625,
                to: 25.98375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.53,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.52625,
                to: 21.53375,
            },
            {
                signals: [
                    {
                        delta: 138.36,
                        assignment: 'C(1)',
                    },
                ],
                from: 138.35625000000002,
                to: 138.36375,
            },
            {
                signals: [
                    {
                        delta: 129.35,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.34625,
                to: 129.35375,
            },
            {
                signals: [
                    {
                        delta: 128.54,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.53625,
                to: 128.54375,
            },
            {
                signals: [
                    {
                        delta: 125.62,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.61625000000001,
                to: 125.62375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.12,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.116249999999999,
                to: 12.12375,
            },
            {
                signals: [
                    {
                        delta: 46.75,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.74625,
                to: 46.75375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.99,
                        assignment: 'CO',
                    },
                ],
                from: 175.98625,
                to: 175.99375,
            },
            {
                signals: [
                    {
                        delta: 20.81,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.80625,
                to: 20.81375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 207.07,
                        assignment: 'CO',
                    },
                ],
                from: 207.06625,
                to: 207.07375,
            },
            {
                signals: [
                    {
                        delta: 30.92,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.91625,
                to: 30.923750000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 116.43,
                        assignment: 'CN',
                    },
                ],
                from: 116.42625000000001,
                to: 116.43375,
            },
            {
                signals: [
                    {
                        delta: 1.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.88625,
                to: 1.8937499999999998,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.37,
                        assignment: 'CH',
                    },
                ],
                from: 128.36625,
                to: 128.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 69.15,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 69.14625000000001,
                to: 69.15375,
            },
            {
                signals: [
                    {
                        delta: 31.25,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 31.24625,
                to: 31.25375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 124.99,
                        assignment: 'CO₂',
                    },
                ],
                from: 124.98625,
                to: 124.99374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.83,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.82625000000002,
                to: 192.83375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.34,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.33625,
                to: 96.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 77.36,
                        assignment: 'CH',
                    },
                ],
                from: 77.35625,
                to: 77.36375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.55,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.54625,
                to: 70.55375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 26.94,
                        assignment: 'CH₂',
                    },
                ],
                from: 26.93625,
                to: 26.94375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 43.5,
                        assignment: 'CH₂',
                    },
                ],
                from: 43.49625,
                to: 43.50375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 53.52,
                        assignment: 'CH₂',
                    },
                ],
                from: 53.51625000000001,
                to: 53.52375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.2,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.19625,
                to: 15.20375,
            },
            {
                signals: [
                    {
                        delta: 65.91,
                        assignment: 'CH₂',
                    },
                ],
                from: 65.90625,
                to: 65.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.01,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.00625,
                to: 59.013749999999995,
            },
            {
                signals: [
                    {
                        delta: 70.51,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.50625000000001,
                to: 70.51375,
            },
            {
                signals: [
                    {
                        delta: 71.9,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.89625000000001,
                to: 71.90375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.62,
                        assignment: 'CH',
                    },
                ],
                from: 162.61625,
                to: 162.62375,
            },
            {
                signals: [
                    {
                        delta: 36.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.49625,
                to: 36.50375,
            },
            {
                signals: [
                    {
                        delta: 31.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 31.44625,
                to: 31.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.14,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.13625,
                to: 67.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.08,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.07625,
                to: 59.083749999999995,
            },
            {
                signals: [
                    {
                        delta: 71.84,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.83625,
                to: 71.84375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.8862499999999995,
                to: 6.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.41,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.40625,
                to: 18.41375,
            },
            {
                signals: [
                    {
                        delta: 58.28,
                        assignment: 'CH₂',
                    },
                ],
                from: 58.276250000000005,
                to: 58.28375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.04,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 21.03625,
                to: 21.04375,
            },
            {
                signals: [
                    {
                        delta: 171.36,
                        assignment: 'CO',
                    },
                ],
                from: 171.35625000000002,
                to: 171.36375,
            },
            {
                signals: [
                    {
                        delta: 60.49,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.486250000000005,
                to: 60.49375,
            },
            {
                signals: [
                    {
                        delta: 14.19,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.18625,
                to: 14.19375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.13,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.12625,
                to: 123.13374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.79,
                        assignment: 'CH₂',
                    },
                ],
                from: 63.78625,
                to: 63.793749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 29.71,
                        assignment: 'CH₂',
                    },
                ],
                from: 29.70625,
                to: 29.71375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 132.21,
                        assignment: 'C',
                    },
                ],
                from: 132.20625,
                to: 132.21375,
            },
            {
                signals: [
                    {
                        delta: 16.98,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.97625,
                to: 16.98375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.14,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.13625,
                to: 14.14375,
            },
            {
                signals: [
                    {
                        delta: 22.7,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 22.69625,
                to: 22.70375,
            },
            {
                signals: [
                    {
                        delta: 31.64,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 31.63625,
                to: 31.64375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.97,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.96625,
                to: 1.97375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.87,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.86625,
                to: 36.873749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.38,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.37625,
                to: 135.38375,
            },
            {
                signals: [
                    {
                        delta: 122,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 121.99625,
                to: 122.00375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.63,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.63375,
                to: -4.62625,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 50.41,
                        assignment: 'CH₃',
                    },
                ],
                from: 50.40625,
                to: 50.41374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 62.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 62.49625,
                to: 62.50375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.08,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.07625,
                to: 14.08375,
            },
            {
                signals: [
                    {
                        delta: 22.38,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.37625,
                to: 22.38375,
            },
            {
                signals: [
                    {
                        delta: 34.16,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.15625,
                to: 34.16374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.62625,
                to: 16.63375,
            },
            {
                signals: [
                    {
                        delta: 16.37,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.36625,
                to: 16.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.14,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.13625,
                to: 25.14375,
            },
            {
                signals: [
                    {
                        delta: 64.5,
                        assignment: 'CH',
                    },
                ],
                from: 64.49625,
                to: 64.50375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.49625,
                to: 19.50375,
            },
            {
                signals: [
                    {
                        delta: 115.74,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.73625,
                to: 115.74374999999999,
            },
            {
                signals: [
                    {
                        delta: 133.91,
                        assignment: 'CH',
                    },
                ],
                from: 133.90625,
                to: 133.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 149.9,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 149.89625,
                to: 149.90375,
            },
            {
                signals: [
                    {
                        delta: 123.75,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 123.74625,
                to: 123.75375,
            },
            {
                signals: [
                    {
                        delta: 135.96,
                        assignment: 'CH(4)',
                    },
                ],
                from: 135.95625,
                to: 135.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.77,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.76625,
                to: 117.77374999999999,
            },
            {
                signals: [
                    {
                        delta: 107.98,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 107.97625000000001,
                to: 107.98375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 46.93,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 46.92625,
                to: 46.933749999999996,
            },
            {
                signals: [
                    {
                        delta: 25.56,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.55625,
                to: 25.56375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.19,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.18625,
                to: 1.1937499999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.97,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 67.96625,
                to: 67.97375,
            },
            {
                signals: [
                    {
                        delta: 25.62,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.61625,
                to: 25.62375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.46,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.45625,
                to: 21.46375,
            },
            {
                signals: [
                    {
                        delta: 137.89,
                        assignment: 'C(1)',
                    },
                ],
                from: 137.88625,
                to: 137.89374999999998,
            },
            {
                signals: [
                    {
                        delta: 129.07,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.06625,
                to: 129.07375,
            },
            {
                signals: [
                    {
                        delta: 128.26,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.25625,
                to: 128.26375,
            },
            {
                signals: [
                    {
                        delta: 125.33,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.32625,
                to: 125.33375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 11.61,
                        assignment: 'CH₃',
                    },
                ],
                from: 11.60625,
                to: 11.61375,
            },
            {
                signals: [
                    {
                        delta: 46.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.24625,
                to: 46.25375,
            },
        ],
        nucleus: '13C',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.3,
                        assignment: 'CO',
                    },
                ],
                from: 175.29625000000001,
                to: 175.30375,
            },
            {
                signals: [
                    {
                        delta: 20.27,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.26625,
                to: 20.27375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 204,
                        assignment: 'CO',
                    },
                ],
                from: 203.99625,
                to: 204.00375,
            },
            {
                signals: [
                    {
                        delta: 30.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.02625,
                to: 30.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 115.76,
                        assignment: 'CN',
                    },
                ],
                from: 115.75625000000001,
                to: 115.76375,
            },
            {
                signals: [
                    {
                        delta: 0.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.02625,
                to: 0.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.57,
                        assignment: 'CH',
                    },
                ],
                from: 128.56625,
                to: 128.57375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.12,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 68.11625000000001,
                to: 68.12375,
            },
            {
                signals: [
                    {
                        delta: 30.49,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.48625,
                to: 30.49375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 124.86,
                        assignment: 'CO₂',
                    },
                ],
                from: 124.85625,
                to: 124.86375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.71,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.70625,
                to: 192.71375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.57,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.56625,
                to: 96.57374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 77.89,
                        assignment: 'CH',
                    },
                ],
                from: 77.88625,
                to: 77.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.86,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.85625,
                to: 70.86375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.31,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.30625,
                to: 27.31375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 43.4,
                        assignment: 'CH₂',
                    },
                ],
                from: 43.39625,
                to: 43.403749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 53.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 53.46625,
                to: 53.473749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.47,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.46625,
                to: 15.47375,
            },
            {
                signals: [
                    {
                        delta: 65.94,
                        assignment: 'CH₂',
                    },
                ],
                from: 65.93625,
                to: 65.94375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.62,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.61625,
                to: 58.623749999999994,
            },
            {
                signals: [
                    {
                        delta: 70.92,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.91625,
                to: 70.92375,
            },
            {
                signals: [
                    {
                        delta: 72.39,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.38625,
                to: 72.39375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 161.93,
                        assignment: 'CH',
                    },
                ],
                from: 161.92625,
                to: 161.93375,
            },
            {
                signals: [
                    {
                        delta: 35.22,
                        assignment: 'CH₃',
                    },
                ],
                from: 35.21625,
                to: 35.223749999999995,
            },
            {
                signals: [
                    {
                        delta: 30.64,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.63625,
                to: 30.64375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.17,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.16625,
                to: 67.17375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.626250000000006,
                to: 58.63375,
            },
            {
                signals: [
                    {
                        delta: 72.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.24625,
                to: 72.25375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.94,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.93625,
                to: 6.9437500000000005,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.78,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.77625,
                to: 18.78375,
            },
            {
                signals: [
                    {
                        delta: 57.81,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.806250000000006,
                to: 57.81375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.46,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.45625,
                to: 20.46375,
            },
            {
                signals: [
                    {
                        delta: 170.02,
                        assignment: 'CO',
                    },
                ],
                from: 170.01625,
                to: 170.02375,
            },
            {
                signals: [
                    {
                        delta: 60.08,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.07625,
                to: 60.083749999999995,
            },
            {
                signals: [
                    {
                        delta: 14.23,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.22625,
                to: 14.23375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 122.92,
                        assignment: 'CH₂',
                    },
                ],
                from: 122.91625,
                to: 122.92375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.29,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.28625000000001,
                to: 64.29375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 30.31,
                        assignment: 'CH₂',
                    },
                ],
                from: 30.30625,
                to: 30.31375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 131.72,
                        assignment: 'C',
                    },
                ],
                from: 131.71625,
                to: 131.72375,
            },
            {
                signals: [
                    {
                        delta: 16.84,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.83625,
                to: 16.84375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.34,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.33625,
                to: 14.34375,
            },
            {
                signals: [
                    {
                        delta: 23.12,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.11625,
                to: 23.12375,
            },
            {
                signals: [
                    {
                        delta: 32.06,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.056250000000006,
                to: 32.06375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.99,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.98625,
                to: 1.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.8,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.79625,
                to: 36.803749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.57,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.56625,
                to: 135.57375,
            },
            {
                signals: [
                    {
                        delta: 122.13,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.12625,
                to: 122.13374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.34,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.34375,
                to: -4.33625,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.9,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.89625,
                to: 49.903749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 61.14,
                        assignment: 'CH₃',
                    },
                ],
                from: 61.136250000000004,
                to: 61.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.27,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.26625,
                to: 14.27375,
            },
            {
                signals: [
                    {
                        delta: 22.79,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.78625,
                to: 22.79375,
            },
            {
                signals: [
                    {
                        delta: 34.54,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.53625,
                to: 34.543749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.65,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.64625,
                to: 16.65375,
            },
            {
                signals: [
                    {
                        delta: 16.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.62625,
                to: 16.63375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.24,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.23625,
                to: 25.24375,
            },
            {
                signals: [
                    {
                        delta: 64.12,
                        assignment: 'CH',
                    },
                ],
                from: 64.11625000000001,
                to: 64.12375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.32,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.31625,
                to: 19.32375,
            },
            {
                signals: [
                    {
                        delta: 115.89,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.88625,
                to: 115.89375,
            },
            {
                signals: [
                    {
                        delta: 133.61,
                        assignment: 'CH',
                    },
                ],
                from: 133.60625000000002,
                to: 133.61375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.25,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.24625,
                to: 150.25375,
            },
            {
                signals: [
                    {
                        delta: 123.46,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 123.45625,
                to: 123.46374999999999,
            },
            {
                signals: [
                    {
                        delta: 135.17,
                        assignment: 'CH(4)',
                    },
                ],
                from: 135.16625,
                to: 135.17374999999998,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.61,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.60625,
                to: 117.61375,
            },
            {
                signals: [
                    {
                        delta: 108.15,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.14625000000001,
                to: 108.15375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 47.12,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 47.11625,
                to: 47.123749999999994,
            },
            {
                signals: [
                    {
                        delta: 25.75,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.74625,
                to: 25.75375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.3662500000000002,
                to: 1.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.75,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 67.74625,
                to: 67.75375,
            },
            {
                signals: [
                    {
                        delta: 25.79,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.78625,
                to: 25.79375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.36625,
                to: 21.37375,
            },
            {
                signals: [
                    {
                        delta: 137.84,
                        assignment: 'C(1)',
                    },
                ],
                from: 137.83625,
                to: 137.84375,
            },
            {
                signals: [
                    {
                        delta: 129.33,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.32625000000002,
                to: 129.33375,
            },
            {
                signals: [
                    {
                        delta: 128.51,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.50625,
                to: 128.51375,
            },
            {
                signals: [
                    {
                        delta: 125.66,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.65625,
                to: 125.66375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.39,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.38625,
                to: 12.39375,
            },
            {
                signals: [
                    {
                        delta: 46.82,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.816250000000004,
                to: 46.82375,
            },
        ],
        nucleus: '13C',
        solvent: 'toluene- d₈',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.82,
                        assignment: 'CO',
                    },
                ],
                from: 175.81625,
                to: 175.82375,
            },
            {
                signals: [
                    {
                        delta: 20.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.36625,
                to: 20.37375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 204.43,
                        assignment: 'CO',
                    },
                ],
                from: 204.42625,
                to: 204.43375,
            },
            {
                signals: [
                    {
                        delta: 30.14,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.13625,
                to: 30.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 116.02,
                        assignment: 'CN',
                    },
                ],
                from: 116.01625,
                to: 116.02374999999999,
            },
            {
                signals: [
                    {
                        delta: 0.2,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.19625,
                to: 0.20375000000000001,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.62,
                        assignment: 'CH',
                    },
                ],
                from: 128.61625,
                to: 128.62375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.19,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 68.18625,
                to: 68.19375,
            },
            {
                signals: [
                    {
                        delta: 30.47,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.46625,
                to: 30.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 124.76,
                        assignment: 'CO₂',
                    },
                ],
                from: 124.75625000000001,
                to: 124.76375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.69,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.68625,
                to: 192.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.44,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.43625,
                to: 96.44375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 77.79,
                        assignment: 'CH',
                    },
                ],
                from: 77.78625000000001,
                to: 77.79375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.59,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.58625,
                to: 70.59375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.23,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.22625,
                to: 27.23375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 43.59,
                        assignment: 'CH₂',
                    },
                ],
                from: 43.58625000000001,
                to: 43.59375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 53.46,
                        assignment: 'CH₂',
                    },
                ],
                from: 53.456250000000004,
                to: 53.46375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.46,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.45625,
                to: 15.463750000000001,
            },
            {
                signals: [
                    {
                        delta: 65.94,
                        assignment: 'CH₂',
                    },
                ],
                from: 65.93625,
                to: 65.94375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.66,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.65625,
                to: 58.66374999999999,
            },
            {
                signals: [
                    {
                        delta: 70.87,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.86625000000001,
                to: 70.87375,
            },
            {
                signals: [
                    {
                        delta: 72.35,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.34625,
                to: 72.35374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.13,
                        assignment: 'CH',
                    },
                ],
                from: 162.12625,
                to: 162.13375,
            },
            {
                signals: [
                    {
                        delta: 35.25,
                        assignment: 'CH₃',
                    },
                ],
                from: 35.24625,
                to: 35.25375,
            },
            {
                signals: [
                    {
                        delta: 30.72,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.71625,
                to: 30.72375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.16,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.15625,
                to: 67.16375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.68,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.67625,
                to: 58.683749999999996,
            },
            {
                signals: [
                    {
                        delta: 72.21,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.20625,
                to: 72.21374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.96,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.95625,
                to: 6.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.72,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.71625,
                to: 18.72375,
            },
            {
                signals: [
                    {
                        delta: 57.86,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.85625,
                to: 57.863749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.56,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.55625,
                to: 20.56375,
            },
            {
                signals: [
                    {
                        delta: 170.44,
                        assignment: 'CO',
                    },
                ],
                from: 170.43625,
                to: 170.44375,
            },
            {
                signals: [
                    {
                        delta: 60.21,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.206250000000004,
                to: 60.21375,
            },
            {
                signals: [
                    {
                        delta: 14.19,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.18625,
                to: 14.19375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 122.96,
                        assignment: 'CH₂',
                    },
                ],
                from: 122.95625,
                to: 122.96374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.34,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.33625,
                to: 64.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 30.22,
                        assignment: 'CH₂',
                    },
                ],
                from: 30.21625,
                to: 30.22375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 131.79,
                        assignment: 'C',
                    },
                ],
                from: 131.78625,
                to: 131.79375,
            },
            {
                signals: [
                    {
                        delta: 16.95,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.94625,
                to: 16.95375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.32,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.31625,
                to: 14.32375,
            },
            {
                signals: [
                    {
                        delta: 23.04,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.03625,
                to: 23.04375,
            },
            {
                signals: [
                    {
                        delta: 31.96,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 31.95625,
                to: 31.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.05,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.0462499999999997,
                to: 2.05375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.88,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.876250000000006,
                to: 36.88375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.76,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.75625,
                to: 135.76375,
            },
            {
                signals: [
                    {
                        delta: 122.16,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.15625,
                to: 122.16375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.29,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.29375,
                to: -4.28625,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.97,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.96625,
                to: 49.973749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 61.16,
                        assignment: 'CH₃',
                    },
                ],
                from: 61.15625,
                to: 61.16374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.25,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.24625,
                to: 14.25375,
            },
            {
                signals: [
                    {
                        delta: 22.72,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.71625,
                to: 22.72375,
            },
            {
                signals: [
                    {
                        delta: 34.45,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.446250000000006,
                to: 34.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.66,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.65625,
                to: 16.66375,
            },
            {
                signals: [
                    {
                        delta: 16.6,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.59625,
                to: 16.60375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.18,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.17625,
                to: 25.18375,
            },
            {
                signals: [
                    {
                        delta: 64.23,
                        assignment: 'CH',
                    },
                ],
                from: 64.22625000000001,
                to: 64.23375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.38,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.37625,
                to: 19.38375,
            },
            {
                signals: [
                    {
                        delta: 115.92,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.91625,
                to: 115.92375,
            },
            {
                signals: [
                    {
                        delta: 133.69,
                        assignment: 'CH',
                    },
                ],
                from: 133.68625,
                to: 133.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.27,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.26625,
                to: 150.27375,
            },
            {
                signals: [
                    {
                        delta: 123.58,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 123.57625,
                to: 123.58375,
            },
            {
                signals: [
                    {
                        delta: 135.28,
                        assignment: 'CH(4)',
                    },
                ],
                from: 135.27625,
                to: 135.28375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.78,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.77625,
                to: 117.78375,
            },
            {
                signals: [
                    {
                        delta: 108.21,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.20625,
                to: 108.21374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 46.86,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 46.85625,
                to: 46.863749999999996,
            },
            {
                signals: [
                    {
                        delta: 25.65,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.64625,
                to: 25.65375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.38,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.37625,
                to: 1.3837499999999998,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.8,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 67.79625,
                to: 67.80375,
            },
            {
                signals: [
                    {
                        delta: 25.72,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.71625,
                to: 25.72375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.1,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.09625,
                to: 21.10375,
            },
            {
                signals: [
                    {
                        delta: 137.91,
                        assignment: 'C(1)',
                    },
                ],
                from: 137.90625,
                to: 137.91375,
            },
            {
                signals: [
                    {
                        delta: 129.33,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.32625000000002,
                to: 129.33375,
            },
            {
                signals: [
                    {
                        delta: 128.56,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.55625,
                to: 128.56375,
            },
            {
                signals: [
                    {
                        delta: 125.68,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.67625000000001,
                to: 125.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.35,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.34625,
                to: 12.35375,
            },
            {
                signals: [
                    {
                        delta: 46.77,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.76625000000001,
                to: 46.77375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.67,
                        assignment: 'CO',
                    },
                ],
                from: 175.66625,
                to: 175.67374999999998,
            },
            {
                signals: [
                    {
                        delta: 20.4,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.39625,
                to: 20.40375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 204.83,
                        assignment: 'CO',
                    },
                ],
                from: 204.82625000000002,
                to: 204.83375,
            },
            {
                signals: [
                    {
                        delta: 30.12,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.11625,
                to: 30.12375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 115.93,
                        assignment: 'CN',
                    },
                ],
                from: 115.92625000000001,
                to: 115.93375,
            },
            {
                signals: [
                    {
                        delta: 0.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.62625,
                to: 0.63375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.38,
                        assignment: 'CH',
                    },
                ],
                from: 128.37625,
                to: 128.38375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.19,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 68.18625,
                to: 68.19375,
            },
            {
                signals: [
                    {
                        delta: 31.13,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 31.12625,
                to: 31.13375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 126.08,
                        assignment: 'CO₂',
                    },
                ],
                from: 126.07625,
                to: 126.08375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.49,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.48625,
                to: 192.49375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.38,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.37625,
                to: 96.38374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 77.67,
                        assignment: 'CH',
                    },
                ],
                from: 77.66625,
                to: 77.67375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.55,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.54625,
                to: 70.55375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 26.99,
                        assignment: 'CH₂',
                    },
                ],
                from: 26.98625,
                to: 26.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 43.6,
                        assignment: 'CH₂',
                    },
                ],
                from: 43.596250000000005,
                to: 43.60375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 53.54,
                        assignment: 'CH₂',
                    },
                ],
                from: 53.53625,
                to: 53.543749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.35,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.34625,
                to: 15.35375,
            },
            {
                signals: [
                    {
                        delta: 65.79,
                        assignment: 'CH₂',
                    },
                ],
                from: 65.78625000000001,
                to: 65.79375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.42,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.416250000000005,
                to: 58.42375,
            },
            {
                signals: [
                    {
                        delta: 70.56,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.55625,
                to: 70.56375,
            },
            {
                signals: [
                    {
                        delta: 72.07,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.06625,
                to: 72.07374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.01,
                        assignment: 'CH',
                    },
                ],
                from: 162.00625,
                to: 162.01375,
            },
            {
                signals: [
                    {
                        delta: 35.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 35.446250000000006,
                to: 35.45375,
            },
            {
                signals: [
                    {
                        delta: 30.71,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.70625,
                to: 30.71375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 66.95,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.94625,
                to: 66.95375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.31,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.306250000000006,
                to: 58.31375,
            },
            {
                signals: [
                    {
                        delta: 71.81,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.80625,
                to: 71.81375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.91,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.90625,
                to: 6.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.55,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.54625,
                to: 18.55375,
            },
            {
                signals: [
                    {
                        delta: 57.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.626250000000006,
                to: 57.63375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.5,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.49625,
                to: 20.50375,
            },
            {
                signals: [
                    {
                        delta: 170.2,
                        assignment: 'CO',
                    },
                ],
                from: 170.19625,
                to: 170.20374999999999,
            },
            {
                signals: [
                    {
                        delta: 60.06,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.056250000000006,
                to: 60.06375,
            },
            {
                signals: [
                    {
                        delta: 14.07,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.06625,
                to: 14.07375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 122.95,
                        assignment: 'CH₂',
                    },
                ],
                from: 122.94625,
                to: 122.95375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.03,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.02625,
                to: 64.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 30.11,
                        assignment: 'CH₂',
                    },
                ],
                from: 30.10625,
                to: 30.11375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 131.54,
                        assignment: 'C',
                    },
                ],
                from: 131.53625,
                to: 131.54375,
            },
            {
                signals: [
                    {
                        delta: 16.68,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.67625,
                to: 16.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.18,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.17625,
                to: 14.18375,
            },
            {
                signals: [
                    {
                        delta: 22.86,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 22.85625,
                to: 22.86375,
            },
            {
                signals: [
                    {
                        delta: 31.77,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 31.76625,
                to: 31.77375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.92,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.91625,
                to: 1.9237499999999998,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.64,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.636250000000004,
                to: 36.64375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.5,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.49625,
                to: 135.50375,
            },
            {
                signals: [
                    {
                        delta: 121.96,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 121.95625,
                to: 121.96374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.33,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.33375,
                to: -4.32625,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.66,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.65625,
                to: 49.66374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 61.68,
                        assignment: 'CH₃',
                    },
                ],
                from: 61.67625,
                to: 61.683749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.1,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.09625,
                to: 14.10375,
            },
            {
                signals: [
                    {
                        delta: 22.54,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.53625,
                to: 22.54375,
            },
            {
                signals: [
                    {
                        delta: 34.26,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.25625,
                to: 34.263749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.56,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.55625,
                to: 16.56375,
            },
            {
                signals: [
                    {
                        delta: 16.48,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.47625,
                to: 16.48375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.14,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.13625,
                to: 25.14375,
            },
            {
                signals: [
                    {
                        delta: 64.18,
                        assignment: 'CH',
                    },
                ],
                from: 64.17625000000001,
                to: 64.18375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.32,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.31625,
                to: 19.32375,
            },
            {
                signals: [
                    {
                        delta: 115.86,
                        assignment: 'CH₂',
                    },
                ],
                from: 115.85625,
                to: 115.86375,
            },
            {
                signals: [
                    {
                        delta: 133.57,
                        assignment: 'CH',
                    },
                ],
                from: 133.56625,
                to: 133.57375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 149.93,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 149.92625,
                to: 149.93375,
            },
            {
                signals: [
                    {
                        delta: 123.49,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 123.48625,
                to: 123.49374999999999,
            },
            {
                signals: [
                    {
                        delta: 135.32,
                        assignment: 'CH(4)',
                    },
                ],
                from: 135.31625,
                to: 135.32375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.65,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.64625000000001,
                to: 117.65375,
            },
            {
                signals: [
                    {
                        delta: 108.03,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.02625,
                to: 108.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 46.75,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 46.74625,
                to: 46.75375,
            },
            {
                signals: [
                    {
                        delta: 25.59,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.58625,
                to: 25.59375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.09,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.0862500000000002,
                to: 1.09375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.64,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 67.63625,
                to: 67.64375,
            },
            {
                signals: [
                    {
                        delta: 25.68,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.67625,
                to: 25.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.23,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.22625,
                to: 21.23375,
            },
            {
                signals: [
                    {
                        delta: 137.65,
                        assignment: 'C(1)',
                    },
                ],
                from: 137.64625,
                to: 137.65375,
            },
            {
                signals: [
                    {
                        delta: 129.12,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.11625,
                to: 129.12375,
            },
            {
                signals: [
                    {
                        delta: 128.31,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.30625,
                to: 128.31375,
            },
            {
                signals: [
                    {
                        delta: 125.43,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.42625000000001,
                to: 125.43375,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 11.87,
                        assignment: 'CH₃',
                    },
                ],
                from: 11.866249999999999,
                to: 11.87375,
            },
            {
                signals: [
                    {
                        delta: 46.36,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.35625,
                to: 46.363749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 172.31,
                        assignment: 'CO',
                    },
                ],
                from: 172.30625,
                to: 172.31375,
            },
            {
                signals: [
                    {
                        delta: 20.51,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.50625,
                to: 20.51375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 205.87,
                        assignment: 'CO',
                    },
                ],
                from: 205.86625,
                to: 205.87375,
            },
            {
                signals: [
                    {
                        delta: 30.6,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.59625,
                to: 30.60375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.6,
                        assignment: 'CN',
                    },
                ],
                from: 117.59625,
                to: 117.60374999999999,
            },
            {
                signals: [
                    {
                        delta: 1.12,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.1162500000000002,
                to: 1.12375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 129.15,
                        assignment: 'CH',
                    },
                ],
                from: 129.14625,
                to: 129.15375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.13,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 68.12625,
                to: 68.13374999999999,
            },
            {
                signals: [
                    {
                        delta: 30.72,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.71625,
                to: 30.72375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 125.81,
                        assignment: 'CO₂',
                    },
                ],
                from: 125.80625,
                to: 125.81375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 193.58,
                        assignment: 'CS₂',
                    },
                ],
                from: 193.57625000000002,
                to: 193.58375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.65,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.64625000000001,
                to: 96.65375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 79.19,
                        assignment: 'CH',
                    },
                ],
                from: 79.18625,
                to: 79.19375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 71.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.24625,
                to: 71.25375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.51,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.50625,
                to: 27.51375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.24625,
                to: 45.25375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.95,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.946250000000006,
                to: 54.95375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.78,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.77625,
                to: 15.78375,
            },
            {
                signals: [
                    {
                        delta: 66.12,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.11625000000001,
                to: 66.12375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.77,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.76625000000001,
                to: 58.77375,
            },
            {
                signals: [
                    {
                        delta: 71.03,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.02625,
                to: 71.03375,
            },
            {
                signals: [
                    {
                        delta: 72.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.62625,
                to: 72.63374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.79,
                        assignment: 'CH',
                    },
                ],
                from: 162.78625,
                to: 162.79375,
            },
            {
                signals: [
                    {
                        delta: 36.15,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.14625,
                to: 36.153749999999995,
            },
            {
                signals: [
                    {
                        delta: 31.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 31.02625,
                to: 31.03375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.6,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.59625,
                to: 67.60374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.446250000000006,
                to: 58.45375,
            },
            {
                signals: [
                    {
                        delta: 72.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.46625,
                to: 72.47375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.88,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.87625,
                to: 6.88375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.88625,
                to: 18.89375,
            },
            {
                signals: [
                    {
                        delta: 57.72,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.71625,
                to: 57.723749999999995,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.83,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.826249999999998,
                to: 20.83375,
            },
            {
                signals: [
                    {
                        delta: 170.96,
                        assignment: 'CO',
                    },
                ],
                from: 170.95625,
                to: 170.96375,
            },
            {
                signals: [
                    {
                        delta: 60.56,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.556250000000006,
                to: 60.56375,
            },
            {
                signals: [
                    {
                        delta: 14.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.49625,
                to: 14.50375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.46625,
                to: 123.47375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.26,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.25625000000001,
                to: 64.26375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 132.22,
                        assignment: 'C',
                    },
                ],
                from: 132.21625,
                to: 132.22375,
            },
            {
                signals: [
                    {
                        delta: 16.86,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.85625,
                to: 16.86375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.34,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.33625,
                to: 14.34375,
            },
            {
                signals: [
                    {
                        delta: 23.28,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.27625,
                to: 23.28375,
            },
            {
                signals: [
                    {
                        delta: 32.3,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.29625,
                to: 32.303749999999994,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.01,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.0062499999999996,
                to: 2.01375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 37.04,
                        assignment: 'CH₃',
                    },
                ],
                from: 37.03625,
                to: 37.043749999999996,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.89,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.88625,
                to: 135.89374999999998,
            },
            {
                signals: [
                    {
                        delta: 122.31,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.30625,
                to: 122.31375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -5.33,
                        assignment: 'CH₄',
                    },
                ],
                from: -5.33375,
                to: -5.32625,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.77,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.76625000000001,
                to: 49.77375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.21,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.206250000000004,
                to: 63.21375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.29,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.286249999999999,
                to: 14.29375,
            },
            {
                signals: [
                    {
                        delta: 22.98,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 22.97625,
                to: 22.98375,
            },
            {
                signals: [
                    {
                        delta: 34.83,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.82625,
                to: 34.833749999999995,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.68,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.67625,
                to: 16.68375,
            },
            {
                signals: [
                    {
                        delta: 16.78,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.77625,
                to: 16.78375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.67,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.66625,
                to: 25.673750000000002,
            },
            {
                signals: [
                    {
                        delta: 63.85,
                        assignment: 'CH',
                    },
                ],
                from: 63.846250000000005,
                to: 63.85375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.42,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.41625,
                to: 19.423750000000002,
            },
            {
                signals: [
                    {
                        delta: 116.03,
                        assignment: 'CH₂',
                    },
                ],
                from: 116.02625,
                to: 116.03375,
            },
            {
                signals: [
                    {
                        delta: 134.34,
                        assignment: 'CH',
                    },
                ],
                from: 134.33625,
                to: 134.34375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.67,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.66625,
                to: 150.67374999999998,
            },
            {
                signals: [
                    {
                        delta: 124.57,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 124.56625,
                to: 124.57374999999999,
            },
            {
                signals: [
                    {
                        delta: 136.56,
                        assignment: 'CH(4)',
                    },
                ],
                from: 136.55625,
                to: 136.56375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.98,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.97625000000001,
                to: 117.98375,
            },
            {
                signals: [
                    {
                        delta: 108.04,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.03625000000001,
                to: 108.04375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.4,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.07,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.06625,
                to: 68.07374999999999,
            },
            {
                signals: [
                    {
                        delta: 26.15,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.14625,
                to: 26.15375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.46,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.45625,
                to: 21.46375,
            },
            {
                signals: [
                    {
                        delta: 138.48,
                        assignment: 'C(1)',
                    },
                ],
                from: 138.47625,
                to: 138.48375,
            },
            {
                signals: [
                    {
                        delta: 129.76,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.75625,
                to: 129.76375,
            },
            {
                signals: [
                    {
                        delta: 129.03,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 129.02625,
                to: 129.03375,
            },
            {
                signals: [
                    {
                        delta: 126.12,
                        assignment: 'CH(4)',
                    },
                ],
                from: 126.11625000000001,
                to: 126.12375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.49,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.48625,
                to: 12.49375,
            },
            {
                signals: [
                    {
                        delta: 47.07,
                        assignment: 'CH₂',
                    },
                ],
                from: 47.066250000000004,
                to: 47.07375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 171.93,
                        assignment: 'CO',
                    },
                ],
                from: 171.92625,
                to: 171.93375,
            },
            {
                signals: [
                    {
                        delta: 20.95,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.94625,
                to: 20.95375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 206.31,
                        assignment: 'CO',
                    },
                ],
                from: 206.30625,
                to: 206.31375,
            },
            {
                signals: [
                    {
                        delta: 30.56,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.55625,
                to: 30.56375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.91,
                        assignment: 'CN',
                    },
                ],
                from: 117.90625,
                to: 117.91375,
            },
            {
                signals: [
                    {
                        delta: 1.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.02625,
                to: 1.03375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 128.3,
                        assignment: 'CH',
                    },
                ],
                from: 128.29625000000001,
                to: 128.30375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 66.88,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 66.87625,
                to: 66.88374999999999,
            },
            {
                signals: [
                    {
                        delta: 30.38,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.37625,
                to: 30.38375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 124.21,
                        assignment: 'CO₂',
                    },
                ],
                from: 124.20625,
                to: 124.21374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 192.63,
                        assignment: 'CS₂',
                    },
                ],
                from: 192.62625,
                to: 192.63375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 95.44,
                        assignment: 'CCl₄',
                    },
                ],
                from: 95.43625,
                to: 95.44375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 79.16,
                        assignment: 'CH',
                    },
                ],
                from: 79.15625,
                to: 79.16375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 69.85,
                        assignment: 'CH₂',
                    },
                ],
                from: 69.84625,
                to: 69.85374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 26.33,
                        assignment: 'CH₂',
                    },
                ],
                from: 26.326249999999998,
                to: 26.33375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.02,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.01625000000001,
                to: 45.02375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.84,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.83625000000001,
                to: 54.84375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.12,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.116249999999999,
                to: 15.12375,
            },
            {
                signals: [
                    {
                        delta: 62.05,
                        assignment: 'CH₂',
                    },
                ],
                from: 62.04625,
                to: 62.053749999999994,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 57.98,
                        assignment: 'CH₃',
                    },
                ],
                from: 57.97625,
                to: 57.98374999999999,
            },
            {
                signals: [
                    {
                        delta: 69.54,
                        assignment: 'CH₂',
                    },
                ],
                from: 69.53625000000001,
                to: 69.54375,
            },
            {
                signals: [
                    {
                        delta: 71.25,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.24625,
                to: 71.25375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 162.29,
                        assignment: 'CH',
                    },
                ],
                from: 162.28625,
                to: 162.29375,
            },
            {
                signals: [
                    {
                        delta: 35.73,
                        assignment: 'CH₃',
                    },
                ],
                from: 35.72625,
                to: 35.73374999999999,
            },
            {
                signals: [
                    {
                        delta: 30.73,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.72625,
                to: 30.73375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 66.36,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.35625,
                to: 66.36375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.026250000000005,
                to: 58.03375,
            },
            {
                signals: [
                    {
                        delta: 71.17,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.16625,
                to: 71.17375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.61,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.60625,
                to: 6.6137500000000005,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.51,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.50625,
                to: 18.51375,
            },
            {
                signals: [
                    {
                        delta: 56.07,
                        assignment: 'CH₂',
                    },
                ],
                from: 56.066250000000004,
                to: 56.07375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.68,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.67625,
                to: 20.68375,
            },
            {
                signals: [
                    {
                        delta: 170.31,
                        assignment: 'CO',
                    },
                ],
                from: 170.30625,
                to: 170.31375,
            },
            {
                signals: [
                    {
                        delta: 59.74,
                        assignment: 'CH₂',
                    },
                ],
                from: 59.736250000000005,
                to: 59.74375,
            },
            {
                signals: [
                    {
                        delta: 14.4,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.39625,
                to: 14.40375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.52,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.51625,
                to: 123.52374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 62.76,
                        assignment: 'CH₂',
                    },
                ],
                from: 62.75625,
                to: 62.763749999999995,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 131.1,
                        assignment: 'C',
                    },
                ],
                from: 131.09625,
                to: 131.10375,
            },
            {
                signals: [
                    {
                        delta: 16.6,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.59625,
                to: 16.60375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 13.88,
                        assignment: 'CH₃',
                    },
                ],
                from: 13.87625,
                to: 13.883750000000001,
            },
            {
                signals: [
                    {
                        delta: 22.05,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 22.04625,
                to: 22.05375,
            },
            {
                signals: [
                    {
                        delta: 30.95,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 30.94625,
                to: 30.95375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.96,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.42,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.416250000000005,
                to: 36.42375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 135.15,
                        assignment: 'CH(2)',
                    },
                ],
                from: 135.14625,
                to: 135.15375,
            },
            {
                signals: [
                    {
                        delta: 121.55,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 121.54625,
                to: 121.55375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.01,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.01375,
                to: -4.00625,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 48.59,
                        assignment: 'CH₃',
                    },
                ],
                from: 48.58625000000001,
                to: 48.59375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.28,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.276250000000005,
                to: 63.28375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 13.28,
                        assignment: 'CH₃',
                    },
                ],
                from: 13.27625,
                to: 13.28375,
            },
            {
                signals: [
                    {
                        delta: 21.7,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 21.69625,
                to: 21.70375,
            },
            {
                signals: [
                    {
                        delta: 33.48,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 33.47625,
                to: 33.48374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.34,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.33625,
                to: 16.34375,
            },
            {
                signals: [
                    {
                        delta: 15.67,
                        assignment: 'CH₂',
                    },
                ],
                from: 15.66625,
                to: 15.67375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.43,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.42625,
                to: 25.43375,
            },
            {
                signals: [
                    {
                        delta: 64.92,
                        assignment: 'CH',
                    },
                ],
                from: 64.91625,
                to: 64.92375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.2,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.19625,
                to: 19.20375,
            },
            {
                signals: [
                    {
                        delta: 116.07,
                        assignment: 'CH₂',
                    },
                ],
                from: 116.06625,
                to: 116.07374999999999,
            },
            {
                signals: [
                    {
                        delta: 133.55,
                        assignment: 'CH',
                    },
                ],
                from: 133.54625000000001,
                to: 133.55375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 149.58,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 149.57625000000002,
                to: 149.58375,
            },
            {
                signals: [
                    {
                        delta: 123.84,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 123.83625,
                to: 123.84375,
            },
            {
                signals: [
                    {
                        delta: 136.05,
                        assignment: 'CH(4)',
                    },
                ],
                from: 136.04625000000001,
                to: 136.05375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 117.32,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 117.31625,
                to: 117.32374999999999,
            },
            {
                signals: [
                    {
                        delta: 107.07,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 107.06625,
                to: 107.07374999999999,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 46.51,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 46.50625,
                to: 46.513749999999995,
            },
            {
                signals: [
                    {
                        delta: 25.26,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.25625,
                to: 25.26375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.03,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 67.02625,
                to: 67.03375,
            },
            {
                signals: [
                    {
                        delta: 25.14,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.13625,
                to: 25.14375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.99,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.98625,
                to: 20.99375,
            },
            {
                signals: [
                    {
                        delta: 137.35,
                        assignment: 'C(1)',
                    },
                ],
                from: 137.34625,
                to: 137.35375,
            },
            {
                signals: [
                    {
                        delta: 128.88,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 128.87625,
                to: 128.88375,
            },
            {
                signals: [
                    {
                        delta: 128.18,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 128.17625,
                to: 128.18375,
            },
            {
                signals: [
                    {
                        delta: 125.29,
                        assignment: 'CH(4)',
                    },
                ],
                from: 125.28625000000001,
                to: 125.29375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 11.74,
                        assignment: 'CH₃',
                    },
                ],
                from: 11.73625,
                to: 11.74375,
            },
            {
                signals: [
                    {
                        delta: 45.74,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.736250000000005,
                to: 45.74375,
            },
        ],
        nucleus: '13C',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 173.21,
                        assignment: 'CO',
                    },
                ],
                from: 173.20625,
                to: 173.21375,
            },
            {
                signals: [
                    {
                        delta: 20.73,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.72625,
                to: 20.73375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 207.43,
                        assignment: 'CO',
                    },
                ],
                from: 207.42625,
                to: 207.43375,
            },
            {
                signals: [
                    {
                        delta: 30.91,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.90625,
                to: 30.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.26,
                        assignment: 'CN',
                    },
                ],
                from: 118.25625000000001,
                to: 118.26375,
            },
            {
                signals: [
                    {
                        delta: 1.79,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.7862500000000001,
                to: 1.79375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 129.32,
                        assignment: 'CH',
                    },
                ],
                from: 129.31625,
                to: 129.32375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.74,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 68.73625,
                to: 68.74374999999999,
            },
            {
                signals: [
                    {
                        delta: 30.68,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.67625,
                to: 30.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 125.89,
                        assignment: 'CO₂',
                    },
                ],
                from: 125.88625,
                to: 125.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 193.6,
                        assignment: 'CS₂',
                    },
                ],
                from: 193.59625,
                to: 193.60375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.68,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.67625000000001,
                to: 96.68375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 79.17,
                        assignment: 'CH',
                    },
                ],
                from: 79.16625,
                to: 79.17375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 71.22,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.21625,
                to: 71.22375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.62625,
                to: 27.63375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.54,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.53625,
                to: 45.543749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 55.32,
                        assignment: 'CH₂',
                    },
                ],
                from: 55.316250000000004,
                to: 55.32375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.62625,
                to: 15.633750000000001,
            },
            {
                signals: [
                    {
                        delta: 66.32,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.31625,
                to: 66.32374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.9,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.89625,
                to: 58.903749999999995,
            },
            {
                signals: [
                    {
                        delta: 70.99,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.98625,
                to: 70.99374999999999,
            },
            {
                signals: [
                    {
                        delta: 72.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.62625,
                to: 72.63374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 163.31,
                        assignment: 'CH',
                    },
                ],
                from: 163.30625,
                to: 163.31375,
            },
            {
                signals: [
                    {
                        delta: 36.57,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.566250000000004,
                to: 36.57375,
            },
            {
                signals: [
                    {
                        delta: 31.32,
                        assignment: 'CH₃',
                    },
                ],
                from: 31.31625,
                to: 31.32375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.72,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.71625,
                to: 67.72375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.886250000000004,
                to: 58.89375,
            },
            {
                signals: [
                    {
                        delta: 72.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.46625,
                to: 72.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.99,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.98625,
                to: 6.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.8,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.79625,
                to: 18.80375,
            },
            {
                signals: [
                    {
                        delta: 57.96,
                        assignment: 'CH₂',
                    },
                ],
                from: 57.956250000000004,
                to: 57.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.16,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 21.15625,
                to: 21.16375,
            },
            {
                signals: [
                    {
                        delta: 171.68,
                        assignment: 'CO',
                    },
                ],
                from: 171.67625,
                to: 171.68375,
            },
            {
                signals: [
                    {
                        delta: 60.98,
                        assignment: 'CH₂',
                    },
                ],
                from: 60.97625,
                to: 60.98374999999999,
            },
            {
                signals: [
                    {
                        delta: 14.54,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.536249999999999,
                to: 14.54375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.69,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.68625,
                to: 123.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.22,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.21625,
                to: 64.22375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 132.61,
                        assignment: 'C',
                    },
                ],
                from: 132.60625000000002,
                to: 132.61375,
            },
            {
                signals: [
                    {
                        delta: 16.94,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.93625,
                to: 16.94375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.43,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.42625,
                to: 14.43375,
            },
            {
                signals: [
                    {
                        delta: 23.4,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.39625,
                to: 23.40375,
            },
            {
                signals: [
                    {
                        delta: 32.36,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.35625,
                to: 32.363749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.07,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.0662499999999997,
                to: 2.07375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 37.1,
                        assignment: 'CH₃',
                    },
                ],
                from: 37.096250000000005,
                to: 37.10375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 136.33,
                        assignment: 'CH(2)',
                    },
                ],
                from: 136.32625000000002,
                to: 136.33375,
            },
            {
                signals: [
                    {
                        delta: 122.78,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.77625,
                to: 122.78375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.61,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.6137500000000005,
                to: -4.60625,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.9,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.89625,
                to: 49.903749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.66,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.65625,
                to: 63.66374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.37,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.366249999999999,
                to: 14.37375,
            },
            {
                signals: [
                    {
                        delta: 23.08,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 23.076249999999998,
                to: 23.08375,
            },
            {
                signals: [
                    {
                        delta: 34.89,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 34.886250000000004,
                to: 34.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.73,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.72625,
                to: 16.73375,
            },
            {
                signals: [
                    {
                        delta: 16.91,
                        assignment: 'CH₂',
                    },
                ],
                from: 16.90625,
                to: 16.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.55,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.54625,
                to: 25.55375,
            },
            {
                signals: [
                    {
                        delta: 64.3,
                        assignment: 'CH',
                    },
                ],
                from: 64.29625,
                to: 64.30375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.48,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.47625,
                to: 19.48375,
            },
            {
                signals: [
                    {
                        delta: 116.12,
                        assignment: 'CH₂',
                    },
                ],
                from: 116.11625000000001,
                to: 116.12375,
            },
            {
                signals: [
                    {
                        delta: 134.78,
                        assignment: 'CH',
                    },
                ],
                from: 134.77625,
                to: 134.78375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.76,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.75625,
                to: 150.76375,
            },
            {
                signals: [
                    {
                        delta: 127.76,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 127.75625000000001,
                to: 127.76375,
            },
            {
                signals: [
                    {
                        delta: 136.89,
                        assignment: 'CH(4)',
                    },
                ],
                from: 136.88625,
                to: 136.89374999999998,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.47,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 118.46625,
                to: 118.47375,
            },
            {
                signals: [
                    {
                        delta: 108.31,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.30625,
                to: 108.31375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 47.57,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 47.566250000000004,
                to: 47.57375,
            },
            {
                signals: [
                    {
                        delta: 26.34,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.33625,
                to: 26.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.33,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.32625,
                to: 68.33375,
            },
            {
                signals: [
                    {
                        delta: 26.27,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.26625,
                to: 26.27375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.49625,
                to: 21.50375,
            },
            {
                signals: [
                    {
                        delta: 138.9,
                        assignment: 'C(1)',
                    },
                ],
                from: 138.89625,
                to: 138.90375,
            },
            {
                signals: [
                    {
                        delta: 129.94,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.93625,
                to: 129.94375,
            },
            {
                signals: [
                    {
                        delta: 129.23,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 129.22625,
                to: 129.23375,
            },
            {
                signals: [
                    {
                        delta: 126.28,
                        assignment: 'CH(4)',
                    },
                ],
                from: 126.27625,
                to: 126.28375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 12.38,
                        assignment: 'CH₃',
                    },
                ],
                from: 12.37625,
                to: 12.383750000000001,
            },
            {
                signals: [
                    {
                        delta: 47.1,
                        assignment: 'CH₂',
                    },
                ],
                from: 47.096250000000005,
                to: 47.10375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 177.96,
                        assignment: 'CO',
                    },
                ],
                from: 177.95625,
                to: 177.96375,
            },
            {
                signals: [
                    {
                        delta: 20.91,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.90625,
                to: 20.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 32.35,
                        assignment: 'CO',
                    },
                ],
                from: 32.346250000000005,
                to: 32.35375,
            },
            {
                signals: [
                    {
                        delta: 214.98,
                        assignment: 'CH₃',
                    },
                ],
                from: 214.97625,
                to: 214.98375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.95,
                        assignment: 'CN',
                    },
                ],
                from: 118.94625,
                to: 118.95375,
            },
            {
                signals: [
                    {
                        delta: 1,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.99625,
                to: 1.00375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 129.84,
                        assignment: 'CH',
                    },
                ],
                from: 129.83625,
                to: 129.84375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 72.35,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 72.34625,
                to: 72.35374999999999,
            },
            {
                signals: [
                    {
                        delta: 31.07,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 31.06625,
                to: 31.07375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 126.92,
                        assignment: 'CO₂',
                    },
                ],
                from: 126.91625,
                to: 126.92375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 196.26,
                        assignment: 'CS₂',
                    },
                ],
                from: 196.25625,
                to: 196.26375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 97.74,
                        assignment: 'CCl₄',
                    },
                ],
                from: 97.73625,
                to: 97.74374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 78.83,
                        assignment: 'CH',
                    },
                ],
                from: 78.82625,
                to: 78.83375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.8,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.79625,
                to: 70.80375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 28.34,
                        assignment: 'CH₂',
                    },
                ],
                from: 28.33625,
                to: 28.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.28,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.276250000000005,
                to: 45.28375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.46,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.456250000000004,
                to: 54.46375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.33,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.32625,
                to: 15.33375,
            },
            {
                signals: [
                    {
                        delta: 67.55,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.54625,
                to: 67.55375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.4,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.39625,
                to: 59.403749999999995,
            },
            {
                signals: [
                    {
                        delta: 73.05,
                        assignment: 'CH₂',
                    },
                ],
                from: 73.04625,
                to: 73.05375,
            },
            {
                signals: [
                    {
                        delta: 71.33,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.32625,
                to: 71.33375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 166.01,
                        assignment: 'CH',
                    },
                ],
                from: 166.00625,
                to: 166.01375,
            },
            {
                signals: [
                    {
                        delta: 37.76,
                        assignment: 'CH₃',
                    },
                ],
                from: 37.75625,
                to: 37.763749999999995,
            },
            {
                signals: [
                    {
                        delta: 30.96,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.95625,
                to: 30.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.52,
                        assignment: 'CH₂',
                    },
                ],
                from: 68.51625,
                to: 68.52374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.52,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.51625000000001,
                to: 59.52375,
            },
            {
                signals: [
                    {
                        delta: 72.87,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.86625000000001,
                to: 72.87375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 7.01,
                        assignment: 'CH₃',
                    },
                ],
                from: 7.00625,
                to: 7.01375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.11,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.10625,
                to: 18.11375,
            },
            {
                signals: [
                    {
                        delta: 59.68,
                        assignment: 'CH₂',
                    },
                ],
                from: 59.67625,
                to: 59.683749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.18,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 21.17625,
                to: 21.18375,
            },
            {
                signals: [
                    {
                        delta: 175.55,
                        assignment: 'CO',
                    },
                ],
                from: 175.54625000000001,
                to: 175.55375,
            },
            {
                signals: [
                    {
                        delta: 62.7,
                        assignment: 'CH₂',
                    },
                ],
                from: 62.696250000000006,
                to: 62.70375,
            },
            {
                signals: [
                    {
                        delta: 14.36,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.35625,
                to: 14.36375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 124.08,
                        assignment: 'CH₂',
                    },
                ],
                from: 124.07625,
                to: 124.08375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.87,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.86625000000001,
                to: 64.87375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 134.04,
                        assignment: 'C',
                    },
                ],
                from: 134.03625,
                to: 134.04375,
            },
            {
                signals: [
                    {
                        delta: 17.04,
                        assignment: 'CH₃',
                    },
                ],
                from: 17.03625,
                to: 17.04375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.62625,
                to: 14.633750000000001,
            },
            {
                signals: [
                    {
                        delta: 24.06,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 24.05625,
                to: 24.06375,
            },
            {
                signals: [
                    {
                        delta: 33.17,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 33.166250000000005,
                to: 33.17375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.09,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.0862499999999997,
                to: 2.09375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 37.21,
                        assignment: 'CH₃',
                    },
                ],
                from: 37.206250000000004,
                to: 37.21375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 136.58,
                        assignment: 'CH(2)',
                    },
                ],
                from: 136.57625000000002,
                to: 136.58375,
            },
            {
                signals: [
                    {
                        delta: 122.93,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.92625000000001,
                to: 122.93375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -5.88,
                        assignment: 'CH₄',
                    },
                ],
                from: -5.88375,
                to: -5.87625,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 50.67,
                        assignment: 'CH₃',
                    },
                ],
                from: 50.666250000000005,
                to: 50.67375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.17,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.166250000000005,
                to: 63.17375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.54,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.536249999999999,
                to: 14.54375,
            },
            {
                signals: [
                    {
                        delta: 23.75,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 23.74625,
                to: 23.75375,
            },
            {
                signals: [
                    {
                        delta: 35.76,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 35.75625,
                to: 35.763749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.93,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.92625,
                to: 16.93375,
            },
            {
                signals: [
                    {
                        delta: 17.46,
                        assignment: 'CH₂',
                    },
                ],
                from: 17.45625,
                to: 17.46375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.21,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.20625,
                to: 25.21375,
            },
            {
                signals: [
                    {
                        delta: 66.69,
                        assignment: 'CH',
                    },
                ],
                from: 66.68625,
                to: 66.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.63,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.62625,
                to: 19.63375,
            },
            {
                signals: [
                    {
                        delta: 116.38,
                        assignment: 'CH₂',
                    },
                ],
                from: 116.37625,
                to: 116.38374999999999,
            },
            {
                signals: [
                    {
                        delta: 136,
                        assignment: 'CH',
                    },
                ],
                from: 135.99625,
                to: 136.00375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 149.76,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 149.75625,
                to: 149.76375,
            },
            {
                signals: [
                    {
                        delta: 126.27,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 126.26625,
                to: 126.27374999999999,
            },
            {
                signals: [
                    {
                        delta: 139.62,
                        assignment: 'CH(4)',
                    },
                ],
                from: 139.61625,
                to: 139.62375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 119.61,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 119.60625,
                to: 119.61375,
            },
            {
                signals: [
                    {
                        delta: 108.85,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.84625,
                to: 108.85374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 47.43,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 47.42625,
                to: 47.433749999999996,
            },
            {
                signals: [
                    {
                        delta: 25.73,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.72625,
                to: 25.73375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.87,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.86625,
                to: 2.8737500000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 69.53,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 69.52625,
                to: 69.53375,
            },
            {
                signals: [
                    {
                        delta: 26.69,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.68625,
                to: 26.69375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.62,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.61625,
                to: 21.62375,
            },
            {
                signals: [
                    {
                        delta: 139.92,
                        assignment: 'C(1)',
                    },
                ],
                from: 139.91625,
                to: 139.92374999999998,
            },
            {
                signals: [
                    {
                        delta: 130.58,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 130.57625000000002,
                to: 130.58375,
            },
            {
                signals: [
                    {
                        delta: 129.79,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 129.78625,
                to: 129.79375,
            },
            {
                signals: [
                    {
                        delta: 126.82,
                        assignment: 'CH(4)',
                    },
                ],
                from: 126.81625,
                to: 126.82374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 9.51,
                        assignment: 'CH₃',
                    },
                ],
                from: 9.50625,
                to: 9.51375,
            },
            {
                signals: [
                    {
                        delta: 48.45,
                        assignment: 'CH₂',
                    },
                ],
                from: 48.446250000000006,
                to: 48.45375,
            },
        ],
        nucleus: '13C',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 175.11,
                        assignment: 'CO',
                    },
                ],
                from: 175.10625000000002,
                to: 175.11375,
            },
            {
                signals: [
                    {
                        delta: 20.56,
                        assignment: 'CH₃',
                    },
                ],
                from: 20.55625,
                to: 20.56375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 209.67,
                        assignment: 'CO',
                    },
                ],
                from: 209.66625,
                to: 209.67374999999998,
            },
            {
                signals: [
                    {
                        delta: 30.67,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.66625,
                to: 30.673750000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.06,
                        assignment: 'CN',
                    },
                ],
                from: 118.05625,
                to: 118.06375,
            },
            {
                signals: [
                    {
                        delta: 0.85,
                        assignment: 'CH₃',
                    },
                ],
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 129.34,
                        assignment: 'CH',
                    },
                ],
                from: 129.33625,
                to: 129.34375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 69.4,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 69.39625000000001,
                to: 69.40375,
            },
            {
                signals: [
                    {
                        delta: 30.91,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.90625,
                to: 30.91375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [
            {
                signals: [
                    {
                        delta: 126.31,
                        assignment: 'CO₂',
                    },
                ],
                from: 126.30625,
                to: 126.31375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 193.82,
                        assignment: 'CS₂',
                    },
                ],
                from: 193.81625,
                to: 193.82375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 97.21,
                        assignment: 'CCl₄',
                    },
                ],
                from: 97.20625,
                to: 97.21374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 79.44,
                        assignment: 'CH',
                    },
                ],
                from: 79.43625,
                to: 79.44375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 71.47,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.46625,
                to: 71.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 27.96,
                        assignment: 'CH₂',
                    },
                ],
                from: 27.95625,
                to: 27.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 45.11,
                        assignment: 'CH₂',
                    },
                ],
                from: 45.10625,
                to: 45.113749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        delta: 54.78,
                        assignment: 'CH₂',
                    },
                ],
                from: 54.776250000000005,
                to: 54.78375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 15.46,
                        assignment: 'CH₃',
                    },
                ],
                from: 15.45625,
                to: 15.463750000000001,
            },
            {
                signals: [
                    {
                        delta: 66.88,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.87625,
                to: 66.88374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.06,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.056250000000006,
                to: 59.06375,
            },
            {
                signals: [
                    {
                        delta: 71.33,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.32625,
                to: 71.33375,
            },
            {
                signals: [
                    {
                        delta: 72.92,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.91625,
                to: 72.92375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 164.73,
                        assignment: 'CH',
                    },
                ],
                from: 164.72625,
                to: 164.73375,
            },
            {
                signals: [
                    {
                        delta: 36.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.886250000000004,
                to: 36.89375,
            },
            {
                signals: [
                    {
                        delta: 31.61,
                        assignment: 'CH₃',
                    },
                ],
                from: 31.60625,
                to: 31.61375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.11,
                        assignment: 'CH₂',
                    },
                ],
                from: 68.10625,
                to: 68.11375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 59.06,
                        assignment: 'CH₃',
                    },
                ],
                from: 59.056250000000006,
                to: 59.06375,
            },
            {
                signals: [
                    {
                        delta: 72.72,
                        assignment: 'CH₂',
                    },
                ],
                from: 72.71625,
                to: 72.72375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 6.98,
                        assignment: 'CH₃',
                    },
                ],
                from: 6.97625,
                to: 6.983750000000001,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 18.4,
                        assignment: 'CH₃',
                    },
                ],
                from: 18.39625,
                to: 18.40375,
            },
            {
                signals: [
                    {
                        delta: 58.26,
                        assignment: 'CH₂',
                    },
                ],
                from: 58.25625,
                to: 58.263749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 20.88,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 20.87625,
                to: 20.88375,
            },
            {
                signals: [
                    {
                        delta: 172.89,
                        assignment: 'CO',
                    },
                ],
                from: 172.88625,
                to: 172.89374999999998,
            },
            {
                signals: [
                    {
                        delta: 61.5,
                        assignment: 'CH₂',
                    },
                ],
                from: 61.49625,
                to: 61.50375,
            },
            {
                signals: [
                    {
                        delta: 14.49,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.48625,
                to: 14.49375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 123.46,
                        assignment: 'CH₂',
                    },
                ],
                from: 123.45625,
                to: 123.46374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 64.3,
                        assignment: 'CH₂',
                    },
                ],
                from: 64.29625,
                to: 64.30375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 132.53,
                        assignment: 'C',
                    },
                ],
                from: 132.52625,
                to: 132.53375,
            },
            {
                signals: [
                    {
                        delta: 16.9,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.89625,
                to: 16.90375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.45,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.44625,
                to: 14.45375,
            },
            {
                signals: [
                    {
                        delta: 23.68,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 23.67625,
                to: 23.68375,
            },
            {
                signals: [
                    {
                        delta: 32.73,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 32.72625,
                to: 32.73374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 1.99,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.98625,
                to: 1.99375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 37,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.99625,
                to: 37.00375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 136.31,
                        assignment: 'CH(2)',
                    },
                ],
                from: 136.30625,
                to: 136.31375,
            },
            {
                signals: [
                    {
                        delta: 122.6,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.59625,
                to: 122.60374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        delta: -4.9,
                        assignment: 'CH₄',
                    },
                ],
                from: -4.9037500000000005,
                to: -4.89625,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.86,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.85625,
                to: 49.863749999999996,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.08,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.07625,
                to: 63.083749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.39,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.38625,
                to: 14.39375,
            },
            {
                signals: [
                    {
                        delta: 23.38,
                        assignment: 'CH₂(2,4)',
                    },
                ],
                from: 23.37625,
                to: 23.38375,
            },
            {
                signals: [
                    {
                        delta: 35.3,
                        assignment: 'CH₂(3)',
                    },
                ],
                from: 35.29625,
                to: 35.303749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 16.8,
                        assignment: 'CH₃',
                    },
                ],
                from: 16.79625,
                to: 16.80375,
            },
            {
                signals: [
                    {
                        delta: 17.19,
                        assignment: 'CH₂',
                    },
                ],
                from: 17.18625,
                to: 17.19375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 25.27,
                        assignment: 'CH₃',
                    },
                ],
                from: 25.26625,
                to: 25.27375,
            },
            {
                signals: [
                    {
                        delta: 64.71,
                        assignment: 'CH',
                    },
                ],
                from: 64.70625,
                to: 64.71374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        delta: 19.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 19.49625,
                to: 19.50375,
            },
            {
                signals: [
                    {
                        delta: 116.04,
                        assignment: 'CH₂',
                    },
                ],
                from: 116.03625000000001,
                to: 116.04375,
            },
            {
                signals: [
                    {
                        delta: 134.61,
                        assignment: 'CH',
                    },
                ],
                from: 134.60625000000002,
                to: 134.61375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 150.07,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 150.06625,
                to: 150.07375,
            },
            {
                signals: [
                    {
                        delta: 125.53,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 125.52625,
                to: 125.53375,
            },
            {
                signals: [
                    {
                        delta: 138.35,
                        assignment: 'CH(4)',
                    },
                ],
                from: 138.34625,
                to: 138.35375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 118.28,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 118.27625,
                to: 118.28375,
            },
            {
                signals: [
                    {
                        delta: 108.11,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 108.10625,
                to: 108.11375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 47.23,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 47.22625,
                to: 47.23374999999999,
            },
            {
                signals: [
                    {
                        delta: 26.29,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.28625,
                to: 26.29375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.1,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.09625,
                to: 2.1037500000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.83,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.82625,
                to: 68.83375,
            },
            {
                signals: [
                    {
                        delta: 26.48,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 26.47625,
                to: 26.48375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.49625,
                to: 21.50375,
            },
            {
                signals: [
                    {
                        delta: 138.85,
                        assignment: 'C(1)',
                    },
                ],
                from: 138.84625,
                to: 138.85375,
            },
            {
                signals: [
                    {
                        delta: 129.91,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 129.90625,
                to: 129.91375,
            },
            {
                signals: [
                    {
                        delta: 129.2,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 129.19625,
                to: 129.20374999999999,
            },
            {
                signals: [
                    {
                        delta: 126.29,
                        assignment: 'CH(4)',
                    },
                ],
                from: 126.28625000000001,
                to: 126.29375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 11.09,
                        assignment: 'CH₃',
                    },
                ],
                from: 11.08625,
                to: 11.09375,
            },
            {
                signals: [
                    {
                        delta: 46.96,
                        assignment: 'CH₂',
                    },
                ],
                from: 46.956250000000004,
                to: 46.96375,
            },
        ],
        nucleus: '13C',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 177.21,
                        assignment: 'CO',
                    },
                ],
                from: 177.20625,
                to: 177.21375,
            },
            {
                signals: [
                    {
                        delta: 21.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 21.02625,
                to: 21.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 215.94,
                        assignment: 'CO',
                    },
                ],
                from: 215.93625,
                to: 215.94375,
            },
            {
                signals: [
                    {
                        delta: 30.89,
                        assignment: 'CH₃',
                    },
                ],
                from: 30.88625,
                to: 30.89375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        delta: 119.68,
                        assignment: 'CN',
                    },
                ],
                from: 119.67625000000001,
                to: 119.68375,
            },
            {
                signals: [
                    {
                        delta: 1.47,
                        assignment: 'CH₃',
                    },
                ],
                from: 1.46625,
                to: 1.47375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.36,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 70.35625,
                to: 70.36375,
            },
            {
                signals: [
                    {
                        delta: 30.29,
                        assignment: '(CH₃)₃C',
                    },
                ],
                from: 30.28625,
                to: 30.29375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['carbon dioxide'],
        smiles: 'O=C=O',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['carbon disulfide'],
        smiles: 'S=C=S',
        ranges: [
            {
                signals: [
                    {
                        delta: 197.25,
                        assignment: 'CS₂',
                    },
                ],
                from: 197.24625,
                to: 197.25375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['carbon tetrachloride'],
        smiles: 'ClC(Cl)(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        delta: 96.73,
                        assignment: 'CCl₄',
                    },
                ],
                from: 96.72625000000001,
                to: 96.73375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        delta: 70.14,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.13625,
                to: 70.14375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 14.77,
                        assignment: 'CH₃',
                    },
                ],
                from: 14.76625,
                to: 14.77375,
            },
            {
                signals: [
                    {
                        delta: 66.42,
                        assignment: 'CH₂',
                    },
                ],
                from: 66.41625,
                to: 66.42375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.67,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.666250000000005,
                to: 58.67375,
            },
            {
                signals: [
                    {
                        delta: 70.05,
                        assignment: 'CH₂',
                    },
                ],
                from: 70.04625,
                to: 70.05375,
            },
            {
                signals: [
                    {
                        delta: 71.63,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.62625,
                to: 71.63374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 165.53,
                        assignment: 'CH',
                    },
                ],
                from: 165.52625,
                to: 165.53375,
            },
            {
                signals: [
                    {
                        delta: 37.54,
                        assignment: 'CH₃',
                    },
                ],
                from: 37.53625,
                to: 37.543749999999996,
            },
            {
                signals: [
                    {
                        delta: 32.03,
                        assignment: 'CH₃',
                    },
                ],
                from: 32.026250000000005,
                to: 32.03375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 67.19,
                        assignment: 'CH₂',
                    },
                ],
                from: 67.18625,
                to: 67.19375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        delta: 58.67,
                        assignment: 'CH₃',
                    },
                ],
                from: 58.666250000000005,
                to: 58.67375,
            },
            {
                signals: [
                    {
                        delta: 71.49,
                        assignment: 'CH₂',
                    },
                ],
                from: 71.48625,
                to: 71.49374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 17.47,
                        assignment: 'CH₃',
                    },
                ],
                from: 17.46625,
                to: 17.47375,
            },
            {
                signals: [
                    {
                        delta: 58.05,
                        assignment: 'CH₂',
                    },
                ],
                from: 58.04625,
                to: 58.053749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 21.15,
                        assignment: 'CH₃CO',
                    },
                ],
                from: 21.14625,
                to: 21.15375,
            },
            {
                signals: [
                    {
                        delta: 175.26,
                        assignment: 'CO',
                    },
                ],
                from: 175.25625,
                to: 175.26375,
            },
            {
                signals: [
                    {
                        delta: 62.32,
                        assignment: 'CH₂',
                    },
                ],
                from: 62.316250000000004,
                to: 62.32375,
            },
            {
                signals: [
                    {
                        delta: 13.92,
                        assignment: 'CH₃',
                    },
                ],
                from: 13.91625,
                to: 13.92375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.17,
                        assignment: 'CH₂',
                    },
                ],
                from: 63.166250000000005,
                to: 63.17375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['H grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 2.31,
                        assignment: 'CH₃',
                    },
                ],
                from: 2.30625,
                to: 2.31375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 36.46,
                        assignment: 'CH₃',
                    },
                ],
                from: 36.456250000000004,
                to: 36.46375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        delta: 136.65,
                        assignment: 'CH(2)',
                    },
                ],
                from: 136.64625,
                to: 136.65375,
            },
            {
                signals: [
                    {
                        delta: 122.43,
                        assignment: 'CH(4,5)',
                    },
                ],
                from: 122.42625000000001,
                to: 122.43375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        delta: 49.5,
                        assignment: 'CH₃',
                    },
                ],
                from: 49.49625,
                to: 49.50375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        delta: 63.22,
                        assignment: 'CH₃',
                    },
                ],
                from: 63.21625,
                to: 63.223749999999995,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        delta: 24.38,
                        assignment: 'CH₃',
                    },
                ],
                from: 24.37625,
                to: 24.38375,
            },
            {
                signals: [
                    {
                        delta: 64.88,
                        assignment: 'CH',
                    },
                ],
                from: 64.87625,
                to: 64.88374999999999,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 149.18,
                        assignment: 'CH(2,6)',
                    },
                ],
                from: 149.17625,
                to: 149.18375,
            },
            {
                signals: [
                    {
                        delta: 125.12,
                        assignment: 'CH(3,5)',
                    },
                ],
                from: 125.11625000000001,
                to: 125.12375,
            },
            {
                signals: [
                    {
                        delta: 138.27,
                        assignment: 'CH(4)',
                    },
                ],
                from: 138.26625,
                to: 138.27375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        delta: 119.06,
                        assignment: 'CH(2,5)',
                    },
                ],
                from: 119.05625,
                to: 119.06375,
            },
            {
                signals: [
                    {
                        delta: 107.83,
                        assignment: 'CH(3,4)',
                    },
                ],
                from: 107.82625,
                to: 107.83375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 46.83,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 46.82625,
                to: 46.833749999999995,
            },
            {
                signals: [
                    {
                        delta: 25.86,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.85625,
                to: 25.86375,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        delta: 68.68,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                from: 68.67625000000001,
                to: 68.68375,
            },
            {
                signals: [
                    {
                        delta: 25.67,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                from: 25.66625,
                to: 25.673750000000002,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [],
        nucleus: '13C',
        solvent: 'D₂O',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        delta: 9.07,
                        assignment: 'CH₃',
                    },
                ],
                from: 9.06625,
                to: 9.07375,
            },
            {
                signals: [
                    {
                        delta: 47.19,
                        assignment: 'CH₂',
                    },
                ],
                from: 47.18625,
                to: 47.193749999999994,
            },
        ],
        nucleus: '13C',
        solvent: 'D₂O',
    },
];

},{}],455:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDatabase = void 0;
const cross_fetch_1 = require("cross-fetch");
const resurrectRange_1 = require("../utilities/resurrectRange");
async function getDatabase(url = 'https://docs.google.com/spreadsheets/d/1uwyq_L38PMRWCcT4If_EhPbHKyY3q_2tpjV8vr5_zh0/edit?usp=sharing', options = {}) {
    const { format = 'tsv' } = options;
    if (url.includes('google.com')) {
        url = `https://googledocs.cheminfo.org/spreadsheets/d/${extractGoogleUUID(url)}/export?format=tsv`;
    }
    let parsed;
    const response = await (0, cross_fetch_1.fetch)(url);
    switch (format) {
        case 'tsv':
            parsed = parseData(await response.text());
            break;
        case 'json':
            parsed = await response.json();
            break;
        default:
            throw new Error('unknown database format');
    }
    const results = [];
    for (let line of parsed.data) {
        const result = {
            smiles: '',
            solvent: '',
            nucleus: '',
            jcampURL: '',
            names: [],
            meta: {},
            ranges: [],
        };
        for (let i = 0; i < line.length; i++) {
            switch (parsed.kinds[i]) {
                case 'smiles':
                    result.smiles = line[i];
                    break;
                case 'solvent':
                    result.solvent = line[i];
                    break;
                case 'nucleus':
                    result.nucleus = line[i];
                    break;
                case 'jcampURL':
                    result.jcampURL = line[i];
                    break;
                case 'name':
                    if (result.names)
                        result.names.push(line[i]);
                    break;
                case 'meta':
                    if (result.meta)
                        result.meta[parsed.labels[i]] = line[i];
                    break;
                case 'signal': {
                    const range = (0, resurrectRange_1.resurrectRange)(line[i]);
                    if (range)
                        result.ranges.push(range);
                    break;
                }
                default:
                    throw new Error(`Unknown column kind: ${parsed.kinds[i]}`);
            }
        }
        results.push(result);
    }
    return results;
}
exports.getDatabase = getDatabase;
function extractGoogleUUID(url) {
    return url.replace(/.*\/(?<uuid>[^/]{20,50}).*/, '$<uuid>');
}
function parseData(text) {
    const matrix = text
        .split(/\r?\n/)
        .filter((line) => !/^\s*$/.exec(line))
        .map((line) => line.split('\t').map((cell) => cell.trim()));
    const labels = matrix[0];
    const kinds = matrix[1];
    const data = matrix.slice(2);
    return {
        labels,
        kinds,
        data,
    };
}

},{"../utilities/resurrectRange":515,"cross-fetch":4}],456:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.protonImpurities = void 0;
exports.protonImpurities = [
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.46,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 2.45625,
                to: 2.46375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.89,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.88625,
                to: 1.8937499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.05,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.0462499999999997,
                to: 2.05375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.95,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.94625,
                to: 1.9537499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.31,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.3062499999999995,
                to: 7.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.15,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.14625,
                to: 1.1537499999999998,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.16,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 3.15625,
                to: 3.1637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.89,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.8862499999999995,
                to: 7.89375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.57,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.5662499999999997,
                to: 3.57375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.44,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.43625,
                to: 1.4437499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.77,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.76625,
                to: 3.77375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.51,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.50625,
                to: 5.51375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.12,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.0987500000000001,
                to: 1.14125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.38,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.35,
                to: 3.4099999999999997,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.43,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.42625,
                to: 3.4337500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.53,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5262499999999997,
                to: 3.53375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.2762499999999997,
                to: 3.28375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.91,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.90625,
                to: 7.91375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.88,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.8762499999999998,
                to: 2.88375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.76,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.7562499999999996,
                to: 2.76375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.56,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.55625,
                to: 3.56375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.2762499999999997,
                to: 3.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.43,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.42625,
                to: 3.4337500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.1,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.07875,
                to: 1.12125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.51,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.48,
                to: 3.5399999999999996,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.3,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 3.2962499999999997,
                to: 3.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.94,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.93625,
                to: 1.9437499999999999,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.04,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.01,
                to: 4.07,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.19,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.16875,
                to: 1.21125,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.36,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.35625,
                to: 5.3637500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.48,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.47625,
                to: 3.48375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.85,
                to: 0.91,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.18,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.17625,
                to: 2.1837500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.58,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.564375,
                to: 2.595625,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.55,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.54625,
                to: 4.55375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.48,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.47625,
                to: 7.483750000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.94,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 6.93625,
                to: 6.9437500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.19,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.18625,
                to: 0.19375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.27,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.26625,
                to: 3.27375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.02,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 3.01625,
                to: 3.02375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.31,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.3062499999999995,
                to: 4.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.31,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.3062500000000001,
                to: 1.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.878,
                to: 0.922,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.33,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2715,
                to: 1.3885,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.08,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.06875,
                to: 1.09125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.82,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.7712499999999998,
                to: 3.86875,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.69,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6744999999999999,
                to: 1.7055,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.89,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.873749999999999,
                to: 4.90625,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.99,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.965,
                to: 5.015000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.79,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.78625,
                to: 5.79375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.54,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.536249999999999,
                to: 8.54375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.25,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.24625,
                to: 7.25375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.65,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.64625,
                to: 7.6537500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 9.96,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 9.95625,
                to: 9.963750000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.66,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.65625,
                to: 6.66375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.02,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.016249999999999,
                to: 6.02375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.75,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.74625,
                to: 2.75375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.59,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.5862500000000002,
                to: 1.59375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.11,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.10625,
                to: 0.11375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.62,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.61625,
                to: 3.6237500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.79,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.7862500000000001,
                to: 1.79375,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.31,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.30625,
                to: 2.31375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.1,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.0962499999999995,
                to: 7.10375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.19,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.18625,
                to: 7.1937500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.97,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.94875,
                to: 0.99125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.46,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.43,
                to: 2.4899999999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'THF-d₈',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.52,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 1.51625,
                to: 1.52375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.06,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.05625,
                to: 2.06375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.12,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.11625,
                to: 2.1237500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.97,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.96625,
                to: 1.97375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.35,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.3462499999999995,
                to: 7.35375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.24,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.23625,
                to: 1.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.32,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.31625,
                to: 7.32375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.5862499999999997,
                to: 3.59375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.44,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.43625,
                to: 1.4437499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.76,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.7562499999999996,
                to: 3.76375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.33,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.32625,
                to: 5.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.15,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.12875,
                to: 1.17125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.43,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.4000000000000004,
                to: 3.46,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.57,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5662499999999997,
                to: 3.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.5,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.49625,
                to: 3.50375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.33,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.32625,
                to: 3.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.96,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.95625,
                to: 7.96375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.91,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.90625,
                to: 2.9137500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.82,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.8162499999999997,
                to: 2.82375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.65,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.6462499999999998,
                to: 3.65375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.34,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.3362499999999997,
                to: 3.34375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.49,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.48625,
                to: 3.4937500000000004,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.19,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.16875,
                to: 1.21125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.66,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.6300000000000003,
                to: 3.69,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.33,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.3262500000000002,
                to: 1.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.99625,
                to: 2.00375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.08,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.05,
                to: 4.11,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.23,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.20875,
                to: 1.25125,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.39625,
                to: 5.4037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.66,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.65625,
                to: 3.6637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.84,
                to: 0.9,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.27,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.26625,
                to: 1.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.2,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.19625,
                to: 2.2037500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.27,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.26625,
                to: 1.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.6,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.584375,
                to: 2.615625,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.59,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.58625,
                to: 4.59375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.63,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.62625,
                to: 7.63375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.07,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.06625,
                to: 7.07375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.21,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.20625,
                to: 0.21375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.42,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.41625,
                to: 3.42375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.09,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.0862500000000002,
                to: 1.09375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.31,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.3062499999999995,
                to: 4.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.3,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.2962500000000001,
                to: 1.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.878,
                to: 0.922,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.32,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2615,
                to: 1.3785,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.17,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.15875,
                to: 1.18125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.97,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.92125,
                to: 4.01875,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.71,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6945,
                to: 1.7255,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.93,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.913749999999999,
                to: 4.94625,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.03,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.005,
                to: 5.055000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.84,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.83625,
                to: 5.84375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.59,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.58625,
                to: 8.59375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.28,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.27625,
                to: 7.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.68,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.67625,
                to: 7.68375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.69,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 8.68625,
                to: 8.69375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.79,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.78625,
                to: 6.79375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.19,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.18625,
                to: 6.1937500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.82,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.8162499999999997,
                to: 2.82375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.67,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.66625,
                to: 1.6737499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.09,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.08625,
                to: 0.09375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.69,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.68625,
                to: 3.69375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.82,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.8162500000000001,
                to: 1.82375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.34,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.3362499999999997,
                to: 2.34375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.15,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.14625,
                to: 7.1537500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.24,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.23625,
                to: 7.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.99,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.96875,
                to: 1.01125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.48,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.45,
                to: 2.51,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₂Cl₂',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.56,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 1.5562500000000001,
                to: 1.56375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.09625,
                to: 2.1037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.17,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.16625,
                to: 2.17375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.09625,
                to: 2.1037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.36,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.35625,
                to: 7.3637500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.27625,
                to: 1.28375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.26,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.25625,
                to: 7.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.67,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.66625,
                to: 3.67375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.43,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.42625,
                to: 1.4337499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.73,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.72625,
                to: 3.73375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.3,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.29625,
                to: 5.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.21,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.18875,
                to: 1.23125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.48,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.45,
                to: 3.51,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.65,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.6462499999999998,
                to: 3.65375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.57,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5662499999999997,
                to: 3.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.39,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.38625,
                to: 3.3937500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.02,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 8.01625,
                to: 8.02375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.96,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.95625,
                to: 2.96375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.88,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.8762499999999998,
                to: 2.88375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.71,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.70625,
                to: 3.71375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.4,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.3962499999999998,
                to: 3.40375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.55,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5462499999999997,
                to: 3.55375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.87,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86625,
                to: 0.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.25,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.22875,
                to: 1.27125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.72,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.6900000000000004,
                to: 3.75,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.32,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.3162500000000001,
                to: 1.32375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.05,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 2.0462499999999997,
                to: 2.05375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.12,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.09,
                to: 4.15,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.26,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.23875,
                to: 1.28125,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.39625,
                to: 5.4037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.76,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.7562499999999996,
                to: 3.76375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.84,
                to: 0.87,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.25,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.24625,
                to: 1.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.24,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.23625,
                to: 2.2437500000000004,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.85875,
                to: 0.90125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.26,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.25625,
                to: 1.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.65,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.634375,
                to: 2.665625,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.62,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.61625,
                to: 4.62375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.67,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.66625,
                to: 7.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.1,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.0962499999999995,
                to: 7.10375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.22,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.21625,
                to: 0.22375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.49,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.48625,
                to: 3.4937500000000004,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.09,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.0862500000000002,
                to: 1.09375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.33,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.32625,
                to: 4.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.85875,
                to: 0.90125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.27,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.26625,
                to: 1.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.878,
                to: 0.922,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.32,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2615,
                to: 1.3785,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.22,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.20875,
                to: 1.23125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 4.04,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.99125,
                to: 4.08875,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.73,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.7145,
                to: 1.7455,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.94,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.92375,
                to: 4.956250000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.03,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.005,
                to: 5.055000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.83,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.82625,
                to: 5.83375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.62,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.616249999999999,
                to: 8.62375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.29,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.28625,
                to: 7.29375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.68,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.67625,
                to: 7.68375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.4,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 8.39625,
                to: 8.40375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.83,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.82625,
                to: 6.83375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.26,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.25625,
                to: 6.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.87,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.86625,
                to: 2.8737500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.68,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.67625,
                to: 1.6837499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.76,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.7562499999999996,
                to: 3.76375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.85,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.8462500000000002,
                to: 1.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.36,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.3562499999999997,
                to: 2.36375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.17,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.16625,
                to: 7.17375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.25,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.24625,
                to: 7.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.03,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.00875,
                to: 1.05125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.53,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.5,
                to: 2.5599999999999996,
            },
        ],
        nucleus: '1H',
        solvent: 'CDCl₃',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.43,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 0.42625,
                to: 0.43374999999999997,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.57,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.5662500000000001,
                to: 1.57375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.57,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.5662500000000001,
                to: 1.57375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.69,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 0.6862499999999999,
                to: 0.69375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.12,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.11625,
                to: 7.12375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.03,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.02625,
                to: 1.03375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 0.58,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 0.5762499999999999,
                to: 0.58375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.1,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 6.0962499999999995,
                to: 6.10375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.36,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.3562499999999997,
                to: 3.36375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.91,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.90625,
                to: 2.9137500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.32,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 4.31625,
                to: 4.32375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.1,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.07875,
                to: 1.12125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.25,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.22,
                to: 3.28,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.43,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.42625,
                to: 3.4337500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.31,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.30625,
                to: 3.31375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.12,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.11625,
                to: 3.1237500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.57,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.56625,
                to: 7.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.37,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.36625,
                to: 2.3737500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.96,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.33,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.32625,
                to: 3.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.12,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.11625,
                to: 3.1237500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.31,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.30625,
                to: 3.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.81,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.80625,
                to: 0.8137500000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.97,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 0.94875,
                to: 0.99125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.36,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.33,
                to: 3.3899999999999997,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 0.83,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 0.8262499999999999,
                to: 0.83375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.69,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.68625,
                to: 1.6937499999999999,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.87,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 3.8400000000000003,
                to: 3.9,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.94,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 0.91875,
                to: 0.9612499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.25,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.24625,
                to: 5.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.36,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.3562499999999997,
                to: 3.36375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.89,
                to: 0.96,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.33,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.3262500000000002,
                to: 1.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.09625,
                to: 2.1037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.85875,
                to: 0.90125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.22,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.21625,
                to: 1.22375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.09625,
                to: 0.10375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.42,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.404375,
                to: 2.435625,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.5,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.49625,
                to: 4.50375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.3,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.29625,
                to: 7.30375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.86,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 6.85625,
                to: 6.8637500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.17,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.16625,
                to: 0.17375000000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.03,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.0262499999999997,
                to: 3.03375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.01,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.0062499999999996,
                to: 3.01375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.87,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84875,
                to: 0.89125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.25,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.24625,
                to: 1.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.868,
                to: 0.912,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.32,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2615,
                to: 1.3785,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 0.95,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.93875,
                to: 0.9612499999999999,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.65,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.60125,
                to: 3.69875,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.55,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.5345,
                to: 1.5655000000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.92,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.90375,
                to: 4.93625,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.98,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.955,
                to: 5.005000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.7,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.69625,
                to: 5.70375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.47,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.46625,
                to: 8.47375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.67,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 6.66625,
                to: 6.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.99,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 6.98625,
                to: 6.99375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.71,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 7.70625,
                to: 7.71375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.43,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.42625,
                to: 6.43375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.27,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.266249999999999,
                to: 6.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.54,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.53625,
                to: 2.54375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.36,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.3562500000000002,
                to: 1.36375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.26,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.25625000000000003,
                to: 0.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.54,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.53625,
                to: 3.54375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.43,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.42625,
                to: 1.4337499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.11,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.1062499999999997,
                to: 2.11375,
            },
            {
                signals: [],
                integration: 3,
                from: 6.96,
                to: 7.01,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.09,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.08625,
                to: 7.09375,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.95,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.92875,
                to: 0.97125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.39,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.3600000000000003,
                to: 2.42,
            },
        ],
        nucleus: '1H',
        solvent: 'toluene-d₈',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.4,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 0.39625000000000005,
                to: 0.40375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.52,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.51625,
                to: 1.52375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.55,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.5462500000000001,
                to: 1.55375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.58,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 0.5762499999999999,
                to: 0.58375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.15,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.14625,
                to: 7.1537500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.05,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.0462500000000001,
                to: 1.05375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 0.63,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 0.62625,
                to: 0.63375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.15,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 6.14625,
                to: 6.1537500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.39,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.38625,
                to: 3.3937500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.9,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.8962499999999998,
                to: 2.90375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.27,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 4.266249999999999,
                to: 4.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.11,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.08875,
                to: 1.13125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.26,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.23,
                to: 3.2899999999999996,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.46,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.45625,
                to: 3.46375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.34,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.3362499999999997,
                to: 3.34375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.11,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.1062499999999997,
                to: 3.11375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.63,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.62625,
                to: 7.63375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.36,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.3562499999999997,
                to: 2.36375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.86,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.8562500000000002,
                to: 1.86375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.35,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.34625,
                to: 3.3537500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.12,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.11625,
                to: 3.1237500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.33,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.32625,
                to: 3.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.8,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.79625,
                to: 0.8037500000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.96,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 0.93875,
                to: 0.98125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.34,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.31,
                to: 3.3699999999999997,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 0.5,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 0.49625,
                to: 0.50375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.65,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.64625,
                to: 1.6537499999999998,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.89,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 3.8600000000000003,
                to: 3.92,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.92,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 0.89875,
                to: 0.94125,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.25,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.24625,
                to: 5.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.41,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.40625,
                to: 3.4137500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.9,
                to: 0.98,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.32,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.3162500000000001,
                to: 1.32375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.13,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.1262499999999998,
                to: 2.13375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.24,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.23625,
                to: 1.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.12,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.11624999999999999,
                to: 0.12375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.4,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.384375,
                to: 2.415625,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.47,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.46625,
                to: 4.47375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.33,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.32625,
                to: 7.33375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.9,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 6.89625,
                to: 6.9037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.16,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.15625,
                to: 0.16375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.0662499999999997,
                to: 3.07375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.94,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.93625,
                to: 2.94375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.87,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84875,
                to: 0.89125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.23,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.22625,
                to: 1.23375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.86,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.838,
                to: 0.882,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.26,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2015,
                to: 1.3185,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 0.95,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.93875,
                to: 0.9612499999999999,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.67,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.62125,
                to: 3.71875,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.55,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.5345,
                to: 1.5655000000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.95,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.93375,
                to: 4.9662500000000005,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.01,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.984999999999999,
                to: 5.035,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.72,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.71625,
                to: 5.72375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.53,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.52625,
                to: 8.53375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.66,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 6.65625,
                to: 6.66375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.98,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 6.97625,
                to: 6.983750000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.8,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 7.79625,
                to: 7.80375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.48,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.47625,
                to: 6.483750000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.37,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.36625,
                to: 6.37375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.54,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.53625,
                to: 2.54375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.33,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.3262500000000002,
                to: 1.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.29,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.28625,
                to: 0.29374999999999996,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.57,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.5662499999999997,
                to: 3.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.4,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.11,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.1062499999999997,
                to: 2.11375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.02,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.016249999999999,
                to: 7.02375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.13,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.12625,
                to: 7.13375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.96,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.93875,
                to: 0.98125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.4,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.37,
                to: 2.4299999999999997,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₆',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.03,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 1.02625,
                to: 1.03375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.76,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.75625,
                to: 1.76375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.77,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.76625,
                to: 1.77375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.21,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.20625,
                to: 1.2137499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.2,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.19625,
                to: 7.20375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.12,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.1162500000000002,
                to: 1.12375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.3,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.2962500000000001,
                to: 1.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.74,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 6.73625,
                to: 6.74375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.41,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.40625,
                to: 3.4137500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.37,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.3662500000000002,
                to: 1.37375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.26,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.2562499999999996,
                to: 3.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.77,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 4.766249999999999,
                to: 4.77375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.1,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.07875,
                to: 1.12125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.31,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.2800000000000002,
                to: 3.34,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.49,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.48625,
                to: 3.4937500000000004,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.37,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.36625,
                to: 3.3737500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.16,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.15625,
                to: 3.1637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.73,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.72625,
                to: 7.733750000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.51,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.5062499999999996,
                to: 2.51375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.3,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.2962499999999997,
                to: 2.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.45,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.44625,
                to: 3.4537500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.17,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.16625,
                to: 3.17375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.37,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.36625,
                to: 3.3737500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.79,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.78625,
                to: 0.7937500000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.06,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.03875,
                to: 1.08125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.51,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.48,
                to: 3.5399999999999996,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.39,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.38625,
                to: 1.3937499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.78,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.77625,
                to: 1.78375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.96,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 3.93,
                to: 3.9899999999999998,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.04,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.01875,
                to: 1.06125,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.29,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.28625,
                to: 5.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.58,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.57625,
                to: 3.58375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.86,
                to: 0.92,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.3,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.2962500000000001,
                to: 1.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.09625,
                to: 2.1037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.85,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.82875,
                to: 0.87125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.19,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.18625,
                to: 1.1937499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.09625,
                to: 0.10375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.47,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.454375,
                to: 2.485625,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.49,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.48625,
                to: 4.49375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.53,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.52625,
                to: 7.53375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.01,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.00625,
                to: 7.01375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.15,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.14625,
                to: 0.15375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.25,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.24625,
                to: 3.25375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.3,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 1.2962500000000001,
                to: 1.30375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.5862499999999997,
                to: 3.59375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.84,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.81875,
                to: 0.86125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.23,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.22625,
                to: 1.23375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.84,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.818,
                to: 0.862,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.26,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2015,
                to: 1.3185,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.04,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.02875,
                to: 1.05125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.82,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.7712499999999998,
                to: 3.86875,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.58,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.5645,
                to: 1.5955000000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.91,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.89375,
                to: 4.9262500000000005,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.98,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.955,
                to: 5.005000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.72,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.71625,
                to: 5.72375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.51,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.50625,
                to: 8.51375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.9,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 6.89625,
                to: 6.9037500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.25,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.24625,
                to: 7.25375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.61,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 8.60625,
                to: 8.61375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.62,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.61625,
                to: 6.62375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.27,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.266249999999999,
                to: 6.27375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.64,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.63625,
                to: 2.6437500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.43,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.42625,
                to: 1.4337499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.14,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.13625,
                to: 0.14375000000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.5862499999999997,
                to: 3.59375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.55,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.5462500000000001,
                to: 1.55375,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.16,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.15625,
                to: 2.1637500000000003,
            },
            {
                signals: [],
                integration: 3,
                from: 7.01,
                to: 7.08,
                multiplicity: 'm',
            },
            {
                signals: [],
                integration: 2,
                from: 7.1,
                to: 7.17,
                multiplicity: 'm',
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.93,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.9087500000000001,
                to: 0.95125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.39,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.3600000000000003,
                to: 2.42,
            },
        ],
        nucleus: '1H',
        solvent: 'C₆D₅Cl',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.84,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 2.8362499999999997,
                to: 2.84375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.96,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.09,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.0862499999999997,
                to: 2.09375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.05,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.0462499999999997,
                to: 2.05375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.36,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.35625,
                to: 7.3637500000000005,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.18,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.17625,
                to: 1.1837499999999999,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.02,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 8.01625,
                to: 8.02375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.5862499999999997,
                to: 3.59375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.43,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.42625,
                to: 1.4337499999999999,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.87,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.86625,
                to: 3.8737500000000002,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.63,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.62625,
                to: 5.63375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.11,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.08875,
                to: 1.13125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.41,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.3800000000000003,
                to: 3.44,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.56,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.55625,
                to: 3.56375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.47,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.46625,
                to: 3.4737500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.2762499999999997,
                to: 3.28375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.96,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.95625,
                to: 7.96375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.94,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.93625,
                to: 2.94375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.78,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.7762499999999997,
                to: 2.78375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.5862499999999997,
                to: 3.59375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.2762499999999997,
                to: 3.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.46,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.45625,
                to: 3.46375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.83,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.8262499999999999,
                to: 0.83375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.12,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.0987500000000001,
                to: 1.14125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.57,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.54,
                to: 3.5999999999999996,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.39,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 3.38625,
                to: 3.3937500000000003,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.97,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.96625,
                to: 1.97375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.05,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.02,
                to: 4.08,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.2,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.17875,
                to: 1.22125,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.38,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.37625,
                to: 5.38375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.2762499999999997,
                to: 3.28375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.89625,
                to: 0.90375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.17,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.16625,
                to: 2.17375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.85875,
                to: 0.90125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.28,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.27625,
                to: 1.28375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.59,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.574375,
                to: 2.605625,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.54,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.53625,
                to: 4.54375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.62,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.61625,
                to: 7.62375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.04,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.03625,
                to: 7.04375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.17,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.16625,
                to: 0.17375000000000002,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.31,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.30625,
                to: 3.31375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.12,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 3.11625,
                to: 3.1237500000000002,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.43,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.42625,
                to: 4.43375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.85875,
                to: 0.90125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.27,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.26625,
                to: 1.27375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.858,
                to: 0.902,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.31,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2515,
                to: 1.3685,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.1,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.08875,
                to: 1.11125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.9,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.85125,
                to: 3.94875,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.68,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6644999999999999,
                to: 1.6955,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.9,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.88375,
                to: 4.916250000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.975,
                to: 5.025,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.81,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.8062499999999995,
                to: 5.81375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.58,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.57625,
                to: 8.58375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.35,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.3462499999999995,
                to: 7.35375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.76,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.75625,
                to: 7.76375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 10.02,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 10.01625,
                to: 10.02375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.77,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.766249999999999,
                to: 6.77375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.07,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.06625,
                to: 6.07375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.13,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.12625,
                to: 0.13375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.63,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.6262499999999998,
                to: 3.63375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.79,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.7862500000000001,
                to: 1.79375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.32,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.3162499999999997,
                to: 2.32375,
            },
            {
                signals: [],
                integration: 3,
                from: 7.1,
                to: 7.2,
                multiplicity: 'm',
            },
            {
                signals: [],
                integration: 2,
                from: 7.1,
                to: 7.2,
                multiplicity: 'm',
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.96,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.93875,
                to: 0.98125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.45,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.4200000000000004,
                to: 2.48,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂CO',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.33,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 3.32625,
                to: 3.33375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.91,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.90625,
                to: 1.9137499999999998,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.09,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.0862499999999997,
                to: 2.09375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.0662499999999997,
                to: 2.07375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.37,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.36625,
                to: 7.37375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.11,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.1062500000000002,
                to: 1.11375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 4.19,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 4.18625,
                to: 4.1937500000000005,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.32,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 8.31625,
                to: 8.32375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.51,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.5062499999999996,
                to: 3.51375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.9,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.8962499999999998,
                to: 3.90375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.76,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.75625,
                to: 5.76375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.09,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.06875,
                to: 1.11125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.38,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.35,
                to: 3.4099999999999997,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.51,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5062499999999996,
                to: 3.51375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.38,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.3762499999999998,
                to: 3.38375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.24,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.23625,
                to: 3.2437500000000004,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.95,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.94625,
                to: 7.95375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.89,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.88625,
                to: 2.8937500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.73,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.72625,
                to: 2.73375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.57,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.5662499999999997,
                to: 3.57375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.24,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.23625,
                to: 3.2437500000000004,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.43,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.42625,
                to: 3.4337500000000003,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.82,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.8162499999999999,
                to: 0.82375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.06,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.03875,
                to: 1.08125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.44,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.41,
                to: 3.4699999999999998,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 4.63,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 4.62625,
                to: 4.63375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.99,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.98625,
                to: 1.99375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.03,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4,
                to: 4.0600000000000005,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.17,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.14875,
                to: 1.19125,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.41,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.40625,
                to: 5.41375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.34,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.3362499999999997,
                to: 3.34375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.82,
                to: 0.88,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.24,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.23625,
                to: 1.24375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.14,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.13625,
                to: 2.1437500000000003,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.86,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.83875,
                to: 0.88125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.25,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.24625,
                to: 1.25375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.06,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.056249999999999994,
                to: 0.06375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.53,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.514375,
                to: 2.545625,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.61,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.60625,
                to: 4.6137500000000005,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.63,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.62625,
                to: 7.63375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.01,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.00625,
                to: 7.01375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.2,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.19625,
                to: 0.20375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.16,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.15625,
                to: 3.1637500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 4.01,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 4.00625,
                to: 4.01375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.42,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.41625,
                to: 4.42375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.86,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.83875,
                to: 0.88125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.27,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.26625,
                to: 1.27375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.87,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.848,
                to: 0.892,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.29,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2315,
                to: 1.3485,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.04,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.02875,
                to: 1.05125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.78,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.7312499999999997,
                to: 3.82875,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.68,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6644999999999999,
                to: 1.6955,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.94,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.92375,
                to: 4.956250000000001,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.03,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.005,
                to: 5.055000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.8,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.79625,
                to: 5.80375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.58,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.57625,
                to: 8.58375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.39,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.3862499999999995,
                to: 7.39375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.79,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.78625,
                to: 7.79375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 10.75,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 10.74625,
                to: 10.75375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.73,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.72625,
                to: 6.733750000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.01,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.00625,
                to: 6.01375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.67,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.66625,
                to: 2.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.55,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.5462500000000001,
                to: 1.55375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: -0.06,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: -0.06375,
                to: -0.056249999999999994,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.6,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.59625,
                to: 3.6037500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.76,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.75625,
                to: 1.76375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.3,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.2962499999999997,
                to: 2.30375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.18,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.17625,
                to: 7.18375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.25,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.24625,
                to: 7.25375,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.93,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.9087500000000001,
                to: 0.95125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.43,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.4000000000000004,
                to: 2.46,
            },
        ],
        nucleus: '1H',
        solvent: '(CD₃)₂SO',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.13,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 2.1262499999999998,
                to: 2.13375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.96,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.08,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.07625,
                to: 2.08375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.96,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.95625,
                to: 1.9637499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.37,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.36625,
                to: 7.37375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.16,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.15625,
                to: 1.1637499999999998,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.18,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 2.17625,
                to: 2.1837500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.58,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.57625,
                to: 7.58375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.51,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.5062499999999996,
                to: 3.51375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.44,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.43625,
                to: 1.4437499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.81,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.80625,
                to: 3.81375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.44,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.43625,
                to: 5.4437500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.12,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.0987500000000001,
                to: 1.14125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.42,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.39,
                to: 3.4499999999999997,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.53,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5262499999999997,
                to: 3.53375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.45,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.44625,
                to: 3.4537500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.29,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.28625,
                to: 3.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.92,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.91625,
                to: 7.92375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.89,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.88625,
                to: 2.8937500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.77,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.76625,
                to: 2.77375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.6,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.59625,
                to: 3.6037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.2762499999999997,
                to: 3.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.45,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.44625,
                to: 3.4537500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.12,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.0987500000000001,
                to: 1.14125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.54,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.5100000000000002,
                to: 3.57,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.47,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 2.46625,
                to: 2.4737500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.97,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 1.96625,
                to: 1.97375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.06,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.029999999999999,
                to: 4.09,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.2,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.17875,
                to: 1.22125,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.41,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.40625,
                to: 5.41375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.51,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5062499999999996,
                to: 3.51375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.19,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.18625,
                to: 2.19375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.28,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.27625,
                to: 1.28375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.57,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.554375,
                to: 2.585625,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.57,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.56625,
                to: 4.57375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.57,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.56625,
                to: 7.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.01,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.00625,
                to: 7.01375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.2,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.19625,
                to: 0.20375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.2762499999999997,
                to: 3.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.16,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 2.15625,
                to: 2.1637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.31,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.3062499999999995,
                to: 4.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.89,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.86875,
                to: 0.91125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.878,
                to: 0.922,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.33,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2715,
                to: 1.3885,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.09,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.07875,
                to: 1.10125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.87,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.82125,
                to: 3.91875,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.7,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6844999999999999,
                to: 1.7155,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.93,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.913749999999999,
                to: 4.94625,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.04,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.015,
                to: 5.065,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.85,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.8462499999999995,
                to: 5.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.57,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.56625,
                to: 8.57375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.33,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.32625,
                to: 7.33375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.73,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.72625,
                to: 7.733750000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 9.27,
                        assignment: 'NH',
                    },
                ],
                integration: 1,
                from: 9.26625,
                to: 9.27375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.75,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.74625,
                to: 6.75375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.1,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.0962499999999995,
                to: 6.10375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.75,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.74625,
                to: 2.75375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.61,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.6062500000000002,
                to: 1.61375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.08,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.07625,
                to: 0.08375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.64,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.63625,
                to: 3.6437500000000003,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.8,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.7962500000000001,
                to: 1.80375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.33,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.32625,
                to: 2.33375,
            },
            {
                signals: [],
                integration: 3,
                from: 7.1,
                to: 7.3,
                multiplicity: 'm',
            },
            {
                signals: [],
                integration: 2,
                from: 7.1,
                to: 7.3,
                multiplicity: 'm',
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.96,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.93875,
                to: 0.98125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.45,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.4200000000000004,
                to: 2.48,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃CN',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.66,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 3.65625,
                to: 3.6637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.06,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.05625,
                to: 2.06375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.19,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.18625,
                to: 2.19375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.95,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.94625,
                to: 1.9537499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.36,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.35625,
                to: 7.3637500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.27625,
                to: 1.28375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.2,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 1,
                from: 2.19625,
                to: 2.2037500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.33,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.32625,
                to: 7.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.64,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.63625,
                to: 3.6437500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.47,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.46625,
                to: 1.47375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.71,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.70625,
                to: 3.71375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.24,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.23625,
                to: 5.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.2,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.17875,
                to: 1.22125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.58,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5500000000000003,
                to: 3.61,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.67,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.66625,
                to: 3.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.62,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.61625,
                to: 3.6237500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.41,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.40625,
                to: 3.4137500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.86,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.85625,
                to: 7.8637500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.98,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.97625,
                to: 2.98375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.88,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.8762499999999998,
                to: 2.88375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.76,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.7562499999999996,
                to: 3.76375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.4,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.3962499999999998,
                to: 3.40375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.61,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.6062499999999997,
                to: 3.61375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.22,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.19875,
                to: 1.24125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.71,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.68,
                to: 3.7399999999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.03,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 2.0262499999999997,
                to: 2.03375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.14,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.109999999999999,
                to: 4.17,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.26,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.23875,
                to: 1.28125,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.4,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.39625,
                to: 5.4037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.72,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.71625,
                to: 3.7237500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.88,
                to: 0.94,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.33,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.3262500000000002,
                to: 1.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.24,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.23625,
                to: 2.2437500000000004,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.91,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.88875,
                to: 0.93125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.31,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.3062500000000001,
                to: 1.31375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.08,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.07625,
                to: 0.08375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.63,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.614375,
                to: 2.645625,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.53,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.52625,
                to: 4.53375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.61,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.60625,
                to: 7.6137500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.03,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.02625,
                to: 7.03375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.18,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.17625,
                to: 0.18375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.44,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.43625,
                to: 3.44375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.27625,
                to: 4.28375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.87875,
                to: 0.92125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.33,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.3262500000000002,
                to: 1.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.878,
                to: 0.922,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.33,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2715,
                to: 1.3885,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.2,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.18875,
                to: 1.21125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 4.05,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 4.00125,
                to: 4.09875,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.7,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6844999999999999,
                to: 1.7155,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.93,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.913749999999999,
                to: 4.94625,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.03,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.005,
                to: 5.055000000000001,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.87,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.86625,
                to: 5.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.45,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.44625,
                to: 8.45375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.4,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.39625,
                to: 7.4037500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.82,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.81625,
                to: 7.82375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.84,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.83625,
                to: 6.84375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.24,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.23625,
                to: 6.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.11,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.1062499999999997,
                to: 3.11375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.93,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.92625,
                to: 1.9337499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.16,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.15625,
                to: 0.16375,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.78,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.7762499999999997,
                to: 3.78375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.91,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.90625,
                to: 1.9137499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.33,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.32625,
                to: 2.33375,
            },
            {
                signals: [],
                integration: 3,
                from: 7.1,
                to: 7.3,
                multiplicity: 'm',
            },
            {
                signals: [],
                integration: 2,
                from: 7.1,
                to: 7.3,
                multiplicity: 'm',
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.31,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.28875,
                to: 1.33125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.12,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.0900000000000003,
                to: 3.15,
            },
        ],
        nucleus: '1H',
        solvent: 'TFE-d₃',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.87,
                        multiplicity: 's',
                        assignment: 'OH',
                    },
                ],
                integration: 2,
                from: 4.86625,
                to: 4.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.99,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.98625,
                to: 1.99375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.15,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.1462499999999998,
                to: 2.15375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.03,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.0262499999999997,
                to: 2.03375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.33,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 6,
                from: 7.32625,
                to: 7.33375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.4,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.39625,
                to: 1.4037499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.9,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.89625,
                to: 7.9037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.64,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.63625,
                to: 3.6437500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.45,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 12,
                from: 1.44625,
                to: 1.4537499999999999,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.78,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.7762499999999997,
                to: 3.78375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.49,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 5.48625,
                to: 5.49375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.18,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.15875,
                to: 1.20125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.49,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.4600000000000004,
                to: 3.52,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.61,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.6062499999999997,
                to: 3.61375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.58,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.57625,
                to: 3.58375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.35,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.34625,
                to: 3.3537500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.97,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.96625,
                to: 7.97375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.99,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.98625,
                to: 2.9937500000000004,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.86,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.8562499999999997,
                to: 2.86375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.66,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.65625,
                to: 3.6637500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.35,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.34625,
                to: 3.3537500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.52,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.51625,
                to: 3.52375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.84625,
                to: 0.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.19,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.16875,
                to: 1.21125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.6,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.5700000000000003,
                to: 3.63,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.01,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 2.0062499999999996,
                to: 2.01375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.09,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.06,
                to: 4.12,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.24,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.21875,
                to: 1.26125,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.39,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.3862499999999995,
                to: 5.39375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.59,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5862499999999997,
                to: 3.59375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [
            {
                signals: [],
                integration: 6,
                from: 0.86,
                to: 0.93,
                multiplicity: 'm',
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        multiplicity: 'br s',
                        assignment: 'CH₂',
                    },
                ],
                integration: 10,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.19,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.18625,
                to: 2.19375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.87875,
                to: 0.92125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.07,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.06625,
                to: 0.07375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.64,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.624375,
                to: 2.655625,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.56,
                        multiplicity: 's',
                        assignment: 'H₂',
                    },
                ],
                integration: 2,
                from: 4.5562499999999995,
                to: 4.56375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.67,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.66625,
                to: 7.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.05,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.04625,
                to: 7.05375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.2,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.19625,
                to: 0.20375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.34,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.3362499999999997,
                to: 3.34375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.34,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.33625,
                to: 4.34375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.9,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.87875,
                to: 0.92125,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.29,
                        assignment: 'CH₂',
                    },
                ],
                integration: 6,
                from: 1.2862500000000001,
                to: 1.29375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.91,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.888,
                to: 0.932,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.34,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2815,
                to: 1.3985,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.5,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.48875,
                to: 1.51125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 3.92,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.87125,
                to: 3.96875,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.7,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6844999999999999,
                to: 1.7155,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.91,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.89375,
                to: 4.9262500000000005,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.01,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 4.984999999999999,
                to: 5.035,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.82,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.81625,
                to: 5.82375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.53,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.52625,
                to: 8.53375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.44,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.43625,
                to: 7.4437500000000005,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.85,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.8462499999999995,
                to: 7.85375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.72,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.71625,
                to: 6.72375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.08,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.07625,
                to: 6.08375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.8,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 2.7962499999999997,
                to: 2.80375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.72,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.71625,
                to: 1.72375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.1,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.09625,
                to: 0.10375000000000001,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.71,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.70625,
                to: 3.71375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.87,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.8662500000000002,
                to: 1.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.32,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.3162499999999997,
                to: 2.32375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.16,
                        assignment: 'CH(2,4,6)',
                    },
                ],
                integration: 3,
                from: 7.15625,
                to: 7.16375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.16,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.15625,
                to: 7.16375,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.05,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.02875,
                to: 1.07125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.58,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.5500000000000003,
                to: 2.61,
            },
        ],
        nucleus: '1H',
        solvent: 'CD₃OD',
    },
    {
        names: ['water'],
        smiles: 'O',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['acetic acid'],
        smiles: 'CC(=O)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.08,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.07625,
                to: 2.08375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['acetone'],
        smiles: 'CC(=O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.22,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 2.21625,
                to: 2.2237500000000003,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['acetonitrile'],
        smiles: 'CC#N',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.06,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.05625,
                to: 2.06375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['benzene'],
        smiles: 'c1ccccc1',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['tert -butyl alcohol'],
        smiles: 'CC(C)(C)O',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 1.24,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 9,
                from: 1.23625,
                to: 1.24375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['chloroform'],
        smiles: 'ClC(Cl)Cl',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['18-crown-6'],
        smiles: 'C1COCCOCCOCCOCCOCCO1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.8,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 24,
                from: 3.7962499999999997,
                to: 3.80375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['cyclohexane'],
        smiles: 'C1CCCCC1',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['1,2-dichloroethane'],
        smiles: 'ClCCCl',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['dichloromethane'],
        smiles: 'ClCCl',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.17,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.14875,
                to: 1.19125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.56,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.5300000000000002,
                to: 3.59,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['diglyme'],
        smiles: 'COCCOCCOC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.67,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.66625,
                to: 3.67375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.61,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.6062499999999997,
                to: 3.61375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.37,
                        multiplicity: 's',
                        assignment: 'OCH₃',
                    },
                ],
                integration: 6,
                from: 3.36625,
                to: 3.3737500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['dimethylformamide'],
        smiles: 'C(=O)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.92,
                        multiplicity: 's',
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 7.91625,
                to: 7.92375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.01,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.0062499999999996,
                to: 3.01375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 2.85,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 2.84625,
                to: 2.8537500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['1,4-dioxane'],
        smiles: 'C1COCCOC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.75,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 8,
                from: 3.74625,
                to: 3.75375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['DME', 'diethyl ether'],
        smiles: 'CCOCC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.37,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 3.36625,
                to: 3.3737500000000002,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 3.6,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.59625,
                to: 3.6037500000000002,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['ethane'],
        smiles: 'CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.82,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.8162499999999999,
                to: 0.82375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['ethanol'],
        smiles: 'CCO',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.17,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.14875,
                to: 1.19125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 3.65,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 3.62,
                to: 3.6799999999999997,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['ethyl acetate'],
        smiles: 'CC(=O)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 2.07,
                        multiplicity: 's',
                        assignment: 'CH₃CO',
                    },
                ],
                integration: 3,
                from: 2.0662499999999997,
                to: 2.07375,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 4.14,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 2,
                from: 4.109999999999999,
                to: 4.17,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.24,
                        assignment: 'CH₂CH₃',
                    },
                ],
                integration: 3,
                from: 1.21875,
                to: 1.26125,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['ethylene'],
        smiles: 'C=C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 5.44,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 5.43625,
                to: 5.4437500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['ethylene glycol'],
        smiles: 'OCCO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.65,
                        multiplicity: 's',
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 3.6462499999999998,
                to: 3.65375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['H greaseᶠ'],
        smiles: '',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['hexamethylbenzene'],
        smiles: 'CC1=C(C(=C(C(=C1C)C)C)C)C',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['n-hexane'],
        smiles: 'CCCCCC',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['HMDSO'],
        smiles: 'C[Si](C)(C)O[Si](C)(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.28,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 0.27625000000000005,
                to: 0.28375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['HMPA'],
        smiles: 'CN(C)P(=O)(N(C)C)N(C)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 9.5,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 2.61,
                        assignment: 'CH₃',
                    },
                ],
                integration: 18,
                from: 2.594375,
                to: 2.625625,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['hydrogen'],
        smiles: '',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['imidazole'],
        smiles: 'C1=CN=CN1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 7.78,
                        multiplicity: 's',
                        assignment: 'CH(2)',
                    },
                ],
                integration: 1,
                from: 7.77625,
                to: 7.78375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.14,
                        multiplicity: 's',
                        assignment: 'CH(4,5)',
                    },
                ],
                integration: 2,
                from: 7.1362499999999995,
                to: 7.14375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['methane'],
        smiles: 'C',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 0.18,
                        multiplicity: 's',
                        assignment: 'CH₄',
                    },
                ],
                integration: 4,
                from: 0.17625,
                to: 0.18375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['methanol'],
        smiles: 'CO',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.34,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 3.3362499999999997,
                to: 3.34375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['nitromethane'],
        smiles: 'C[N+](=O)[O-]',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 4.4,
                        multiplicity: 's',
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 4.39625,
                to: 4.4037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['n-pentane'],
        smiles: 'CCCCC',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['propane'],
        smiles: 'CCC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.88,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.858,
                to: 0.902,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7.3,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 1.3,
                        assignment: 'CH₂',
                    },
                ],
                integration: 2,
                from: 1.2415,
                to: 1.3585,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['2-propanol'],
        smiles: 'CC(O)C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 1.17,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 1.15875,
                to: 1.18125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6,
                                multiplicity: 'sept',
                            },
                        ],
                        delta: 4.02,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 3.9712499999999995,
                to: 4.06875,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['propylene'],
        smiles: 'CC=C',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 6.4,
                                multiplicity: 'd',
                            },
                            {
                                coupling: 1.5,
                                multiplicity: 't',
                            },
                        ],
                        delta: 1.7,
                        assignment: 'CH₃',
                    },
                ],
                integration: 3,
                from: 1.6844999999999999,
                to: 1.7155,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 10,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 4.95,
                        assignment: 'CH₂(1)',
                    },
                ],
                integration: 1,
                from: 4.93375,
                to: 4.9662500000000005,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 17,
                                multiplicity: 'd',
                            },
                        ],
                        delta: 5.06,
                        assignment: 'CH₂(2)',
                    },
                ],
                integration: 1,
                from: 5.034999999999999,
                to: 5.085,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 5.9,
                        assignment: 'CH',
                    },
                ],
                integration: 1,
                from: 5.89625,
                to: 5.9037500000000005,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['pyridine'],
        smiles: 'C1=CC=NC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 8.52,
                        assignment: 'CH(2,6)',
                    },
                ],
                integration: 2,
                from: 8.51625,
                to: 8.52375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.45,
                        assignment: 'CH(3,5)',
                    },
                ],
                integration: 2,
                from: 7.44625,
                to: 7.45375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 7.87,
                        assignment: 'CH(4)',
                    },
                ],
                integration: 1,
                from: 7.86625,
                to: 7.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['pyrrole'],
        smiles: 'C1=CNC=C1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 6.93,
                        assignment: 'CH(2,5)',
                    },
                ],
                integration: 2,
                from: 6.92625,
                to: 6.93375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 6.26,
                        assignment: 'CH(3,4)',
                    },
                ],
                integration: 2,
                from: 6.25625,
                to: 6.26375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['pyrrolidine'],
        smiles: 'C1CCNC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.07,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.0662499999999997,
                to: 3.07375,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.87,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.8662500000000002,
                to: 1.87375,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['silicone grease'],
        smiles: '',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['tetrahydrofuran'],
        smiles: 'C1COCC1',
        ranges: [
            {
                signals: [
                    {
                        js: [],
                        delta: 3.74,
                        assignment: 'CH₂(2,5)',
                    },
                ],
                integration: 4,
                from: 3.73625,
                to: 3.7437500000000004,
            },
            {
                signals: [
                    {
                        js: [],
                        delta: 1.88,
                        assignment: 'CH₂(3,4)',
                    },
                ],
                integration: 4,
                from: 1.87625,
                to: 1.8837499999999998,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['toluene'],
        smiles: 'Cc1ccccc1',
        ranges: [],
        nucleus: '1H',
        solvent: 'D₂O',
    },
    {
        names: ['triethylamine'],
        smiles: 'CCN(CC)CC',
        ranges: [
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 't',
                            },
                        ],
                        delta: 0.99,
                        assignment: 'CH₃',
                    },
                ],
                integration: 6,
                from: 0.96875,
                to: 1.01125,
            },
            {
                signals: [
                    {
                        js: [
                            {
                                coupling: 7,
                                multiplicity: 'q',
                            },
                        ],
                        delta: 2.57,
                        assignment: 'CH₂',
                    },
                ],
                integration: 4,
                from: 2.54,
                to: 2.5999999999999996,
            },
        ],
        nucleus: '1H',
        solvent: 'D₂O',
    },
];

},{}],457:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("gyromagnetic-ratio"), exports);
__exportStar(require("./constants/impurities"), exports);
__exportStar(require("./constants/couplingPatterns"), exports);
__exportStar(require("./peaks/peaksFilterImpurities"), exports);
__exportStar(require("./peaks/peaksToXY"), exports);
__exportStar(require("./peaks/peakToXY"), exports);
__exportStar(require("./prediction/predictProton"), exports);
__exportStar(require("./prediction/predictCarbon"), exports);
__exportStar(require("./prediction/predictCOSY"), exports);
__exportStar(require("./prediction/predictHSQC"), exports);
__exportStar(require("./prediction/predictHMBC"), exports);
__exportStar(require("./prediction/predictAll"), exports);
__exportStar(require("./prediction/predictAllSpectra"), exports);
__exportStar(require("./assignment/get1HAssignments"), exports);
__exportStar(require("./assignment/get13CAssignments"), exports);
__exportStar(require("./assignment/getAssignments"), exports);
__exportStar(require("./ranges/rangesToACS"), exports);
__exportStar(require("./ranges/rangesToXY"), exports);
__exportStar(require("./signals/signalsToRanges"), exports);
__exportStar(require("./signals/signalsToXY"), exports);
__exportStar(require("./signals/signals2DToZ"), exports);
__exportStar(require("./signals/optimizeSignals"), exports);
__exportStar(require("./signals/signalsToFID"), exports);
__exportStar(require("./utilities/resurrect"), exports);
__exportStar(require("./utilities/rangeFromSignal"), exports);
__exportStar(require("./utilities/getFrequency"), exports);
__exportStar(require("./xy/xyAutoPeaksPicking"), exports);
__exportStar(require("./xy/xyAutoRangesPicking"), exports);
__exportStar(require("./xy/xyPeaksOptimization"), exports);
__exportStar(require("./xyz/xyzAutoZonesPicking"), exports);
__exportStar(require("./xyz/xyzJResAnalyzer"), exports);
__exportStar(require("./databases/getDatabase"), exports);
__exportStar(require("./databases/carbonImpurities"), exports);
__exportStar(require("./databases/protonImpurities"), exports);
__exportStar(require("./peaks/solventSuppression"), exports);
__exportStar(require("./ranges/markSolventSignal"), exports);
__exportStar(require("./apodization/apodization"), exports);

},{"./apodization/apodization":425,"./assignment/get13CAssignments":432,"./assignment/get1HAssignments":433,"./assignment/getAssignments":434,"./constants/couplingPatterns":451,"./constants/impurities":453,"./databases/carbonImpurities":454,"./databases/getDatabase":455,"./databases/protonImpurities":456,"./peaks/peakToXY":458,"./peaks/peaksFilterImpurities":459,"./peaks/peaksToXY":461,"./peaks/solventSuppression":462,"./prediction/predictAll":471,"./prediction/predictAllSpectra":472,"./prediction/predictCOSY":473,"./prediction/predictCarbon":474,"./prediction/predictHMBC":475,"./prediction/predictHSQC":476,"./prediction/predictProton":477,"./ranges/markSolventSignal":484,"./ranges/rangesToACS":485,"./ranges/rangesToXY":486,"./signals/optimizeSignals":497,"./signals/signals2DToZ":498,"./signals/signalsToFID":500,"./signals/signalsToRanges":501,"./signals/signalsToXY":502,"./utilities/getFrequency":510,"./utilities/rangeFromSignal":513,"./utilities/resurrect":514,"./xy/xyAutoPeaksPicking":518,"./xy/xyAutoRangesPicking":519,"./xy/xyPeaksOptimization":520,"./xyz/xyzAutoZonesPicking":522,"./xyz/xyzJResAnalyzer":523,"gyromagnetic-ratio":10}],458:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.peakToXY = void 0;
const ml_gsd_1 = require("ml-gsd");
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const peaksToXY_1 = require("./peaksToXY");
function peakToXY(peak, options) {
    const newPeak = (0, ml_gsd_1.addMissingShape)([peak])[0];
    const factor = (0, ml_peak_shape_generator_1.getShape1D)(newPeak.shape).getFactor();
    const { from = newPeak.x - (peak.width * factor) / options.frequency, to = newPeak.x + (peak.width * factor) / options.frequency, } = options;
    return (0, peaksToXY_1.peaksToXY)([peak], { ...options, from, to });
}
exports.peakToXY = peakToXY;

},{"./peaksToXY":461,"ml-gsd":167,"ml-peak-shape-generator":187}],459:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.peaksFilterImpurities = void 0;
const impurities_1 = require("../constants/impurities");
const toCheck = ['solvent', 'h2o', 'tms'];
/**
 * Try to remove peaks of impurities.
 */
function peaksFilterImpurities(peakList, options = {}) {
    let { solvent, error = 0.025, remove = false } = options;
    if (solvent) {
        if (solvent === '(cd3)2so')
            solvent = 'dmso';
        if (solvent === 'meod')
            solvent = 'cd3od';
        let solventImpurities = impurities_1.impurities[solvent];
        for (let impurity of toCheck) {
            let impurityShifts = solventImpurities[impurity];
            checkImpurity(peakList, impurityShifts, {
                error,
                remove,
                name: impurity,
            });
        }
    }
    return peakList;
}
exports.peaksFilterImpurities = peaksFilterImpurities;
function checkImpurity(peakList, impurity, options) {
    let { name, error, remove } = options;
    let j, tolerance, difference;
    let i = impurity.length;
    while (i--) {
        j = peakList.length;
        while (j--) {
            tolerance = error + peakList[j].width;
            difference = Math.abs(impurity[i].shift - peakList[j].x);
            if (difference < tolerance) {
                // && (impurity[i].multiplicity === '' || (impurity[i].multiplicity.indexOf(peakList[j].multiplicity)) { // some impurities has multiplicities like 'bs' but at presents it is unsupported
                if (remove) {
                    peakList.splice(j, 1);
                }
                else {
                    peakList[j].kind = name;
                }
            }
        }
    }
}

},{"../constants/impurities":453}],460:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectSignals = exports.peaksToRanges = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const joinRanges_1 = require("../ranges/utils/joinRanges");
const jAnalyzer_1 = __importDefault(require("../signals/utils/jAnalyzer"));
function checkSignalAfterCompilePattern(signal) {
    // if (!signal.symRank)
    //   throw new Error('Internal error, symRank was not calculated');
    if (!signal.mask)
        throw new Error('Internal Error, mask was not added');
    if (!signal.mask2)
        throw new Error('Internal Error, mask2 was not added');
    if (!signal.maskPattern) {
        throw new Error('Internal Error, maskPattern was not added');
    }
}
const assignSignal = (peak, frequency, nucleus) => {
    return {
        id: (0, uuid_1.v4)(),
        delta: NaN,
        nbPeaks: 1,
        kind: 'signal',
        startX: peak.x - peak.width / frequency,
        stopX: peak.x + peak.width / frequency,
        observe: frequency,
        nucleus,
        integralData: {
            from: peak.x - (peak.width * 3) / frequency,
            to: peak.x + (peak.width * 3) / frequency,
            value: 0,
        },
        peaks: [
            {
                x: peak.x,
                intensity: peak.y,
                width: peak.width,
            },
        ],
    };
};
/**
 * This function clustering peaks and calculate the integration value for each range from the peak list returned from extractPeaks function.
 */
function peaksToRanges(data, peakList, options = {}) {
    let { integrationSum = 100, joinOverlapRanges = true, clean = 0.4, compile = true, integralType = 'sum', frequency = 400, frequencyCluster = 16, keepPeaks = false, nucleus = '1H', } = options;
    let signalOptions = {
        integrationSum,
        integralType,
        frequencyCluster,
        frequency,
        nucleus,
    };
    if (peakList.length === 0)
        return [];
    if (data.x[0] > data.x[1]) {
        data.x = data.x.reverse();
        data.y = data.y.reverse();
    }
    let signals = detectSignals(data, peakList, signalOptions);
    if (clean) {
        for (let i = 0; i < signals.length; i++) {
            if (Math.abs(signals[i].integralData.value) < clean) {
                signals.splice(i, 1);
            }
        }
    }
    if (compile) {
        let nHi, sum;
        for (let i = 0; i < signals.length; i++) {
            signals[i] = jAnalyzer_1.default.compilePattern(signals[i]);
            let signal = signals[i];
            if (signal.maskPattern &&
                signal.multiplicity !== 'm' &&
                signal.multiplicity !== '') {
                checkSignalAfterCompilePattern(signal);
                // Create a new signal with the removed peaks
                nHi = 0;
                sum = 0;
                let peaksO = [];
                for (let j = signal.maskPattern.length - 1; j >= 0; j--) {
                    sum += computeArea(signal.peaks[j], frequency);
                    if (!signal.maskPattern[j]) {
                        let peakR = signal.peaks.splice(j, 1)[0];
                        peaksO.push({
                            x: peakR.x,
                            y: peakR.intensity,
                            width: peakR.width,
                        });
                        signal.mask.splice(j, 1);
                        signal.mask2.splice(j, 1);
                        signal.maskPattern.splice(j, 1);
                        signal.nbPeaks--;
                        nHi += computeArea(peakR, frequency);
                    }
                }
                if (peaksO.length > 0) {
                    nHi = (nHi * signal.integralData.value) / sum;
                    signal.integralData.value -= nHi;
                    let peaks1 = [];
                    for (let j = peaksO.length - 1; j >= 0; j--) {
                        peaks1.push(peaksO[j]);
                    }
                    signalOptions.integrationSum = Math.abs(nHi);
                    let ranges = detectSignals(data, peaks1, signalOptions);
                    for (const range of ranges) {
                        signals.push(range);
                    }
                }
            }
        }
        // it was a updateIntegrals function.
        updateIntegration(signals, integrationSum);
    }
    signals.sort((a, b) => {
        return b.delta - a.delta;
    });
    if (clean) {
        for (let i = signals.length - 1; i >= 0; i--) {
            if (Math.abs(signals[i].integralData.value) < clean) {
                signals.splice(i, 1);
            }
        }
    }
    let ranges = [];
    for (let i = 0; i < signals.length; i++) {
        let signal = signals[i];
        const range = {
            id: (0, uuid_1.v4)(),
            from: signal.integralData.from,
            to: signal.integralData.to,
            integration: signal.integralData.value,
        };
        const signalResult = {
            delta: signal.delta,
            kind: signal.kind || 'signal',
            multiplicity: signal.multiplicity,
        };
        if (keepPeaks) {
            signalResult.peaks = signal.peaks.map((peak) => {
                const newResult = {
                    y: peak.intensity,
                    ...peak,
                };
                delete newResult.intensity;
                return newResult;
            });
        }
        if (signal.nmrJs) {
            signalResult.js = signal.nmrJs;
        }
        range.signals = [signalResult];
        ranges[i] = range;
    }
    if (joinOverlapRanges)
        ranges = (0, joinRanges_1.joinRanges)(ranges);
    return ranges;
}
exports.peaksToRanges = peaksToRanges;
/**
 * Extract the signals from the peakList and the given spectrum.
 * @param {object} data - spectra data
 * @param {array} peakList - nmr signals
 * @param {object} [options = {}]
 * @param {number} [options.integrationSum='100'] - Number of hydrogens or some number to normalize the integration data, If it's zero return the absolute integration value
 * @param {string} [options.integralType='sum'] - option to chose between approx area with peaks or the sum of the points of given range
 * @param {number} [options.frequencyCluster=16] - distance limit to clustering the peaks.
 * range = frequencyCluster / observeFrequency -> Peaks withing this range are considered to belongs to the same signal1D
 * @param {string} [options.nucleus='1H'] - - Nucleus
 * @param {String} [options.frequency = 400] - Observed frequency
 * @return {array} nmr signals
 * @private
 */
function detectSignals(data, peakList, options = {}) {
    let { integrationSum = 100, integralType = 'sum', frequencyCluster = 16, frequency = 400, nucleus = '1H', } = options;
    let signal1D = assignSignal(peakList[0], frequency, nucleus);
    let peaks;
    let signals = [];
    let prevPeak = { x: Number.MIN_SAFE_INTEGER };
    frequencyCluster /= frequency;
    for (const peak of peakList) {
        if (Math.abs(peak.x - prevPeak.x) > frequencyCluster) {
            signal1D = assignSignal(peak, frequency, nucleus);
            if (peak.kind)
                signal1D.kind = peak.kind;
            signals.push(signal1D);
        }
        else {
            let tmp = peak.x + peak.width / frequency;
            signal1D.stopX = Math.max(signal1D.stopX, tmp);
            signal1D.startX = Math.min(signal1D.startX, tmp);
            signal1D.nbPeaks++;
            signal1D.peaks.push({
                x: peak.x,
                intensity: peak.y,
                width: peak.width,
            });
            signal1D.integralData.from = Math.min(signal1D.integralData.from, peak.x - (peak.width * 3) / frequency);
            signal1D.integralData.to = Math.max(signal1D.integralData.to, peak.x + (peak.width * 3) / frequency);
            if (peak.kind)
                signal1D.kind = peak.kind;
        }
        prevPeak = peak;
    }
    for (let signal of signals) {
        peaks = signal.peaks;
        let integration = signal.integralData;
        let chemicalShift = 0;
        let integralPeaks = 0;
        for (const peak of peaks) {
            let area = computeArea(peak, frequency);
            chemicalShift += peak.x * area;
            integralPeaks += area;
        }
        signal.delta = chemicalShift / integralPeaks;
        if (integralType === 'sum') {
            integration.value = (0, ml_spectra_processing_1.xyIntegration)(data, {
                from: integration.from,
                to: integration.to,
            });
        }
        else {
            integration.value = integralPeaks;
        }
    }
    if (integrationSum > 0) {
        updateIntegration(signals, integrationSum);
    }
    return signals;
}
exports.detectSignals = detectSignals;
/**
 * Return the area of a Lorentzian function
 * @private
 */
function computeArea(peak, frequency) {
    return Math.abs(((peak.intensity * peak.width) / frequency) * 1.57); // todo add an option with this value: 1.772453851
}
/**
 * update the integration Values
 * @param signals
 * @param integrationSum
 */
function updateIntegration(signals, integrationSum) {
    let sumIntegral = 0;
    let sumObserved = 0;
    for (const signal of signals) {
        sumObserved += Math.abs(Math.round(signal.integralData.value));
    }
    if (sumObserved !== integrationSum) {
        sumIntegral = integrationSum / sumObserved;
        for (const signal of signals) {
            signal.integralData.value *= sumIntegral;
        }
    }
}

},{"../ranges/utils/joinRanges":487,"../signals/utils/jAnalyzer":508,"@lukeed/uuid":1,"ml-spectra-processing":208}],461:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.peaksToXY = void 0;
const spectrum_generator_1 = require("spectrum-generator");
const convertWidthToPPM_1 = require("./util/convertWidthToPPM");
function peaksToXY(peaks, options) {
    const { frequency, nbPoints = 1024, shape } = options;
    if (!frequency) {
        throw new Error('frequency is mandatory');
    }
    const newPeaks = (0, convertWidthToPPM_1.convertWidthToPPM)(peaks, { frequency });
    return (0, spectrum_generator_1.generateSpectrum)(newPeaks, {
        generator: {
            ...getFromTo(newPeaks, options),
            nbPoints,
            shape,
        },
    });
}
exports.peaksToXY = peaksToXY;
function getFromTo(newPeaks, options) {
    if ('to' in options && 'from' in options) {
        return {
            from: options.from,
            to: options.to,
        };
    }
    newPeaks.sort((a, b) => a.x - b.x);
    const firstPeak = newPeaks[0];
    const lastPeak = newPeaks[newPeaks.length - 1];
    const { from = firstPeak.x - (firstPeak.width * 2) / options.frequency, to = lastPeak.x + (lastPeak.width * 2) / options.frequency, } = options;
    return {
        from,
        to,
    };
}

},{"./util/convertWidthToPPM":466,"spectrum-generator":530}],462:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.solventSuppression = void 0;
const linear_sum_assignment_1 = require("linear-sum-assignment");
const ml_matrix_1 = require("ml-matrix");
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const addDummySignals_1 = require("../signals/addDummySignals");
const signalsToSpinSystem_1 = require("../signals/simulation/signalsToSpinSystem");
const simulateXYPeaks_1 = require("../signals/simulation/simulateXYPeaks");
const splitSpinSystem_1 = require("../signals/simulation/splitSpinSystem");
const clone_1 = require("../utilities/clone");
function solventSuppression(peakList, solvent, options = {}) {
    const peaks = (0, clone_1.cloneArray)(peakList).sort((a, b) => a.x - b.x);
    const xValues = peaks.map((peak) => peak.x);
    const { markSolventPeaks = false, solventZoneExtension = 1.2 } = options;
    for (const solventSignal of solvent) {
        let solventXYPeaks = solventSignal.peaks
            ? solventSignal.peaks
            : getSolventPeaks(solventSignal);
        solventXYPeaks.sort((a, b) => a.x - b.x);
        let upIndex = (0, ml_spectra_processing_1.xFindClosestIndex)(xValues, solventXYPeaks[solventXYPeaks.length - 1].x + solventZoneExtension);
        let lowIndex = (0, ml_spectra_processing_1.xFindClosestIndex)(xValues, solventXYPeaks[0].x - solventZoneExtension);
        const nearPeaks = peaks.filter((peak, index) => index >= lowIndex && index <= upIndex);
        const amplitudeResiduals = [];
        const deltaResiduals = [];
        const positionResiduals = [];
        for (let peak of nearPeaks) {
            const { peaks: shiftedSolventPeaks, delta: currentDelta } = getShiftedSolventPeaks(peak, solventSignal, solventXYPeaks);
            const closestPeaks = getClosestPeaks(shiftedSolventPeaks, nearPeaks);
            let deltaResidual = 0;
            let amplitudeResidual = 0;
            let positionResidual = 0;
            for (let i = 0; i < closestPeaks.length; i++) {
                amplitudeResidual += Math.abs(shiftedSolventPeaks[i].y - closestPeaks[i].y);
                deltaResidual += Math.abs(shiftedSolventPeaks[i].x - closestPeaks[i].x);
            }
            if (closestPeaks.length === 0) {
                deltaResidual = Number.MAX_SAFE_INTEGER;
                amplitudeResidual = Number.MAX_SAFE_INTEGER;
                positionResidual = Number.MAX_SAFE_INTEGER;
            }
            else {
                positionResidual = (0, ml_peak_shape_generator_1.gaussianFct)(Math.abs(solventSignal.delta - currentDelta), 0.5);
            }
            amplitudeResiduals.push(amplitudeResidual);
            deltaResiduals.push(deltaResidual);
            positionResiduals.push(positionResidual);
        }
        const [maxAmplitude, maxDelta, maxPosition] = [
            amplitudeResiduals,
            deltaResiduals,
            positionResiduals,
        ].map((data) => {
            const max = (0, ml_spectra_processing_1.xMaxValue)(data);
            return max === 0 ? 1 : max;
        });
        let minIndex = -1;
        let minScore = Number.MAX_SAFE_INTEGER;
        let score = [];
        for (let i = 0; i < deltaResiduals.length; i++) {
            const value = (amplitudeResiduals[i] / maxAmplitude +
                deltaResiduals[i] / maxDelta +
                1 -
                positionResiduals[i] / maxPosition) /
                3;
            score.push(value);
            if (minScore > value) {
                minIndex = i;
                minScore = value;
            }
        }
        if (minScore < 0 || minIndex < 0) {
            new Error('There is not a correct match with the pattern');
            return peaks;
        }
        const { peaks: shiftedSolventPeaks } = getShiftedSolventPeaks(nearPeaks[minIndex], solventSignal, solventXYPeaks);
        const diff = getDiffMatrix(shiftedSolventPeaks, nearPeaks);
        const { rowAssignments, gain } = (0, linear_sum_assignment_1.linearSumAssignment)(diff, {
            maximaze: false,
        });
        if (gain < 0) {
            new Error('The gain is below to zero');
            return peaks;
        }
        if (markSolventPeaks) {
            for (let index of rowAssignments) {
                peaks[index + lowIndex].kind = 'solvent';
            }
        }
        else {
            rowAssignments.sort((a, b) => b - a);
            for (let index of rowAssignments) {
                peaks.splice(index + lowIndex, 1);
            }
        }
    }
    return peaks;
}
exports.solventSuppression = solventSuppression;
function getSolventPeaks(signal, options = {}) {
    let signals = (0, addDummySignals_1.addDummySignals)([signal]);
    let spinSystem = (0, signalsToSpinSystem_1.signalsToSpinSystem)(signals);
    const { frequency = 400, maxClusterSize = 8 } = options;
    spinSystem.clusters = (0, splitSpinSystem_1.splitSpinSystem)(spinSystem, {
        frequency,
        maxClusterSize,
    });
    const peaks = (0, simulateXYPeaks_1.simulateXYPeaks)(spinSystem);
    return peaks.filter((peak) => peak.x < 1000);
}
function getShiftedSolventPeaks(peak, solventSignal, solventXYPeaks) {
    const shiftedSolventPeaks = JSON.parse(JSON.stringify(solventXYPeaks));
    // shift x values of solventPeaks to center it to the current peak.
    let deltaPPM = peak.x - solventSignal.delta;
    if (solventXYPeaks.length > 1 && solventXYPeaks.length % 2 === 0) {
        deltaPPM += solventXYPeaks[0].x;
    }
    const maxIntensity = shiftedSolventPeaks.reduce((max, current) => (current.y > max ? current.y : max), shiftedSolventPeaks[0].y);
    let currentDelta = 0;
    for (let shiftedSolventPeak of shiftedSolventPeaks) {
        shiftedSolventPeak.x += deltaPPM;
        shiftedSolventPeak.y /= maxIntensity;
        currentDelta += shiftedSolventPeak.x;
    }
    return {
        peaks: shiftedSolventPeaks,
        delta: currentDelta / shiftedSolventPeaks.length,
    };
}
function getClosestPeaks(shiftedSolventPeaks, nearPeaks) {
    const diff = getDiffMatrix(shiftedSolventPeaks, nearPeaks);
    const { rowAssignments, gain } = (0, linear_sum_assignment_1.linearSumAssignment)(diff, {
        maximaze: false,
    });
    if (gain === -1)
        return [];
    const assignmentPeaks = [];
    let maxValue = Number.MIN_SAFE_INTEGER;
    for (let index of rowAssignments) {
        if (maxValue < nearPeaks[index].y)
            maxValue = nearPeaks[index].y;
        assignmentPeaks.push({ ...nearPeaks[index] });
    }
    assignmentPeaks.forEach((peak, i, arr) => (arr[i].y /= maxValue));
    return assignmentPeaks;
}
function getDiffMatrix(rows, columns) {
    const nbColumns = columns.length;
    const nbRows = rows.length;
    const diff = new ml_matrix_1.Matrix(nbRows, nbColumns);
    for (let r = 0; r < nbRows; r++) {
        for (let c = 0; c < nbColumns; c++) {
            diff.set(r, c, Math.abs(rows[r].x - columns[c].x));
        }
    }
    return diff;
}

},{"../signals/addDummySignals":490,"../signals/simulation/signalsToSpinSystem":504,"../signals/simulation/simulateXYPeaks":506,"../signals/simulation/splitSpinSystem":507,"../utilities/clone":509,"linear-sum-assignment":16,"ml-matrix":186,"ml-peak-shape-generator":187,"ml-spectra-processing":208}],463:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"@lukeed/uuid":1,"dup":172}],464:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWidth = void 0;
const hasProperty_1 = require("../../utilities/hasProperty");
const { parse, stringify } = JSON;
/**
 * convert width and fwhm to ppm
 */
function convertWidth(peaks, options) {
    const { frequency, convertTo, output = parse(stringify(peaks)), } = options;
    const convert = getConverter(convertTo, frequency);
    for (const peak of output) {
        peak.width = convert(peak.width);
        if ((0, hasProperty_1.hasProperty)(peak, 'shape')) {
            const shape = peak.shape;
            if (shape.fwhm) {
                shape.fwhm = convert(shape.fwhm);
            }
        }
    }
    return output;
}
exports.convertWidth = convertWidth;
function getConverter(convertTo, frequency) {
    switch (convertTo) {
        case 'ppm':
            return (x) => x / frequency;
        case 'hz':
            return (x) => x * frequency;
        default:
            throw new Error(`Does not support convert to ${convertTo}`);
    }
}

},{"../../utilities/hasProperty":511}],465:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWidthToHz = void 0;
const convertWidth_1 = require("./convertWidth");
function convertWidthToHz(peaks, options) {
    return (0, convertWidth_1.convertWidth)(peaks, { ...options, convertTo: 'hz' });
}
exports.convertWidthToHz = convertWidthToHz;

},{"./convertWidth":464}],466:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWidthToPPM = void 0;
const convertWidth_1 = require("./convertWidth");
function convertWidthToPPM(peaks, options) {
    return (0, convertWidth_1.convertWidth)(peaks, { ...options, convertTo: 'ppm' });
}
exports.convertWidthToPPM = convertWidthToPPM;

},{"./convertWidth":464}],467:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineRealTop = void 0;
const ml_levenberg_marquardt_1 = require("ml-levenberg-marquardt");
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const direction8X = [-1, -1, -1, 0, 0, 1, 1, 1];
const direction8Y = [-1, 0, 1, -1, 1, -1, 0, 1];
const direction16X = [-2, -2, -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2, 2, 2];
const direction16Y = [-2, -1, 0, 1, 2, -2, 2, -2, 2, -2, 2, -2, -1, 0, 1, 2];
function determineRealTop(peaks, options) {
    let { nCols, absoluteData, originalData, minX, maxX, minY, maxY } = options;
    for (let i = 0; i < peaks.length; i++) {
        let xIndex = Math.round(peaks[i].x);
        let yIndex = Math.round(peaks[i].y);
        let currentIndex = xIndex + yIndex * nCols;
        let { index, isMax } = determineMax(absoluteData, {
            xIndex,
            yIndex,
            nCols,
            shell: 1,
        });
        currentIndex = isMax
            ? index
            : determineMax(absoluteData, {
                xIndex,
                yIndex,
                nCols,
                shell: 2,
            }).index;
        let realTopCoordinates = fitGaussian(originalData, {
            nCols,
            index: currentIndex,
            minY,
            maxY,
            minX,
            maxX,
        });
        peaks[i] = Object.assign(peaks[i], realTopCoordinates);
    }
    return peaks;
}
exports.determineRealTop = determineRealTop;
function determineMax(data, options) {
    let { xIndex, yIndex, shell, nCols } = options;
    let currentIndex = xIndex + yIndex * nCols;
    let [directionX, directionY] = shell > 1 ? [direction16X, direction16Y] : [direction8X, direction8Y];
    let isMax = false;
    for (let i = 0; i < directionX.length; i++) {
        let c = xIndex + directionX[i];
        let r = yIndex + directionY[i];
        if (data[c + r * nCols] >= data[currentIndex]) {
            isMax = true;
            let candidateIndex = c + r * nCols;
            for (let k = 0; k < direction8Y.length; k++) {
                let nc = c + direction8X[k];
                let nr = r + direction8Y[k];
                if (data[nc + nr * nCols] > data[candidateIndex]) {
                    isMax = false;
                    break;
                }
            }
            if (isMax) {
                currentIndex = candidateIndex;
            }
        }
    }
    return { index: currentIndex, isMax };
}
function fitGaussian(data, options) {
    let { nCols, index, minY, maxY, minX, maxX } = options;
    let nRows = data.length / nCols;
    let intervalX = (maxX - minX) / (nCols - 1);
    let intervalY = (maxY - minY) / (nRows - 1);
    let col = index % nCols;
    let row = (index - col) / nCols;
    let newCol = 1;
    let newRow = 1;
    let max = Number.MIN_SAFE_INTEGER;
    let z = new Array(direction8X.length + 1);
    let xAxis = new Array(direction8X.length + 1);
    for (let i = -1, xi = 0; i < 2; i++) {
        for (let j = -1; j < 2; j++, xAxis[xi] = xi++) {
            let value = data[col + j + (row + i) * nCols];
            if (max < value)
                max = value;
            z[newCol + j + (newRow + i) * 3] = value;
        }
    }
    for (let i = 0; i < z.length; i++)
        z[i] /= max;
    let maxValues = [newCol + 1, newRow + 1, 1.5, 1, 1];
    let minValues = [newCol - 1, newRow - 1, -1.5, 0.001, 0.001];
    let initialValues = [newCol, newRow, z[newCol + newRow * 3], 0.2, 0.2];
    let gradientDifference = [1e-4, 1e-4, 1e-3, 1e-3, 1e-3];
    let func = paramGaussian2D(intervalX, intervalY, 3);
    let pFit = (0, ml_levenberg_marquardt_1.levenbergMarquardt)({ x: xAxis, y: z }, func, {
        damping: 1.5,
        maxIterations: 100,
        errorTolerance: 1e-8,
        initialValues,
        gradientDifference,
        maxValues,
        minValues,
    }).parameterValues;
    return {
        x: pFit[0] + col - 1,
        y: pFit[1] + row - 1,
        z: pFit[2] * max,
    };
}
function paramGaussian2D(intervalX, intervalY, nCols) {
    const gaussian2D = new ml_peak_shape_generator_1.Gaussian2D();
    return (p) => {
        return (t) => {
            let nL = p.length / 5;
            let result = 0;
            let xIndex = t % nCols;
            let yIndex = (t - xIndex) / nCols;
            for (let i = 0; i < nL; i++) {
                gaussian2D.fwhm = { x: p[i + 3 * nL], y: p[i + 4 * nL] };
                result +=
                    p[i + 2 * nL] *
                        gaussian2D.fct((xIndex - p[i]) * intervalX, (yIndex - p[i + nL]) * intervalY);
            }
            return result;
        };
    };
}

},{"ml-levenberg-marquardt":182,"ml-peak-shape-generator":187}],468:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKernel = void 0;
function getKernel(options = {}) {
    let { sigma = 1.4, xLength = 9, yLength = 9 } = options;
    let factor = -40 / laplacianOfGaussian(0, 0, sigma);
    const xCenter = (xLength - 1) / 2;
    const yCenter = (yLength - 1) / 2;
    let matrix = new Array(xLength);
    for (let x = 0; x < xLength; x++) {
        matrix[x] = new Array(yLength);
        for (let y = 0; y < yLength; y++) {
            matrix[x][y] =
                laplacianOfGaussian(x - xCenter, y - yCenter, sigma) * factor;
        }
    }
    return matrix;
}
exports.getKernel = getKernel;
const laplacianOfGaussian = (x, y, sigma) => {
    let factor = -(Math.pow(x, 2) + Math.pow(y, 2)) / 2 / Math.pow(sigma, 2);
    return -(1 / Math.PI / Math.pow(sigma, 4)) * (1 + factor) * Math.exp(factor);
};

},{}],469:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enhanceSymmetry = exports.clean = void 0;
let diagonalError = 0.05;
let tolerance = 0.05;
function clean(peaks, threshold) {
    let max = Number.NEGATIVE_INFINITY;
    // double min = Double.MAX_VALUE;
    for (let i = peaks.length - 1; i >= 0; i--) {
        if (Math.abs(peaks[i].z) > max) {
            max = Math.abs(peaks[i].z);
        }
    }
    max *= threshold;
    for (let i = peaks.length - 1; i >= 0; i--) {
        if (Math.abs(peaks[i].z) < max) {
            peaks.splice(i, 1);
        }
    }
    return peaks;
}
exports.clean = clean;
function enhanceSymmetry(signals) {
    let properties = initializeProperties(signals);
    let output = signals.slice();
    // First step of the optimization: Symmetry validation
    let hits;
    for (let i = output.length - 1; i >= 0; i--) {
        let signal = output[i];
        if (signal.peaks && signal.peaks.length > 1) {
            properties[i][1]++;
        }
        if (properties[i][0] === 1) {
            let index = exist(output, properties, signal, -1, true);
            if (index >= 0) {
                properties[i][1] += 2;
                properties[index][1] += 2;
            }
        }
    }
    // Second step of the optimization: Diagonal image existence
    for (let i = output.length - 1; i >= 0; i--) {
        let signal = output[i];
        if (properties[i][0] === 0) {
            hits = checkCrossPeaks(output, properties, signal, true);
            properties[i][1] += hits;
            // checkCrossPeaks(output, properties, signal, false);
        }
    }
    // Now, each peak have a score between 0 and 4, we can complete the patterns which
    // contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1
    let count = 0;
    for (let i = output.length - 1; i >= 0; i--) {
        if (properties[i][0] !== 0 && properties[i][1] > 2) {
            count++;
            count += completeMissingIfNeeded(output, properties, output[i], properties[i]);
        }
        if (properties[i][1] >= 2 && properties[i][0] === 0) {
            count++;
        }
    }
    let toReturn = new Array(count);
    count--;
    for (let i = output.length - 1; i >= 0; i--) {
        if ((properties[i][0] !== 0 && properties[i][1] > 2) ||
            (properties[i][0] === 0 && properties[i][1] > 1)) {
            toReturn[count--] = output[i];
        }
    }
    return toReturn;
}
exports.enhanceSymmetry = enhanceSymmetry;
// export function alignDimensions(signals2D, references) {
//   // For each reference dimension
//   for (let i = 0; i < references.length; i++) {
//     let ref = references[i];
//     if (ref) {
//       alignSingleDimension(signals2D, ref);
//     }
//   }
// }
function completeMissingIfNeeded(output, properties, thisSignal, thisProp) {
    // Check for symmetry
    let index = exist(output, properties, thisSignal, -thisProp[0], true);
    let addedPeaks = 0;
    let newSignal;
    let tmpProp = null;
    if (index < 0) {
        // If this signal have no a symmetry image, we have to include it
        newSignal = {
            x: {
                nucleus: thisSignal.x.nucleus,
                resolution: thisSignal.x.resolution,
                delta: thisSignal.y.delta,
            },
            y: {
                nucleus: thisSignal.y.nucleus,
                resolution: thisSignal.y.resolution,
                delta: thisSignal.x.delta,
            },
            peaks: [{ x: thisSignal.y.delta, y: thisSignal.x.delta, z: 1 }],
        };
        output.push(newSignal);
        tmpProp = [-thisProp[0], thisProp[1]];
        properties.push(tmpProp);
        addedPeaks++;
    }
    // Check for diagonal peaks
    let signal;
    let diagX = false;
    let diagY = false;
    for (let j = output.length - 1; j >= 0; j--) {
        signal = output[j];
        if (properties[j][0] === 0) {
            if (Math.abs(signal.x.delta - thisSignal.x.delta) < diagonalError) {
                diagX = true;
            }
            if (Math.abs(signal.y.delta - thisSignal.y.delta) < diagonalError) {
                diagY = true;
            }
        }
    }
    if (!diagX) {
        newSignal = {
            x: {
                delta: thisSignal.y.delta,
                nucleus: thisSignal.x.nucleus,
                resolution: thisSignal.x.resolution,
            },
            y: {
                delta: thisSignal.x.delta,
                nucleus: thisSignal.y.nucleus,
                resolution: thisSignal.y.resolution,
            },
            peaks: [{ x: thisSignal.x.delta, y: thisSignal.x.delta, z: 1 }],
        };
        newSignal.peaks = [{ x: thisSignal.x.delta, y: thisSignal.x.delta, z: 1 }];
        output.push(newSignal);
        tmpProp = [0, thisProp[1]];
        properties.push(tmpProp);
        addedPeaks++;
    }
    if (!diagY) {
        newSignal = {
            x: {
                delta: thisSignal.y.delta,
                nucleus: thisSignal.x.nucleus,
                resolution: thisSignal.x.resolution,
            },
            y: {
                delta: thisSignal.y.delta,
                nucleus: thisSignal.y.nucleus,
                resolution: thisSignal.y.resolution,
            },
            peaks: [{ x: thisSignal.y.delta, y: thisSignal.y.delta, z: 1 }],
        };
        output.push(newSignal);
        tmpProp = [0, thisProp[1]];
        properties.push(tmpProp);
        addedPeaks++;
    }
    return addedPeaks;
}
// Check for any diagonal peak that match this cross peak
function checkCrossPeaks(output, properties, signal, updateProperties) {
    let hits = 0;
    let shift = signal.x.delta * 4;
    let crossPeaksX = [];
    let crossPeaksY = [];
    let cross;
    for (let i = output.length - 1; i >= 0; i--) {
        cross = output[i];
        if (properties[i][0] !== 0) {
            if (Math.abs(cross.x.delta - signal.x.delta) < diagonalError) {
                hits++;
                if (updateProperties) {
                    properties[i][1]++;
                }
                crossPeaksX.push(i);
                shift += cross.x.delta;
            }
            else if (Math.abs(cross.y.delta - signal.y.delta) < diagonalError) {
                hits++;
                if (updateProperties) {
                    properties[i][1]++;
                }
                crossPeaksY.push(i);
                shift += cross.y.delta;
            }
        }
    }
    // Update found crossPeaks and diagonal peak
    shift /= crossPeaksX.length + crossPeaksY.length + 4;
    if (crossPeaksX.length > 0) {
        for (let i = crossPeaksX.length - 1; i >= 0; i--) {
            output[crossPeaksX[i]].x.delta = shift;
        }
    }
    if (crossPeaksY.length > 0) {
        for (let i = crossPeaksY.length - 1; i >= 0; i--) {
            output[crossPeaksY[i]].y.delta = shift;
        }
    }
    signal.x.delta = shift;
    signal.y.delta = shift;
    return hits;
}
function exist(output, properties, signal, type, symmetricSearch) {
    for (let i = output.length - 1; i >= 0; i--) {
        if (properties[i][0] === type) {
            if (distanceTo(signal, output[i], symmetricSearch) < tolerance) {
                if (!symmetricSearch) {
                    let shiftX = (output[i].x.delta + signal.x.delta) / 2.0;
                    let shiftY = (output[i].y.delta + signal.y.delta) / 2.0;
                    output[i].x.delta = shiftX;
                    output[i].y.delta = shiftY;
                    signal.x.delta = shiftX;
                    signal.y.delta = shiftY;
                }
                else {
                    let shiftX = signal.x.delta;
                    let shiftY = output[i].x.delta;
                    output[i].y.delta = shiftX;
                    signal.y.delta = shiftY;
                }
                return i;
            }
        }
    }
    return -1;
}
/**
 * Try to determine the position of each signal within the spectrum matrix.
 * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1
 * respectively.
 * @param {Array} signals
 * @return {*} A matrix containing the properties of each signal
 * @private
 */
function initializeProperties(signals) {
    let signalsProperties = new Array(signals.length);
    for (let i = signals.length - 1; i >= 0; i--) {
        signalsProperties[i] = [0, 0];
        // We check if it is a diagonal peak
        if (Math.abs(signals[i].x.delta - signals[i].y.delta) <= diagonalError) {
            signalsProperties[i][1] = 1;
            let shift = (signals[i].x.delta * 2 + signals[i].y.delta) / 3.0;
            signals[i].x.delta = shift;
            signals[i].y.delta = shift;
        }
        else if (signals[i].x.delta - signals[i].y.delta > 0) {
            signalsProperties[i][0] = 1;
        }
        else {
            signalsProperties[i][0] = -1;
        }
    }
    return signalsProperties;
}
/**
 * This function calculates the distance between 2 nmr signals . If toImage is true,
 * it will interchange x by y in the distance calculation for the second signal.
 * @param {object} a
 * @param {object} b
 * @param {boolean} toImage
 * @return {number}
 * @private
 */
function distanceTo(a, b, toImage) {
    if (!toImage) {
        return Math.sqrt(Math.pow(a.x.delta - b.x.delta, 2) + Math.pow(a.y.delta - b.y.delta, 2));
    }
    else {
        return Math.sqrt(Math.pow(a.x.delta - b.y.delta, 2) + Math.pow(a.y.delta - b.x.delta, 2));
    }
}
// type Signal2DWithHighlight = MakeMandatory<NMRSignal2D, '_highlight'>;
// function checkHighlight(signals2D: NMRSignal2D[]): asserts signals2D is Signal2DwithHighlight[] {
//   for (let signal of signals2D) {
//     if (!signal._highlight) throw new Error('there is not _hightlight property');
//     if (!signal.nucleusX) throw new Error('there is not nucleusX property');
//     if (!signal.nucleusY) throw new Error('there is not nucleusY property')
//   }
// }
// function alignSingleDimension(signals2D: NMRSignal2D[], references) {
//   // For each 2D signal
//   for (let i = 0; i < signals2D.length; i++) {
//     let signal2D = signals2D[i];
//     for (let j = 0; j < references.length; j++) {
//       const center = (references[j].startX + references[j].stopX) / 2;
//       const width = Math.abs(references[j].startX - references[j].stopX) / 2;
//       if (signal2D.nucleusX === references[j].nucleus) {
//         // The 2D peak overlaps with the 1D signal
//         if (Math.abs(signal2D.x.delta - center) <= width) {
//           signal2D._highlight.push(references[j]._highlight[0]);
//         }
//       }
//       if (signal2D.nucleusY === references[j].nucleus) {
//         if (Math.abs(signal2D.y.delta - center) <= width) {
//           signal2D._highlight.push(references[j]._highlight[0]);
//         }
//       }
//     }
//   }
// }

},{}],470:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setIDs = void 0;
const uuid_1 = require("@lukeed/uuid");
const { parse, stringify } = JSON;
function setIDs(peaks, options = {}) {
    const output = (options.output || parse(stringify(peaks)));
    for (const peak of output) {
        peak.id = (0, uuid_1.v4)();
    }
    return output;
}
exports.setIDs = setIDs;

},{"@lukeed/uuid":1}],471:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictAll = void 0;
const openchemlib_utils_1 = require("openchemlib-utils");
const predictCOSY_1 = require("./predictCOSY");
const predictCarbon_1 = require("./predictCarbon");
const predictHMBC_1 = require("./predictHMBC");
const predictHSQC_1 = require("./predictHSQC");
const predictProton_1 = require("./predictProton");
const getPredictions_1 = require("./utils/getPredictions");
/**
 * Generate the correlation bidimensional nmr peaks based on the number of bonds between a pair of atoms
 * @returns {Promise<object>} - object with molfile, diaIDs, 1D and 2D signals, joined signals, ranges and zones.
 */
async function predictAll(molecule, options = {}) {
    let { from = 'H', to = 'C', predictor = { H: predictProton_1.predictProton, C: predictCarbon_1.predictCarbon }, predictions, joinDistance = { H: 0.05, C: 0.5 }, predictOptions = {}, } = options;
    const diaIDs = (0, openchemlib_utils_1.getDiastereotopicAtomIDs)(molecule);
    const xPrediction = await (0, getPredictions_1.getPredictions)(from, molecule, predictOptions, predictor, predictions);
    const yPrediction = await (0, getPredictions_1.getPredictions)(to, molecule, predictOptions, predictor, predictions);
    if (!xPrediction || !yPrediction) {
        throw new Error('predictions are not availaible');
    }
    predictions = {
        H: xPrediction,
        C: yPrediction,
    };
    const { molfile } = xPrediction;
    const spectra = {
        proton: predictions.H,
        carbon: predictions.C,
    };
    spectra.cosy = await (0, predictCOSY_1.predictCOSY)(molecule, {
        predictions,
        joinDistance,
    });
    spectra.hsqc = await (0, predictHSQC_1.predictHSQC)(molecule, {
        predictions,
        joinDistance,
    });
    spectra.hmbc = await (0, predictHMBC_1.predictHMBC)(molecule, {
        predictions,
        joinDistance,
    });
    for (const key in spectra) {
        delete spectra[key].molfile;
        delete spectra[key].diaIDs;
    }
    return {
        molfile,
        diaIDs,
        ...spectra,
    };
}
exports.predictAll = predictAll;

},{"./predictCOSY":473,"./predictCarbon":474,"./predictHMBC":475,"./predictHSQC":476,"./predictProton":477,"./utils/getPredictions":481,"openchemlib-utils":525}],472:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictAllSpectra = void 0;
const signals2DToZ_1 = require("../signals/signals2DToZ");
const signalsToXY_1 = require("../signals/signalsToXY");
const getFrequency_1 = require("../utilities/getFrequency");
const predictAll_1 = require("./predictAll");
async function predictAllSpectra(molecule, options = {}) {
    const { simulation: simulationOptions = { oneD: {}, twoD: {} }, prediction: predictionOptions = {}, } = options;
    const predictions = await (0, predictAll_1.predictAll)(molecule, predictionOptions);
    const spectra = [];
    const result = { spectra, molecules: [{ molfile: predictions.molfile }] };
    const oneDOptions = {
        ...{
            proton: { from: 0, to: 14 },
            carbon: { from: 0, to: 200 },
            nbPoints: 65536,
            lineWidth: 1,
        },
        ...(simulationOptions.oneD || {}),
    };
    const twoDOptions = {
        ...{
            from: { x: oneDOptions.proton.from, y: oneDOptions.carbon.from },
            to: { x: oneDOptions.proton.to, y: oneDOptions.carbon.to },
            nbPoints: { x: 1024, y: 1024 },
        },
        ...(simulationOptions.twoD || {}),
    };
    for (const experiment in predictions) {
        switch (experiment) {
            case 'carbon':
            case 'proton': {
                spectra.push(get1DSpectrum(predictions[experiment], {
                    nbPoints: oneDOptions.nbPoints,
                    lineWidth: oneDOptions.lineWidth,
                    ...oneDOptions[experiment],
                    experiment,
                    frequency: simulationOptions.frequency,
                }));
                break;
            }
            case 'cosy':
            case 'hsqc':
            case 'hmbc': {
                spectra.push(get2DSpectrum(predictions[experiment], {
                    ...twoDOptions,
                    experiment,
                    frequency: simulationOptions.frequency,
                }));
                break;
            }
            default:
                break;
        }
    }
    return result;
}
exports.predictAllSpectra = predictAllSpectra;
function get2DSpectrum(prediction, options) {
    const { signals, zones, nuclei } = prediction;
    const { frequency: baseFrequency, experiment } = options;
    const width = get2DWidth(nuclei);
    const frequency = calculateFrequency(nuclei, baseFrequency);
    const minMaxContent = (0, signals2DToZ_1.signals2DToZ)(signals, {
        ...options,
        width,
        factor: 3,
    });
    const spectrum = {
        data: { rr: { ...minMaxContent, noise: 0.01 } },
        info: {
            nucleus: nuclei,
            originFrequency: frequency,
            baseFrequency: frequency,
            pulseSequence: experiment,
            experiment: '2d',
        },
        zones: { values: zones },
    };
    return spectrum;
}
function get2DWidth(nucleus) {
    return nucleus[0] === nucleus[1] ? 0.02 : { x: 0.02, y: 0.2133 };
}
function get1DSpectrum(prediction, options) {
    const { frequency = 400, experiment } = options;
    const { signals, nucleus } = prediction;
    const realFrequency = calculateFrequency(nucleus, frequency);
    const { x, y } = (0, signalsToXY_1.signalsToXY)(signals, {
        ...options,
        frequency: realFrequency,
    });
    const spectrum = {
        // todo Array.from is temporary for the developement
        data: { x: Array.from(x), re: Array.from(y), im: null },
        info: {
            nucleus: prediction.nucleus,
            dimension: 1,
            originFrequency: realFrequency,
            baseFrequency: realFrequency,
            pulseSequence: 'prediction',
            experiment,
            isFt: true,
        },
        ranges: { values: prediction.ranges },
    };
    return spectrum;
}
function calculateFrequency(nucleus, frequency) {
    if (typeof nucleus === 'string') {
        return (0, getFrequency_1.getFrequency)(nucleus, { nucleus: '1H', frequency });
    }
    else if (nucleus[0] === nucleus[1]) {
        return `${frequency},${frequency}`;
    }
    else {
        return `${frequency},${(0, getFrequency_1.getFrequency)(nucleus[1], {
            nucleus: nucleus[0],
            frequency,
        })}`;
    }
}

},{"../signals/signals2DToZ":498,"../signals/signalsToXY":502,"../utilities/getFrequency":510,"./predictAll":471}],473:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictCOSY = void 0;
const predictProton_1 = require("./predictProton");
const predict2D_1 = require("./utils/predict2D");
/**
 * Generate the correlation bidimensional nmr peaks based on the number of bonds between a pair of atoms
 * @returns {Promise<object>} - object with molfile, diaIDs, 2D signals joined signals and zones.
 */
async function predictCOSY(molecule, options = {}) {
    let { minLength = 2, maxLength = 3, predictions, predictor = { H: predictProton_1.predictProton }, predictOptions, joinDistance = { H: 0.05, C: 0.5 }, includeDiagonal = true, } = options;
    return (0, predict2D_1.predict2D)(molecule, {
        from: 'H',
        to: 'H',
        predictor,
        minLength,
        maxLength,
        joinDistance,
        predictions,
        includeDiagonal,
        predictOptions,
    });
}
exports.predictCOSY = predictCOSY;

},{"./predictProton":477,"./utils/predict2D":482}],474:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictCarbon = void 0;
const uuid_1 = require("@lukeed/uuid");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const openchemlib_utils_1 = require("openchemlib-utils");
const setIDs_1 = require("../peaks/util/setIDs");
const signalsToRanges_1 = require("../signals/signalsToRanges");
const fetchPrediction_1 = require("./utils/fetchPrediction");
const getFilteredIDiaIDs_1 = require("./utils/getFilteredIDiaIDs");
const queryByHOSE_1 = require("./utils/queryByHOSE");
const cache = {};
async function loadDB(url = 'https://www.lactame.com/lib/nmr-processing-data/20210711/carbon.js') {
    if (cache[url]) {
        return cache[url];
    }
    const response = await (0, cross_fetch_1.default)(url);
    const database = await response.json();
    cache[url] = database;
    return database;
}
function checkFromPrediction(signal) {
    if (!signal.atoms)
        throw new Error('There is not atoms');
    if (!signal.diaIDs)
        throw new Error('There is not diaIDs');
    if (!signal.nbAtoms)
        throw new Error('There is not nbAtoms');
}
/**
 * Make a query to a hose code based database to predict carbon chemical shift
 * @returns {Promise<object>} - object with molfile, diaIDs, signals, joined signals by diaIDs and ranges.
 */
async function predictCarbon(molecule, options = {}) {
    let { url, database, webserviceURL, diaIDs = (0, openchemlib_utils_1.getDiastereotopicAtomIDs)(molecule), } = options;
    if (webserviceURL) {
        return (0, fetchPrediction_1.fetchPrediction)(molecule, { webserviceURL });
    }
    if (!database)
        database = await loadDB(url);
    if (!database) {
        throw new Error('There is not a database');
    }
    const maxLevel = database.length - 1;
    let { maxSphereSize = maxLevel } = options;
    if (maxSphereSize > maxLevel)
        maxSphereSize = maxLevel;
    const { carbonDiaIDs, molfile } = (0, getFilteredIDiaIDs_1.getFilteredIDiaIDs)(molecule, {
        maxSphereSize,
        diaIDs,
    });
    let predictions = (0, queryByHOSE_1.queryByHose)(carbonDiaIDs, database, {
        maxSphereSize,
    });
    const signals = formatSignals(predictions);
    const joinedSignals = joinSignalByDiaID(signals);
    return {
        molfile,
        nucleus: '13C',
        diaIDs,
        joinedSignals,
        signals,
        ranges: (0, signalsToRanges_1.signalsToRanges)(joinedSignals),
        molecule,
    };
}
exports.predictCarbon = predictCarbon;
function formatSignals(predictions) {
    let signals = [];
    for (const prediction of predictions) {
        const { atoms, nbAtoms, delta, diaIDs, statistic } = prediction;
        const signal = {
            id: (0, uuid_1.v4)(),
            delta: delta || NaN,
            atoms,
            diaIDs,
            multiplicity: 's',
            nbAtoms,
            statistic,
            js: [],
        };
        signals.push(signal);
    }
    return signals;
}
function joinSignalByDiaID(signals) {
    let joinedSignals = {};
    for (let signal of signals) {
        checkFromPrediction(signal);
        let diaID = signal.diaIDs[0];
        if (!joinedSignals[diaID]) {
            joinedSignals[diaID] = JSON.parse(JSON.stringify(signal));
        }
        else {
            joinedSignals[diaID].nbAtoms += signal.nbAtoms;
            joinedSignals[diaID].atoms.push(...signal.atoms);
        }
    }
    return (0, setIDs_1.setIDs)(Object.values(joinedSignals));
}

},{"../peaks/util/setIDs":470,"../signals/signalsToRanges":501,"./utils/fetchPrediction":478,"./utils/getFilteredIDiaIDs":479,"./utils/queryByHOSE":483,"@lukeed/uuid":1,"cross-fetch":4,"openchemlib-utils":525}],475:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictHMBC = void 0;
const predictCarbon_1 = require("./predictCarbon");
const predictProton_1 = require("./predictProton");
const predict2D_1 = require("./utils/predict2D");
async function predictHMBC(molecule, options = {}) {
    let { minLength = 2, maxLength = 3, predictor = { H: predictProton_1.predictProton, C: predictCarbon_1.predictCarbon }, predictOptions, predictions, joinDistance = { H: 0.05, C: 0.5 }, } = options;
    return (0, predict2D_1.predict2D)(molecule, {
        from: 'H',
        to: 'C',
        predictor,
        minLength,
        maxLength,
        predictions,
        predictOptions,
        joinDistance,
    });
}
exports.predictHMBC = predictHMBC;

},{"./predictCarbon":474,"./predictProton":477,"./utils/predict2D":482}],476:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictHSQC = void 0;
const predictCarbon_1 = require("./predictCarbon");
const predictProton_1 = require("./predictProton");
const predict2D_1 = require("./utils/predict2D");
/**
 * Generate the correlation bidimensional nmr peaks based on the number of bonds between a pair of atoms
 * @returns {Promise<object>} - object with molfile, diaIDs, 2D signals joined signals and zones.
 */
async function predictHSQC(molecule, options = {}) {
    let { minLength = 1, maxLength = 1, predictor = { H: predictProton_1.predictProton, C: predictCarbon_1.predictCarbon }, predictions, joinDistance = { H: 0.05, C: 0.5 }, predictOptions, } = options;
    return (0, predict2D_1.predict2D)(molecule, {
        from: 'H',
        to: 'C',
        predictor,
        minLength,
        maxLength,
        predictions,
        predictOptions,
        joinDistance,
    });
}
exports.predictHSQC = predictHSQC;

},{"./predictCarbon":474,"./predictProton":477,"./utils/predict2D":482}],477:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictProton = void 0;
const uuid_1 = require("@lukeed/uuid");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const form_data_1 = __importDefault(require("form-data"));
const openchemlib_utils_1 = require("openchemlib-utils");
const signalsJoin_1 = require("../signals/signalsJoin");
const signalsToRanges_1 = require("../signals/signalsToRanges");
async function predictProton(molecule, options = {}) {
    const { cache } = options;
    molecule = molecule.getCompactCopy();
    molecule.addImplicitHydrogens();
    (0, openchemlib_utils_1.addDiastereotopicMissingChirality)(molecule);
    const molfile = molecule.toMolfile();
    let result;
    if (cache) {
        result = cache(molfile);
    }
    if (result === undefined) {
        const formData = new form_data_1.default();
        formData.append('molfile', molfile);
        const response = await (0, cross_fetch_1.default)('https://www.nmrdb.org/service/predictor', {
            method: 'POST',
            // @ts-expect-error RequestInit type does not include FormData.
            body: formData,
        });
        result = await response.text();
        if (cache) {
            cache(molfile, result);
        }
    }
    const { diaIDs = (0, openchemlib_utils_1.getDiastereotopicAtomIDs)(molecule) } = options;
    const signals = protonParser(result, molecule, diaIDs);
    const joinedSignals = (0, signalsJoin_1.signalsJoin)(signals);
    return {
        molfile,
        diaIDs,
        nucleus: '1H',
        joinedSignals,
        signals,
        ranges: (0, signalsToRanges_1.signalsToRanges)(joinedSignals),
        molecule,
    };
}
exports.predictProton = predictProton;
function protonParser(result, molecule, diaIDs) {
    if (molecule.getAllAtoms() === 0)
        return [];
    if (result.includes('ERR')) {
        throw Error(`Spinus optimization: ${result}`);
    }
    let distanceMatrix = (0, openchemlib_utils_1.getConnectivityMatrix)(molecule, { pathLength: true });
    let lines = result.split('\n').filter((line) => line);
    let signals = [];
    for (let line of lines) {
        let fields = line.split('\t');
        let couplings = fields.slice(4);
        let atom = Number(fields[0]) - 1;
        let signal = {
            id: (0, uuid_1.v4)(),
            atoms: [atom],
            diaIDs: [diaIDs[atom]],
            nbAtoms: 1,
            delta: Number(fields[2]),
            js: [],
        };
        if (!signal.js) {
            throw new Error(`For atom js property was not added`);
        }
        for (let i = 0; i < couplings.length; i += 3) {
            let linked = Number(couplings[i]) - 1;
            signal.js.push({
                coupling: Number(couplings[i + 2]),
                atoms: [linked],
                diaIDs: [diaIDs[linked]],
                multiplicity: 'd',
                pathLength: distanceMatrix[atom][linked],
            });
            signal.js.sort((a, b) => b.coupling - a.coupling);
        }
        signals.push(signal);
    }
    return signals;
}

},{"../signals/signalsJoin":499,"../signals/signalsToRanges":501,"@lukeed/uuid":1,"cross-fetch":4,"form-data":9,"openchemlib-utils":525}],478:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchPrediction = void 0;
const cross_fetch_1 = require("cross-fetch");
async function fetchPrediction(molecule, options) {
    const { webserviceURL } = options;
    const response = await (0, cross_fetch_1.fetch)(webserviceURL, {
        headers: {
            accept: 'application/json',
            'content-type': 'application/json',
        },
        body: JSON.stringify({ molfile: molecule.toMolfile() }),
        method: 'POST',
    });
    const prediction = (await response.json()).data;
    prediction.molecule = molecule
        .getOCL()
        .Molecule.fromMolfile(prediction.molfile);
    return prediction;
}
exports.fetchPrediction = fetchPrediction;

},{"cross-fetch":4}],479:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilteredIDiaIDs = void 0;
const openchemlib_utils_1 = require("openchemlib-utils");
function getFilteredIDiaIDs(molecule, options) {
    const { maxSphereSize, diaIDs } = options;
    molecule.addImplicitHydrogens();
    molecule.addMissingChirality();
    (0, openchemlib_utils_1.addDiastereotopicMissingChirality)(molecule);
    const molfile = molecule.toMolfile();
    let groupedDiaIDs = (0, openchemlib_utils_1.groupDiastereotopicAtomIDs)(diaIDs, molecule, {
        atomLabel: 'C',
    });
    let carbonDiaIDs = groupedDiaIDs.sort((a, b) => {
        if (a.atomLabel === b.atomLabel) {
            return b.counter - a.counter;
        }
        return a.atomLabel < b.atomLabel ? 1 : -1;
    });
    const OCL = molecule.getOCL();
    for (const diaId of carbonDiaIDs) {
        diaId.hose = (0, openchemlib_utils_1.getHoseCodesFromDiastereotopicID)(OCL.Molecule.fromIDCode(diaId.oclID), {
            maxSphereSize,
        });
    }
    let toReturn = {
        molfile,
        carbonDiaIDs: carbonDiaIDs,
    };
    return toReturn;
}
exports.getFilteredIDiaIDs = getFilteredIDiaIDs;

},{"openchemlib-utils":525}],480:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNuclei = void 0;
const nucleusMap = {
    h: '1H',
    c: '13C',
};
function getNuclei(input) {
    return Object.values(input).map((e) => nucleusMap[e.toLowerCase()]);
}
exports.getNuclei = getNuclei;

},{}],481:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPredictions = void 0;
async function getPredictions(key, molecule, predictOptions, predictor, predictions) {
    let prediction;
    if (predictions === null || predictions === void 0 ? void 0 : predictions[key]) {
        prediction = predictions[key];
    }
    else if (predictor) {
        const fromPredictor = predictor[key];
        prediction = fromPredictor
            ? await fromPredictor(molecule, predictOptions[key])
            : undefined;
    }
    return prediction;
}
exports.getPredictions = getPredictions;

},{}],482:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predict2D = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_hclust_1 = require("ml-hclust");
const ml_matrix_1 = require("ml-matrix");
const openchemlib_utils_1 = require("openchemlib-utils");
const setIDs_1 = require("../../peaks/util/setIDs");
const getNuclei_1 = require("./getNuclei");
const getPredictions_1 = require("./getPredictions");
function checkFromTo(options) {
    if (!options.from || !options.to) {
        throw new Error('options from and to are mandatory');
    }
}
async function predict2D(molecule, options = {}) {
    checkFromTo(options);
    molecule.addImplicitHydrogens();
    let { from, to, diaIDs, minLength = 0, maxLength, predictOptions = {}, predictions, predictor, joinDistance = { H: 0.05, C: 0.5 }, includeDiagonal = false, } = options;
    const pathsInfo = (0, openchemlib_utils_1.getPathsInfo)(molecule, {
        fromLabel: from,
        toLabel: to,
        minLength,
        maxLength,
    });
    const groupedDiaIDS = diaIDs
        ? (0, openchemlib_utils_1.groupDiastereotopicAtomIDs)(diaIDs, molecule)
        : (0, openchemlib_utils_1.getGroupedDiastereotopicAtomIDs)(molecule);
    let diaIDswithAtomInfo = [];
    for (let diaID of groupedDiaIDS) {
        diaIDswithAtomInfo.push({
            ...diaID,
            pathInfo: JSON.parse(JSON.stringify(pathsInfo[diaID.atoms[0]])),
        });
    }
    const xPrediction = await (0, getPredictions_1.getPredictions)(from, molecule, predictOptions, predictor, predictions);
    const yPrediction = from === to
        ? xPrediction
        : await (0, getPredictions_1.getPredictions)(to, molecule, predictOptions, predictor, predictions);
    if (!xPrediction || !yPrediction) {
        throw new Error('predictions are not availaible');
    }
    const spectra = {
        x: xPrediction,
        y: yPrediction,
    };
    const signalsByDiaID = {
        x: {},
        y: {},
    };
    for (const axis in signalsByDiaID) {
        for (const signal of spectra[axis].joinedSignals) {
            if (!signal.diaIDs)
                throw new Error('Signal has not diaIDs');
            signalsByDiaID[axis][signal.diaIDs[0]] = signal;
        }
    }
    let group = {};
    for (const diaID of diaIDswithAtomInfo) {
        const pathInfo = diaID.pathInfo;
        if (pathInfo.paths.length < 1)
            continue;
        if (!signalsByDiaID.x[pathInfo.oclID])
            continue;
        const currentPaths = pathInfo.paths;
        for (const path of currentPaths) {
            if (!signalsByDiaID.y[pathsInfo[path.to].oclID])
                continue;
            let fromToDiaID = {
                x: pathInfo,
                y: pathsInfo[path.to],
            };
            const key = `${fromToDiaID.x.oclID}-${fromToDiaID.y.oclID}`;
            if (key === `${pathInfo.oclID}-${pathInfo.oclID}` || group[key]) {
                continue;
            }
            let peak = { id: (0, uuid_1.v4)(), z: 100 };
            let signal = { id: (0, uuid_1.v4)(), x: {}, y: {} };
            for (let axis in fromToDiaID) {
                let diaID = fromToDiaID[axis].oclID;
                peak[axis] = signalsByDiaID[axis][diaID].delta;
                signal[axis].delta = signalsByDiaID[axis][diaID].delta;
                signal[axis].diaIDs = [diaID];
                signal[axis].atoms = signalsByDiaID[axis][diaID].atoms;
            }
            signal.peaks = [peak];
            group[key] = signal;
        }
    }
    if (includeDiagonal) {
        addSelftCorrelation(group, { paths: pathsInfo, signalsByDiaID });
    }
    // clusterize signals by distance
    const joinedSignals = Object.values(group);
    const zones = createZones(joinedSignals, { joinDistance, from, to });
    return {
        molfile: molecule.toMolfile(),
        diaIDs: spectra.x.diaIDs,
        nuclei: (0, getNuclei_1.getNuclei)({ from, to }),
        joinedSignals,
        signals: splitSignals(joinedSignals),
        zones,
        molecule,
    };
}
exports.predict2D = predict2D;
function splitSignals(joinedSignals) {
    let signals = [];
    for (const signal of joinedSignals) {
        for (const xAtom of signal.x.atoms || []) {
            for (const yAtom of signal.y.atoms || []) {
                let newSignal = JSON.parse(JSON.stringify(signal));
                newSignal.x.atoms = [xAtom];
                newSignal.y.atoms = [yAtom];
                signals.push(newSignal);
            }
        }
    }
    return (0, setIDs_1.setIDs)(signals);
}
function addSelftCorrelation(group, options) {
    const { paths = [], signalsByDiaID } = options;
    for (const atom of paths) {
        if (atom.paths.length < 1)
            continue;
        let diaID = atom.oclID;
        if (!signalsByDiaID.x[diaID])
            continue;
        if (group[`${diaID}-${diaID}`])
            continue;
        let signal = { x: {}, y: {} };
        let peak = { z: 1 };
        for (let axis of ['x', 'y']) {
            peak[axis] = signalsByDiaID[axis][diaID].delta;
            signal[axis].delta = signalsByDiaID[axis][diaID].delta;
            signal[axis].diaIDs = [diaID];
            signal[axis].atoms = signalsByDiaID[axis][diaID].atoms;
        }
        signal.peaks = [peak];
        group[`${atom.oclID}-${atom.oclID}`] = signal;
    }
}
function createZones(signals, options) {
    const { joinDistance, from, to } = options;
    const deltas = new ml_matrix_1.Matrix(signals.map((e) => [e.x.delta, e.y.delta]));
    const minX = deltas.minColumn(0);
    const maxX = deltas.maxColumn(0);
    const minY = deltas.minColumn(1);
    const maxY = deltas.maxColumn(1);
    deltas.mulColumn(0, 1 / (maxX - minX));
    deltas.mulColumn(1, 1 / (maxY - minY));
    const cutOff = Math.sqrt(Math.pow(joinDistance[from] / (maxX - minX), 2) +
        Math.pow(joinDistance[to] / (maxY - minY), 2));
    let hClusters = (0, ml_hclust_1.agnes)(deltas.to2DArray(), { method: 'centroid' });
    const clusters = splitClusters([hClusters], cutOff);
    const zones = [];
    for (const cluster of clusters) {
        const signal = [];
        if (cluster.isLeaf)
            signal.push(signals[cluster.index]);
        for (const child of cluster.children) {
            for (const index of child.indices()) {
                signal.push(signals[index]);
            }
        }
        zones.push({
            id: (0, uuid_1.v4)(),
            ...fromTo(signal, { joinDistance, from, to }),
            signals: signal,
        });
    }
    return zones;
}
function fromTo(signals, options) {
    const { joinDistance, from, to } = options;
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    for (const signal of signals) {
        if (signal.x.delta < minX)
            minX = signal.x.delta;
        if (signal.x.delta > maxX)
            maxX = signal.x.delta;
        if (signal.y.delta < minY)
            minY = signal.y.delta;
        if (signal.y.delta > maxY)
            maxY = signal.y.delta;
    }
    return {
        x: { from: minX - joinDistance[from], to: maxX + joinDistance[from] },
        y: { from: minY - joinDistance[to], to: maxY + joinDistance[to] },
    };
}
function splitClusters(clusters, maxDistance) {
    let originalLength = clusters.length;
    for (let i = 0; i < clusters.length; i++) {
        const cluster = clusters[i];
        if (cluster.height > maxDistance) {
            clusters.push(...cluster.children);
            clusters.splice(i--, 1);
        }
    }
    return clusters.length < originalLength
        ? splitClusters(clusters, maxDistance)
        : clusters;
}

},{"../../peaks/util/setIDs":470,"./getNuclei":480,"./getPredictions":481,"@lukeed/uuid":1,"ml-hclust":178,"ml-matrix":186,"openchemlib-utils":525}],483:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryByHose = void 0;
function queryByHose(diaIDs, db, options) {
    const { maxSphereSize } = options;
    const toReturn = [];
    for (const element of diaIDs) {
        let res;
        let level = null;
        for (let k = maxSphereSize; !res && k >= 0; k--) {
            if (db[k]) {
                res = db[k][element.hose[k]];
                level = k;
            }
        }
        for (const atomNumber of element.atoms) {
            let atom = {
                diaIDs: [element.oclID],
                delta: res ? res[0] : null,
                atoms: [atomNumber],
                nbAtoms: 1,
                level,
                statistic: res && res.length > 1
                    ? {
                        mean: res[1],
                        sd: res[2],
                        min: res[3],
                        max: res[4],
                        nb: res[5],
                    }
                    : undefined,
            };
            toReturn.push(atom);
        }
    }
    return toReturn;
}
exports.queryByHose = queryByHose;

},{}],484:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markSolventPeaks = void 0;
const uuid_1 = require("@lukeed/uuid");
const checkIDs_1 = require("../assignment/utils/getAssignment/checkIDs");
const peaksToRanges_1 = require("../peaks/peaksToRanges");
const solventSuppression_1 = require("../peaks/solventSuppression");
const clone_1 = require("../utilities/clone");
function markSolventPeaks(input, solventSignals, options = {}) {
    const { frequency = 400 } = options;
    const ranges = (0, checkIDs_1.addIDs)((0, clone_1.cloneArray)(input));
    let peakList = [];
    for (const range of ranges) {
        const rangeID = range.id;
        for (const signal of range.signals || []) {
            const signalID = signal.id;
            for (let peak of signal.peaks || []) {
                peakList.push({
                    ...peak,
                    rangeID,
                    signalID,
                });
            }
        }
    }
    const peaks = (0, solventSuppression_1.solventSuppression)(peakList, solventSignals, {
        markSolventPeaks: true,
    });
    const signalsWithSolvent = getSignalIDsWithSolvent(peaks);
    for (let range of ranges) {
        if (!range.signals)
            continue;
        for (let signal of range.signals) {
            if (!signalsWithSolvent.includes(signal.id))
                continue;
            const signalPeaks = [];
            const solventSignalPeaks = [];
            for (let peak of peaks) {
                if (peak.signalID === signal.id) {
                    const { signalID, rangeID, ...newPeak } = peak;
                    if (peak.kind === 'solvent') {
                        solventSignalPeaks.push(newPeak);
                    }
                    else {
                        signalPeaks.push(newPeak);
                    }
                }
            }
            const newSignals = signalPeaks.length > 0
                ? (0, peaksToRanges_1.detectSignals)({ x: [], y: [] }, signalPeaks, {
                    integralType: 'peak',
                    frequency,
                })
                : [];
            solventSignalPeaks.sort((a, b) => a.x - b.x);
            const lowPPMValue = solventSignalPeaks[0].x;
            const highPPMValue = solventSignalPeaks[solventSignalPeaks.length - 1].x;
            const newSolventSignals = (0, peaksToRanges_1.detectSignals)({ x: [], y: [] }, solventSignalPeaks, {
                integralType: 'peak',
                frequencyCluster: (highPPMValue - lowPPMValue) * frequency,
                frequency,
            });
            range.signals = [
                ...adaptSignals(newSignals),
                ...adaptSignals(newSolventSignals),
                ...range.signals.filter((currSignal) => currSignal.id !== signal.id),
            ];
        }
    }
    return ranges;
}
exports.markSolventPeaks = markSolventPeaks;
function getSignalIDsWithSolvent(solventPeaks) {
    const uniqueSignalID = new Set();
    for (let peak of solventPeaks) {
        if (peak.kind !== 'solvent')
            continue;
        uniqueSignalID.add(peak.signalID);
    }
    return Array.from(uniqueSignalID);
}
function adaptSignals(signals) {
    const newSignals = [];
    for (let signal of signals) {
        const signalResult = {
            id: (0, uuid_1.v4)(),
            delta: signal.delta,
            kind: signal.kind || 'signal',
            multiplicity: signal.multiplicity,
            integration: signal.integralData.value,
        };
        signalResult.peaks = signal.peaks.map((peak) => {
            const newResult = {
                y: peak.intensity,
                ...peak,
            };
            delete newResult.intensity;
            return newResult;
        });
        signalResult.js = signal.nmrJs || [];
        newSignals.push(signalResult);
    }
    return newSignals;
}

},{"../assignment/utils/getAssignment/checkIDs":439,"../peaks/peaksToRanges":460,"../peaks/solventSuppression":462,"../utilities/clone":509,"@lukeed/uuid":1}],485:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangesToACS = void 0;
const signalJoinCouplings_1 = require("../signal/signalJoinCouplings");
const signalMultiplicityPattern_1 = require("../signal/signalMultiplicityPattern");
const globalOptions = {
    h: {
        nucleus: '1H',
        nbDecimalDelta: 2,
        nbDecimalJ: 1,
        observedFrequency: 400,
    },
    c: {
        nucleus: '13C',
        nbDecimalDelta: 1,
        nbDecimalJ: 1,
        observedFrequency: 100,
    },
    f: {
        nucleus: '19F',
        nbDecimalDelta: 2,
        nbDecimalJ: 1,
        observedFrequency: 400,
    },
};
function rangesToACS(ranges, options = {}) {
    if (!options.nucleus)
        options.nucleus = '1H';
    const nucleus = options.nucleus.toLowerCase().replace(/[0-9]/g, '');
    const defaultOptions = globalOptions[nucleus];
    options = {
        ...defaultOptions,
        ascending: false,
        format: 'IMJA',
        ...options,
    };
    ranges = JSON.parse(JSON.stringify(ranges));
    if (options.ascending === true) {
        ranges.sort((a, b) => {
            const fromA = Math.min(a.from, a.to);
            const fromB = Math.min(b.from, b.to);
            return fromA - fromB;
        });
    }
    let acsString = formatAcs(ranges, options);
    if (acsString.length > 0)
        acsString += '.';
    return acsString;
}
exports.rangesToACS = rangesToACS;
function formatAcs(ranges, options) {
    let acs = spectroInformation(options);
    if (acs.length === 0)
        acs = 'δ ';
    const acsRanges = [];
    for (const range of ranges) {
        if (uselessKind(range.kind, options.filter))
            continue;
        pushDelta(range, acsRanges, options);
    }
    if (acsRanges.length > 0) {
        return acs + acsRanges.join(', ');
    }
    else {
        return '';
    }
}
function spectroInformation(options) {
    const parenthesis = [];
    let strings = `${formatNucleus(options.nucleus)} NMR`;
    if (options.solvent) {
        parenthesis.push(formatMF(options.solvent));
    }
    if (options.observedFrequency) {
        parenthesis.push(`${(options.observedFrequency * 1).toFixed(0)} MHz`);
    }
    if (parenthesis.length > 0) {
        strings += ` (${parenthesis.join(', ')}): δ `;
    }
    else {
        strings += ': δ ';
    }
    return strings;
}
function pushDelta(range, acsRanges, options) {
    let strings = '';
    let parenthesis = [];
    const fromTo = [range.from, range.to];
    if (range.signals) {
        range.signals = range.signals.filter((signal) => !uselessKind(signal.kind, options.filter));
    }
    if (range.signals && range.signals.length > 0) {
        let signals = range.signals;
        if (signals.length > 1) {
            if (options.ascending === true) {
                signals.sort((a, b) => {
                    return a.delta - b.delta;
                });
            }
            strings += `${Math.min(...fromTo).toFixed(options.nbDecimalDelta)}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;
            strings += ` (${getIntegral(range, options)}`;
            if (signals.some((signal) => signal.multiplicity || (signal.js && signal.js.length > 0))) {
                for (let signal of signals) {
                    parenthesis = [];
                    if (signal.delta !== undefined) {
                        strings = appendSeparator(strings);
                        strings += signal.delta.toFixed(options.nbDecimalDelta);
                    }
                    const range = {
                        from: Number.MIN_SAFE_INTEGER,
                        to: Number.MAX_SAFE_INTEGER,
                    };
                    switchFormat(range, signal, parenthesis, options);
                    if (parenthesis.length > 0)
                        strings += ` (${parenthesis.join(', ')})`;
                }
            }
            strings += ')';
        }
        else {
            parenthesis = [];
            if (signals[0].delta !== undefined) {
                strings += signals[0].delta.toFixed(options.nbDecimalDelta);
                switchFormat(range, signals[0], parenthesis, options);
                if (parenthesis.length > 0)
                    strings += ` (${parenthesis.join(', ')})`;
            }
            else {
                strings += `${Math.min(...fromTo).toFixed(options.nbDecimalDelta)}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;
                switchFormat(range, signals[0], parenthesis, options);
                if (parenthesis.length > 0)
                    strings += ` (${parenthesis})`;
            }
        }
    }
    else {
        strings += `${Math.min(...fromTo).toFixed(options.nbDecimalDelta)}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;
        const signal = {};
        switchFormat(range, signal, parenthesis, options);
        if (parenthesis.length > 0)
            strings += ` (${parenthesis.join(', ')})`;
    }
    acsRanges.push(strings);
}
function getIntegral(range, options) {
    let integration = '';
    if (range.pubIntegral) {
        integration = String(range.pubIntegral);
    }
    else if (range.integration) {
        const { nucleus } = options;
        integration = range.integration.toFixed(0) + nucleus[nucleus.length - 1];
    }
    return integration;
}
function pushIntegral(range, parenthesis, options) {
    let integration = getIntegral(range, options);
    if (integration.length > 0)
        parenthesis.push(integration);
}
function pushmultiplicityFromSignal(signal, parenthesis) {
    let multiplicity = signal.multiplicity;
    if (!multiplicity) {
        let joinedCouplings = (0, signalJoinCouplings_1.signalJoinCouplings)(signal, {
            tolerance: 0.05,
            ignoreDiaIDs: true,
        });
        multiplicity = (0, signalMultiplicityPattern_1.signalMultiplicityPattern)(joinedCouplings);
    }
    if (multiplicity.length > 0)
        parenthesis.push(multiplicity);
}
function switchFormat(range, signal, parenthesis, options) {
    for (const char of options.format) {
        switch (char.toUpperCase()) {
            case 'I':
                pushIntegral(range, parenthesis, options);
                break;
            case 'M':
                pushmultiplicityFromSignal(signal, parenthesis);
                break;
            case 'A':
                pushAssignment(signal, parenthesis);
                break;
            case 'J':
                pushCoupling(signal, parenthesis, options);
                break;
            default:
                throw new Error(`Unknow format letter: ${char}`);
        }
    }
}
function formatMF(mf) {
    return mf.replace(/(?<num>[0-9]+)/g, '<sub>$<num></sub>');
}
function formatNucleus(nucleus) {
    return nucleus.replace(/(?<num>[0-9]+)/g, '<sup>$<num></sup>');
}
function appendSeparator(strings) {
    if (strings.length > 0 && !/ $/.exec(strings) && !/\($/.exec(strings)) {
        strings += ', ';
    }
    return strings;
}
function formatAssignment(assignment) {
    assignment = assignment.replace(/(?<num>[0-9]+)/g, '<sub>$<num></sub>');
    assignment = assignment.replace(/"(?<i>[^"]*)"/g, '<i>$<i></i>');
    return assignment;
}
function pushCoupling(signal, parenthesis, options) {
    if (Array.isArray(signal.js) && signal.js.length > 0) {
        signal.js.sort((a, b) => {
            return b.coupling - a.coupling;
        });
        let values = [];
        for (let j of signal.js) {
            if (j.coupling !== undefined) {
                values.push(j.coupling.toFixed(options.nbDecimalJ));
            }
        }
        if (values.length > 0) {
            parenthesis.push(`<i>J</i> = ${values.join(', ')} Hz`);
        }
    }
}
function pushAssignment(signal, parenthesis) {
    if (signal.assignment) {
        parenthesis.push(formatAssignment(signal.assignment));
    }
}
function uselessKind(kind = '', filter = true) {
    kind = kind.toLowerCase();
    if (filter && (kind === 'impurity' || kind === 'solvent'))
        return true;
    return false;
}

},{"../signal/signalJoinCouplings":488,"../signal/signalMultiplicityPattern":489}],486:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangesToXY = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
const spectrum_generator_1 = require("spectrum-generator");
const hackSignalsToXY_1 = require("../signals/hackSignalsToXY");
function checkForSignals(ranges) {
    for (let range of ranges) {
        if (!range.signals)
            throw new Error('range has not signals');
    }
}
const defaultFromTo = (nucleus = '') => {
    switch (nucleus.toUpperCase()) {
        case '13C':
            return { from: -5, to: 206 };
        default:
            return { from: -0.5, to: 10.5 };
    }
};
function rangesToXY(ranges, options = {}) {
    checkForSignals(ranges);
    let { frequency = 400, lineWidth = 1, nbPoints = 16 * 1024, shape = { kind: 'gaussian' }, } = options;
    const addSpectrum = (a, b) => {
        for (let i = 0; i < nbPoints; i++) {
            a[i] += b[i];
        }
    };
    const { from, to } = getFromTo(ranges, options);
    const spectrumOptions = {
        to,
        from,
        nbPoints,
        shape,
        lineWidth,
        frequency,
    };
    let spectrum = new Float64Array(nbPoints);
    for (const range of ranges) {
        const { integration, signals = [] } = range;
        const { multiplicity: rangeMulplicity = '' } = range;
        if (rangeMulplicity === 'm' && signals.length < 1) {
            const { from, to } = range;
            signals.push({
                delta: (from + to) / 2,
                multiplicity: 'm',
            });
        }
        let rangeSpectrum = new Float64Array(nbPoints);
        for (const signal of signals) {
            const { multiplicity } = signal;
            let signalSpectrum = multiplicity === 'm' || multiplicity === 'b' || multiplicity === 'br s'
                ? broadPeakOrMultipletSpectrum([signal], spectrumOptions).y
                : (0, hackSignalsToXY_1.hackSignalsToXY)([signal], spectrumOptions).y;
            normalizeSpectrum(signalSpectrum, [signal]);
            addSpectrum(rangeSpectrum, signalSpectrum);
        }
        if (range.integration) {
            normalizeSpectrum(rangeSpectrum, signals, { integration });
        }
        addSpectrum(spectrum, rangeSpectrum);
    }
    return {
        x: (0, ml_spectra_processing_1.xSequentialFill)({ from, to, size: nbPoints }),
        y: spectrum,
    };
}
exports.rangesToXY = rangesToXY;
function broadPeakOrMultipletSpectrum(signals, options = {}) {
    const { lineWidth, frequency } = options;
    const spectrumGenerator = new spectrum_generator_1.SpectrumGenerator(options);
    const broadWidth = (lineWidth * 3) / frequency;
    for (let signal of signals) {
        const { multiplicity, delta, integration = 1 } = signal;
        if (multiplicity === 'b' || multiplicity === 'br s') {
            spectrumGenerator.addPeak({
                x: delta,
                y: integration,
                width: broadWidth,
            });
        }
        else {
            const peaks = peaksOfMultiplet(delta, {
                lineWidth,
                frequency,
            });
            spectrumGenerator.addPeaks(peaks);
        }
    }
    return spectrumGenerator.getSpectrum();
}
function peaksOfMultiplet(delta, options) {
    const { frequency, lineWidth, intensities = [1, 2, 5, 4, 5, 7, 5, 4, 5, 2, 1], } = options;
    const lineWidthPpm = lineWidth / frequency;
    const spaceBetweenPeaks = lineWidthPpm * 1.5;
    const peaks = [];
    const firstPeakPosition = delta - (spaceBetweenPeaks * intensities.length) / 2;
    for (let i = 0; i < intensities.length; i++) {
        peaks.push({
            x: firstPeakPosition + spaceBetweenPeaks * i,
            y: intensities[i],
            width: lineWidthPpm,
        });
    }
    return peaks;
}
function normalizeSpectrum(spectrum, signals, options = {}) {
    const { integration = signals.reduce((acc, signal) => {
        const { integration = 1 } = signal;
        return acc + integration;
    }, 0), } = options;
    const sum = spectrum.reduce((acc, element) => acc + element, 0);
    if (sum !== 0) {
        const norma = (integration / sum) * 1e6;
        for (let i = 0; i < spectrum.length; i++) {
            spectrum[i] *= norma;
        }
    }
}
function getFromTo(ranges, options) {
    const { from: defaultFrom, to: defaultTo } = defaultFromTo(options.nucleus);
    let rangesFrom = Number.MAX_SAFE_INTEGER;
    let rangesTo = Number.MIN_SAFE_INTEGER;
    for (const range of ranges) {
        for (const signal of range.signals || []) {
            if (rangesFrom > signal.delta)
                rangesFrom = signal.delta;
            if (rangesTo < signal.delta)
                rangesTo = signal.delta;
        }
    }
    const { from = Math.min(rangesFrom - 0.5, defaultFrom), to = Math.max(rangesTo + 0.5, defaultTo), } = options;
    return { from, to };
}

},{"../signals/hackSignalsToXY":491,"ml-spectra-processing":208,"spectrum-generator":530}],487:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinRanges = void 0;
const uuid_1 = require("@lukeed/uuid");
function joinRanges(ranges) {
    ranges.sort((a, b) => a.from - b.from);
    for (let i = 0; i < ranges.length - 1; i++) {
        const currentRange = ranges[i];
        const nextRange = ranges[i + 1];
        if (currentRange.to > nextRange.from) {
            currentRange.id = (0, uuid_1.v4)();
            currentRange.to = Math.max(nextRange.to, currentRange.to);
            if (currentRange.signals && nextRange.signals) {
                currentRange.signals = currentRange.signals.concat(nextRange.signals);
            }
            if (currentRange.integration !== undefined) {
                currentRange.integration += nextRange.integration || 0;
            }
            ranges.splice(i + 1, 1);
            i--;
        }
    }
    return ranges;
}
exports.joinRanges = joinRanges;

},{"@lukeed/uuid":1}],488:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalJoinCouplings = void 0;
const ml_array_sum_1 = __importDefault(require("ml-array-sum"));
const joinPatterns_1 = require("../utilities/joinPatterns");
const localeCompare = (a, b) => a.localeCompare(b);
const localeCompareJcouplingKeys = (a, b) => {
    const aa = `${a.diaIDs.sort(localeCompare).join(' ')}`;
    const bb = `${b.diaIDs.sort(localeCompare).join(' ')}`;
    return localeCompare(aa, bb);
};
const areThanClose = (a, b, tolerance) => Math.abs(a.coupling - b.coupling) < tolerance;
const takeCareDiaIDs = (a, b, tolerance) => localeCompareJcouplingKeys(a, b) === 0 && areThanClose(a, b, tolerance);
/**
 * Join couplings smaller than a define tolerance.
 * The resulting coupling should be an average of the existing one.
 * If pathLength is specified and is not always the same this property will be removed.
 */
function signalJoinCouplings(signal, options = {}) {
    const { tolerance = 0.05, ignoreDiaIDs = false } = options;
    if (!signal.js || signal.js.length < 2)
        return signal;
    if (ignoreDiaIDs) {
        checkJs(signal);
        return groupJCouplings(signal, areThanClose, tolerance);
    }
    else {
        checkJsAndDiaID(signal);
        return groupJCouplings(signal, takeCareDiaIDs, tolerance);
    }
}
exports.signalJoinCouplings = signalJoinCouplings;
function groupJCouplings(signal, comparator, tolerance) {
    signal.js.sort((a, b) => b.coupling - a.coupling);
    let currentGroup = [signal.js[0]];
    let groups = [currentGroup];
    for (let i = 1; i < signal.js.length; i++) {
        let currentJ = signal.js[i];
        if (comparator(currentGroup[currentGroup.length - 1], currentJ, tolerance)) {
            currentGroup.push(currentJ);
        }
        else {
            currentGroup = [currentJ];
            groups.push(currentGroup);
        }
    }
    signal.js = [];
    for (let group of groups) {
        let coupling = (0, ml_array_sum_1.default)(group.map((group) => group.coupling)) / group.length;
        let atoms = distinctValues(group
            .filter((group) => group.atoms)
            .map((group) => group.atoms)
            .flat());
        let assignment = distinctValues(group
            .filter((group) => group.assignment)
            .map((group) => group.assignment)
            .flat()).join(' ');
        let diaIDs = distinctValues(group
            .filter((group) => group.diaIDs)
            .map((group) => group.diaIDs)
            .flat());
        let distances = distinctValues(group.map((group) => group.pathLength));
        let multiplicity = (0, joinPatterns_1.joinPatterns)(group
            .filter((group) => group.multiplicity)
            .map((group) => group.multiplicity));
        let newJ = {
            coupling,
            multiplicity,
        };
        if (diaIDs.length === 1)
            newJ.diaIDs = diaIDs;
        if (distances.length === 1 && distances[0])
            newJ.pathLength = distances[0];
        if (assignment.length > 0)
            newJ.assignment = assignment;
        if (atoms.length > 0)
            newJ.atoms = atoms;
        signal.js.push(newJ);
    }
    return signal;
}
function distinctValues(array) {
    const onlyDifferents = new Set();
    for (const element of array) {
        onlyDifferents.add(element);
    }
    return Array.from(onlyDifferents);
}
function checkJsAndDiaID(signal) {
    if (!signal.js)
        throw new Error('there is not js');
    for (const jcoupling of signal.js) {
        if (!jcoupling.diaIDs)
            throw new Error('there is not diaIDs');
    }
}
function checkJs(signal) {
    if (!signal.js)
        throw new Error('there is not js');
}

},{"../utilities/joinPatterns":512,"ml-array-sum":154}],489:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalMultiplicityPattern = void 0;
/**
 * Return
 * @param {*} signal
 */
function signalMultiplicityPattern(signal) {
    let js = signal.js;
    let pattern = '';
    if (js && js.length > 0) {
        for (let coupling of js) {
            pattern += coupling.multiplicity;
        }
    }
    else if (signal.delta) {
        pattern = '';
    }
    else {
        pattern = 'm';
    }
    return pattern;
}
exports.signalMultiplicityPattern = signalMultiplicityPattern;

},{}],490:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDummySignals = void 0;
const couplingPatterns_1 = require("../constants/couplingPatterns");
function addDummySignals(signals) {
    let newSignals = JSON.parse(JSON.stringify(signals));
    let nextAtomToAssign = signals.reduce((nextAtomToAssign, signal) => {
        const { atoms = [] } = signal;
        return Math.max(...atoms) > nextAtomToAssign
            ? Math.max(...atoms)
            : nextAtomToAssign;
    }, 0) + 1;
    signals.forEach((signal, s) => {
        const { js: jCouplings = [], atoms: signalAssignment = [nextAtomToAssign++], } = signal;
        let { newCouplings, tempSignals } = checkCouplings(jCouplings, newSignals, signalAssignment, nextAtomToAssign + signals.length);
        if (tempSignals.length > 0)
            newSignals.push(...tempSignals);
        newSignals[s].js = newCouplings;
        newSignals[s].atoms = signalAssignment;
    });
    return newSignals.sort((a, b) => a.delta - b.delta);
}
exports.addDummySignals = addDummySignals;
function checkCouplings(jCouplings, signals, signalAssignment, nextAtomToAssign) {
    let tempSignals = [];
    const newCouplings = jCouplings.reduce((newCouplings, jCoupling) => {
        const { atoms = [], multiplicity, coupling } = jCoupling;
        if (atoms.length === 0) {
            if (coupling && multiplicity) {
                let tempCouplings = [];
                const nbLinks = couplingPatterns_1.couplingPatterns.indexOf(multiplicity);
                for (let i = 0; i < nbLinks; i++) {
                    nextAtomToAssign++;
                    tempCouplings.push({
                        coupling,
                        atoms: [nextAtomToAssign],
                    });
                    tempSignals.push(formatSignal(coupling, [nextAtomToAssign], signalAssignment));
                }
            }
            else {
                newCouplings.push(jCoupling);
            }
        }
        return newCouplings;
    }, []);
    return { newCouplings, tempSignals };
}
function formatSignal(coupling, newSignalAssignment, signalAssignment) {
    return {
        delta: 100000,
        atoms: newSignalAssignment,
        js: [
            {
                coupling,
                atoms: signalAssignment,
            },
        ],
    };
}

},{"../constants/couplingPatterns":451}],491:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hackSignalsToXY = void 0;
const addDummySignals_1 = require("./addDummySignals");
const signalsToXY_1 = require("./signalsToXY");
/**
 * Create the xy object from an array of 1D signals.
 * @param signals Array of signals with assigned or unassigned couplings.
 */
function hackSignalsToXY(signals, options = {}) {
    let newSignals = (0, addDummySignals_1.addDummySignals)(signals);
    return (0, signalsToXY_1.signalsToXY)(newSignals, options);
}
exports.hackSignalsToXY = hackSignalsToXY;

},{"./addDummySignals":490,"./signalsToXY":502}],492:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultParameters = void 0;
exports.defaultParameters = {
    delta: {
        init: (data) => data.signal.delta,
        min: (data) => data.signal.delta - data.shape.fwhm * 2,
        max: (data) => data.signal.delta + data.shape.fwhm * 2,
        gradientDifference: () => 2e-3,
    },
    intensity: {
        init: (data) => data.signal.intensity || 1,
        min: () => 0,
        max: () => 1.5,
        gradientDifference: () => 1e-3,
    },
    fwhm: {
        init: (data) => data.shape.fwhm,
        min: (data) => data.shape.fwhm * 0.25,
        max: (data) => data.shape.fwhm * 4,
        gradientDifference: (data) => data.shape.fwhm * 2e-3,
    },
    mu: {
        init: (data) => data.shape.mu || 0.5,
        min: () => 0,
        max: () => 1,
        gradientDifference: () => 0.01,
    },
    coupling: {
        init: (data) => data.jCoupling.coupling,
        min: (data) => data.jCoupling.coupling * 0.8,
        max: (data) => data.jCoupling.coupling * 1.2,
        gradientDifference: () => 0.01,
    },
};

},{}],493:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.directOptimization = void 0;
const ml_direct_1 = __importDefault(require("ml-direct"));
function directOptimization(data, sumOfShapes, options) {
    const { minValues, maxValues, directOptions = {} } = options;
    const objectiveFunction = getObjectiveFunction(data, sumOfShapes);
    const result = (0, ml_direct_1.default)(objectiveFunction, minValues, maxValues, directOptions);
    const { optima } = result;
    return {
        error: result.minFunctionValue,
        iterations: result.iterations,
        parameterValues: optima[0],
    };
}
exports.directOptimization = directOptimization;
function getObjectiveFunction(data, sumOfShapes) {
    const { x, y } = data;
    const nbPoints = x.length;
    return (parameters) => {
        const fct = sumOfShapes(parameters);
        let error = 0;
        for (let i = 0; i < nbPoints; i++) {
            error += Math.pow(y[i] - fct(x[i]), 2);
        }
        return error;
    };
}

},{"ml-direct":155}],494:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInternalSignals = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const defaultParameters_1 = require("./defaultParameters");
const signalsToPointXY_1 = require("./signalsToPointXY");
const properties = ['init', 'min', 'max', 'gradientDifference'];
function getInternalSignals(data, signals, minMaxY, options) {
    var _a, _b;
    let index = 0;
    let internalSignals = [];
    const { shape: shapeAsOption = { kind: 'gaussian' }, baseline: shiftValue = minMaxY.min, lineWidth = 1, frequency, } = options;
    const normalizedSignals = normalizeSignals({
        signals,
        data,
        shiftValue,
        frequency,
        range: minMaxY.range,
    });
    for (const signal of normalizedSignals) {
        const { shape = { ...shapeAsOption } } = signal;
        if (!shape.fwhm) {
            shape.fwhm = lineWidth;
        }
        shape.fwhm /= frequency;
        const shapeFct = (0, ml_peak_shape_generator_1.getShape1D)(shape);
        const parameters = [
            'delta',
            'intensity',
            ...shapeFct.getParameters(),
        ];
        const propertiesValues = {
            min: [],
            max: [],
            init: [],
            gradientDifference: [],
        };
        for (const parameter of parameters) {
            for (const property of properties) {
                propertiesValues[property].push(getPropertyValue({
                    signal,
                    frequency,
                    parameter,
                    property,
                    minMaxY,
                    shapeFct,
                }));
            }
        }
        for (const jCoupling of signal.js || []) {
            for (const property of properties) {
                const parameter = 'coupling';
                let generalParameterValue = (_b = (_a = options === null || options === void 0 ? void 0 : options.parameters) === null || _a === void 0 ? void 0 : _a[parameter]) === null || _b === void 0 ? void 0 : _b[property];
                if (generalParameterValue) {
                    if (typeof generalParameterValue === 'number') {
                        propertiesValues[property].push(getNormalizedValue(generalParameterValue, parameter, property, minMaxY, frequency, options.baseline));
                    }
                    else {
                        let value = generalParameterValue({ jCoupling });
                        propertiesValues[property].push(getNormalizedValue(value, parameter, property, minMaxY, frequency, options.baseline));
                    }
                }
                if (!defaultParameters_1.defaultParameters[parameter]) {
                    throw new Error(`No default parameter for ${parameter}`);
                }
                const defaultParameterValues = defaultParameters_1.defaultParameters[parameter][property];
                propertiesValues[property].push(defaultParameterValues({ jCoupling }));
            }
        }
        const fromIndex = index;
        const toIndex = fromIndex + parameters.length - 1;
        const fromIndexCoupling = toIndex + 1;
        const toIndexCoupling = fromIndexCoupling + signal.js.length - 1;
        index += toIndexCoupling - fromIndex + 1;
        internalSignals.push({
            shape: shape,
            shapeFct,
            signal,
            parameters,
            propertiesValues,
            fromIndex,
            toIndex,
            fromIndexCoupling,
            toIndexCoupling,
        });
    }
    return internalSignals;
}
exports.getInternalSignals = getInternalSignals;
function normalizeSignals(options) {
    const { signals, data, frequency, shiftValue, range } = options;
    const getMaxIntensity = (signal) => {
        const peaks = (0, signalsToPointXY_1.signalsToPointXY)([signal], { frequency, maxClusterSize: 1 });
        const biggestPeak = peaks.reduce((biggest, peak) => (peak.y > biggest.y ? peak : biggest), peaks[0]);
        const { y: maxIntensity } = (0, ml_spectra_processing_1.xyFindClosestPoint)(data, biggestPeak.x);
        return maxIntensity;
    };
    return signals.map((signal) => {
        const { intensity = getMaxIntensity(signal) } = signal;
        return {
            ...signal,
            js: signal.js || [],
            intensity: (intensity - shiftValue) / range,
        };
    });
}
function getPropertyValue(options) {
    var _a, _b, _c, _d;
    const { signal, frequency, parameter, property, minMaxY, shapeFct } = options;
    // check if the property is specified in the signal
    let propertyValue = (_b = (_a = signal === null || signal === void 0 ? void 0 : signal.parameters) === null || _a === void 0 ? void 0 : _a[parameter]) === null || _b === void 0 ? void 0 : _b[property];
    if (propertyValue) {
        return getNormalizedValue(propertyValue, parameter, property, minMaxY, frequency, options.baseline);
    }
    // check if there are some global option, it could be a number or a callback
    let generalParameterValue = (_d = (_c = options === null || options === void 0 ? void 0 : options.parameters) === null || _c === void 0 ? void 0 : _c[parameter]) === null || _d === void 0 ? void 0 : _d[property];
    if (generalParameterValue) {
        if (typeof generalParameterValue === 'number') {
            return getNormalizedValue(generalParameterValue, parameter, property, minMaxY, frequency, options.baseline);
        }
        else {
            let value = generalParameterValue(signal);
            return getNormalizedValue(value, parameter, property, minMaxY, frequency, options.baseline);
        }
    }
    // we just need to take the default parameters
    if (!defaultParameters_1.defaultParameters[parameter]) {
        throw new Error(`No default parameter for ${parameter}`);
    }
    const defaultParameterValues = defaultParameters_1.defaultParameters[parameter][property];
    return defaultParameterValues({ signal, shape: shapeFct });
}
function getNormalizedValue(value, parameter, property, minMaxY, frequency, baseline) {
    if (parameter === 'intensity') {
        if (property === 'gradientDifference') {
            return value;
        }
        else {
            return baseline !== undefined
                ? (value - baseline) / minMaxY.range
                : (value - minMaxY.min) / minMaxY.range;
        }
    }
    else if (parameter === 'fwhm') {
        return value / frequency;
    }
    return value;
}

},{"./defaultParameters":492,"./signalsToPointXY":496,"ml-peak-shape-generator":187,"ml-spectra-processing":208}],495:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSumOfShapes = void 0;
const signalsToPointXY_1 = require("./signalsToPointXY");
const defaultSimulationOptions = {
    maxClusterSize: 1,
};
function getSumOfShapes(internalSignals, options) {
    const simulationOptions = { ...defaultSimulationOptions, ...options };
    return function sumOfShapes(parameters) {
        const peaks = [];
        for (const internalSignal of internalSignals) {
            const delta = parameters[internalSignal.fromIndex];
            const intensity = parameters[internalSignal.fromIndex + 1];
            for (let i = 2; i < internalSignal.parameters.length; i++) {
                //@ts-expect-error Not simply to solve the issue
                internalSignal.shapeFct[internalSignal.parameters[i]] =
                    parameters[internalSignal.fromIndex + i];
            }
            const couplings = internalSignal.signal.js;
            for (let i = 0; i < couplings.length; i++) {
                couplings[i].coupling =
                    parameters[internalSignal.fromIndexCoupling + i];
            }
            const currentPeaks = (0, signalsToPointXY_1.signalsToPointXY)([
                {
                    delta,
                    js: couplings,
                },
            ], simulationOptions);
            peaks.push(...currentPeaks.map((peak) => {
                return { intensity, shape: internalSignal.shapeFct, ...peak };
            }));
        }
        return (currentX) => {
            let totalY = 0;
            for (let peak of peaks) {
                const { x, y, intensity, shape } = peak;
                totalY += y * intensity * shape.fct(currentX - x);
            }
            return totalY;
        };
    };
}
exports.getSumOfShapes = getSumOfShapes;

},{"./signalsToPointXY":496}],496:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsToPointXY = void 0;
const addDummySignals_1 = require("../addDummySignals");
const signalsToSpinSystem_1 = require("../simulation/signalsToSpinSystem");
const simulateXYPeaks_1 = require("../simulation/simulateXYPeaks");
const splitSpinSystem_1 = require("../simulation/splitSpinSystem");
function signalsToPointXY(signals, options) {
    const { frequency, maxClusterSize = 1 } = options;
    const completeSignalSet = (0, addDummySignals_1.addDummySignals)(signals);
    const spinSystem = (0, signalsToSpinSystem_1.signalsToSpinSystem)(completeSignalSet);
    spinSystem.clusters = (0, splitSpinSystem_1.splitSpinSystem)(spinSystem, {
        frequency,
        maxClusterSize,
    });
    const pointsXY = (0, simulateXYPeaks_1.simulateXYPeaks)(spinSystem, options).filter((point) => point.x < 1000);
    const maxIntensity = pointsXY.reduce((max, peak) => (peak.y > max ? peak.y : max), Number.MIN_SAFE_INTEGER);
    for (const point of pointsXY) {
        point.y /= maxIntensity;
    }
    return pointsXY;
}
exports.signalsToPointXY = signalsToPointXY;

},{"../addDummySignals":490,"../simulation/signalsToSpinSystem":504,"../simulation/simulateXYPeaks":506,"../simulation/splitSpinSystem":507}],497:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeSignals = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_levenberg_marquardt_1 = require("ml-levenberg-marquardt");
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const directOptimization_1 = require("./optimization/directOptimization");
const getInternalSignals_1 = require("./optimization/getInternalSignals");
const getSumOfShapes_1 = require("./optimization/getSumOfShapes");
const signalsToPointXY_1 = require("./optimization/signalsToPointXY");
const defaultLMOptimizationOptions = {
    damping: 1.5,
    maxIterations: 100,
    errorTolerance: 1e-8,
};
const defaultDirectOptimizationOptions = {
    iterations: 25,
};
function optimizeSignals(data, signals, options) {
    const { optimization = {}, simulation: simulationOptions, ...restOptions } = options;
    let temp = (0, ml_spectra_processing_1.xMinMaxValues)(data.y);
    const minMaxY = { ...temp, range: temp.max - temp.min };
    const internalSignals = (0, getInternalSignals_1.getInternalSignals)(data, signals, minMaxY, {
        frequency: simulationOptions.frequency,
        ...restOptions,
    });
    const { baseline: shiftValue = minMaxY.min } = options;
    let normalizedY = new Float64Array(data.y.length);
    for (let i = 0; i < data.y.length; i++) {
        normalizedY[i] = (data.y[i] - shiftValue) / minMaxY.range;
    }
    const nbParams = internalSignals[internalSignals.length - 1].toIndexCoupling + 1;
    const minValues = new Float64Array(nbParams);
    const maxValues = new Float64Array(nbParams);
    const initialValues = new Float64Array(nbParams);
    const gradientDifferences = new Float64Array(nbParams);
    let index = 0;
    for (const internalSignal of internalSignals) {
        for (let i = 0; i < internalSignal.parameters.length; i++) {
            minValues[index] = internalSignal.propertiesValues.min[i];
            maxValues[index] = internalSignal.propertiesValues.max[i];
            initialValues[index] = internalSignal.propertiesValues.init[i];
            gradientDifferences[index++] =
                internalSignal.propertiesValues.gradientDifference[i];
        }
        for (let i = internalSignal.parameters.length; i < internalSignal.parameters.length + internalSignal.signal.js.length; i++) {
            minValues[index] = internalSignal.propertiesValues.min[i];
            maxValues[index] = internalSignal.propertiesValues.max[i];
            initialValues[index] = internalSignal.propertiesValues.init[i];
            gradientDifferences[index++] =
                internalSignal.propertiesValues.gradientDifference[i];
        }
    }
    const sumOfShapes = (0, getSumOfShapes_1.getSumOfShapes)(internalSignals, simulationOptions);
    const { kind, options: optimizationOptions } = optimization;
    const [algorithm, defaultOptimizationOptions] = kind === 'direct'
        ? [directOptimization_1.directOptimization, defaultDirectOptimizationOptions]
        : [ml_levenberg_marquardt_1.levenbergMarquardt, defaultLMOptimizationOptions];
    let fitted = algorithm({ x: data.x, y: normalizedY }, sumOfShapes, {
        minValues,
        maxValues,
        initialValues,
        gradientDifference: gradientDifferences,
        ...defaultOptimizationOptions,
        ...optimizationOptions,
    });
    const fittedValues = fitted.parameterValues;
    const newSignals = [];
    for (const internalSignal of internalSignals) {
        const { fromIndexCoupling } = internalSignal;
        const js = internalSignal.signal.js.map((jCoupling, i) => {
            jCoupling.coupling = fittedValues[fromIndexCoupling + i];
            return jCoupling;
        });
        const delta = fittedValues[internalSignal.fromIndex];
        const pointXYs = (0, signalsToPointXY_1.signalsToPointXY)([{ delta, js }], simulationOptions);
        const intensity = fittedValues[internalSignal.fromIndex + 1] * minMaxY.range + shiftValue;
        const newPeaks = [];
        for (const { x, y } of pointXYs) {
            const peak = {
                id: (0, uuid_1.v4)(),
                x,
                y: intensity * y,
                width: 0,
                shape: { ...internalSignal.shape },
            };
            for (let i = 2; i < internalSignal.parameters.length; i++) {
                //@ts-expect-error should be fixed once
                peak.shape[internalSignal.parameters[i]] =
                    fittedValues[internalSignal.fromIndex + i];
            }
            peak.shape.fwhm *= simulationOptions.frequency;
            peak.width = (0, ml_peak_shape_generator_1.getShape1D)(peak.shape).fwhmToWidth(peak.shape.fwhm);
            newPeaks.push(peak);
        }
        newSignals.push({
            delta,
            js,
            shape: { ...newPeaks[0].shape },
            intensity,
            peaks: newPeaks,
//	    optimization: fitted
        });
    }
    return newSignals;
}
exports.optimizeSignals = optimizeSignals;

},{"./optimization/directOptimization":493,"./optimization/getInternalSignals":494,"./optimization/getSumOfShapes":495,"./optimization/signalsToPointXY":496,"@lukeed/uuid":1,"ml-levenberg-marquardt":182,"ml-peak-shape-generator":187,"ml-spectra-processing":208}],498:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signals2DToZ = void 0;
const spectrum_generator_1 = require("spectrum-generator");
function signals2DToZ(signals, options = {}) {
    let { from = -1, to = 12, nbPoints = 512, width = 0.02, factor = 3, } = options;
    const peaks = signals.reduce((acc, { x, y }) => {
        acc.x.push(x.delta);
        acc.y.push(y.delta);
        acc.z.push(1e6);
        return acc;
    }, { x: [], y: [], z: [] });
    width = ensureXYNumber(width);
    return (0, spectrum_generator_1.generateSpectrum2D)(mergeClosePeaks(peaks), {
        generator: {
            from: ensureXYNumber(from),
            to: ensureXYNumber(to),
            nbPoints: ensureXYNumber(nbPoints),
        },
        peaks: {
            width,
            factor,
        },
    });
}
exports.signals2DToZ = signals2DToZ;
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function mergeClosePeaks(peaksIn) {
    let peaks = JSON.parse(JSON.stringify(peaksIn));
    for (let i = 0; i < peaks.x.length; i++) {
        for (let j = i + 1; j < peaks.x.length; j++) {
            if (peaks.x[i] === peaks.x[j] && peaks.y[i] === peaks.y[j]) {
                peaks.z[i] += peaks.z[j];
                peaks.x.splice(j, 1);
                peaks.y.splice(j, 1);
                peaks.z.splice(j, 1);
                j--;
            }
        }
    }
    return peaks;
}

},{"spectrum-generator":530}],499:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsJoin = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_array_mean_1 = __importDefault(require("ml-array-mean"));
const ml_array_sum_1 = __importDefault(require("ml-array-sum"));
const signalJoinCouplings_1 = require("../signal/signalJoinCouplings");
const localeCompare = (a, b) => a.localeCompare(b);
const localeCompareJcouplingKeys = (a, b) => {
    const aa = `${a.diaIDs.join(' ')}${a.pathLength}`;
    const bb = `${b.diaIDs.join(' ')}${b.pathLength}`;
    return localeCompare(aa, bb);
};
function checkForMandatory(signals) {
    for (const signal of signals) {
        if (!signal.js)
            throw new Error('there is not js');
        if (!signal.diaIDs)
            throw new Error('there is not diaIDs');
        for (const jcoupling of signal.js) {
            if (!jcoupling.diaIDs)
                throw new Error('there is not diaIDs');
            if (!jcoupling.pathLength)
                throw new Error('there is not pathLength');
        }
    }
}
/**
 * Join signals if all the same diaID
 */
function signalsJoin(signals, options = {}) {
    checkForMandatory(signals);
    const { joinCouplings = {} } = options;
    const { tolerance, ignoreDiaIDs } = joinCouplings;
    // we group them by diaIDs
    const copySignals = JSON.parse(JSON.stringify(signals));
    const groupedSignals = {};
    for (let signal of copySignals) {
        signal.js = signal.js.sort(localeCompareJcouplingKeys);
        const keyDiaIDs = signal.diaIDs.join(' ');
        let id = `${keyDiaIDs} ${signal.js
            .map((j) => `${j.diaIDs.join(' ')} ${j.pathLength}`)
            .sort(localeCompare)
            .join(' ')}`;
        if (!groupedSignals[id]) {
            groupedSignals[id] = [];
        }
        groupedSignals[id].push(signal);
    }
    // for each group we need to combine assignments and average couplings
    let newSignals = [];
    Object.values(groupedSignals).forEach((group) => {
        // joining couplings only if diaID and pathLength are equal
        let js = [];
        for (let i = 0; i < group[0].js.length; i++) {
            const coupling = group[0].js[i];
            js.push({
                diaIDs: coupling.diaIDs,
                pathLength: coupling.pathLength,
                multiplicity: coupling.multiplicity,
                coupling: (0, ml_array_mean_1.default)(group.map((item) => item.js[i].coupling)),
            });
        }
        let signal = {
            id: (0, uuid_1.v4)(),
            nbAtoms: (0, ml_array_sum_1.default)(group.map((item) => item.nbAtoms || 0)),
            delta: (0, ml_array_mean_1.default)(group.map((item) => item.delta)),
            diaIDs: group[0].diaIDs,
            atoms: group.map((item) => item.atoms || []).flat(),
            js,
        };
        const assignment = group
            .map((item) => item.assignment)
            .filter((item) => item)
            .join(' ');
        if (assignment.length > 0)
            signal.assignment = assignment;
        newSignals.push(signal);
    });
    newSignals = newSignals
        .map((signal) => {
        let newSignal = (0, signalJoinCouplings_1.signalJoinCouplings)(signal, {
            tolerance,
            ignoreDiaIDs,
        });
        if (newSignal.js) {
            newSignal.multiplicity =
                newSignal.js.length > 0
                    ? newSignal.js.map((j) => j.multiplicity).join('')
                    : 's';
        }
        return newSignal;
    })
        .sort((a, b) => a.delta - b.delta);
    return newSignals;
}
exports.signalsJoin = signalsJoin;

},{"../signal/signalJoinCouplings":488,"@lukeed/uuid":1,"ml-array-mean":151,"ml-array-sum":154}],500:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsToFID = void 0;
const ml_spectra_processing_1 = require("ml-spectra-processing");
const apodization_1 = require("../apodization/apodization");
const signalsToSpinSystem_1 = require("./simulation/signalsToSpinSystem");
const simulateXYPeaks_1 = require("./simulation/simulateXYPeaks");
const splitSpinSystem_1 = require("./simulation/splitSpinSystem");
const twoPi = Math.PI * 2;
/**
 * it use the chemical shifts and the coupling between them in order to generate a FID.
 * It does not propagate the hamiltonian of the spin system, instead it simulate all the
 * frequencies in the spectrum (including second order) and add all the waves in a real and
 * imaginary parts, that is why the couplings should be assigned in order to generate the spin system.
 */
function signalsToFID(signals, options) {
    const { lb = 1, from = 0, to = 10, nbPoints = 1024, frequency = 400, maxClusterSize = 8, } = options;
    let spinSystem = (0, signalsToSpinSystem_1.signalsToSpinSystem)(signals);
    spinSystem.clusters = (0, splitSpinSystem_1.splitSpinSystem)(spinSystem, {
        frequency,
        maxClusterSize,
    });
    const peaks = (0, simulateXYPeaks_1.simulateXYPeaks)(spinSystem, { frequency });
    const re = new Float64Array(nbPoints);
    const im = new Float64Array(nbPoints);
    const sw = Math.abs(to - from);
    const adquisitionTime = nbPoints / (sw * frequency);
    const time = (0, ml_spectra_processing_1.xSequentialFill)({
        size: nbPoints,
        from: 0,
        to: adquisitionTime,
    });
    for (const peak of peaks) {
        const { x, y } = peak;
        const cs = x * frequency * twoPi;
        for (let i = 0; i < nbPoints; i++) {
            re[i] += y * Math.cos(cs * time[i]);
            im[i] += y * Math.sin(cs * time[i]);
        }
    }
    const { windowData, ...result } = (0, apodization_1.apodization)({ re, im }, {
        pointsToShift: 0,
        compose: {
            length: nbPoints,
            shapes: [
                {
                    start: 0,
                    shape: {
                        kind: 'exponential',
                        options: {
                            dw: adquisitionTime / (nbPoints - 1),
                            lb,
                        },
                    },
                },
            ],
        },
    });
    return result;
}
exports.signalsToFID = signalsToFID;

},{"../apodization/apodization":425,"./simulation/signalsToSpinSystem":504,"./simulation/simulateXYPeaks":506,"./simulation/splitSpinSystem":507,"ml-spectra-processing":208}],501:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsToRanges = void 0;
const uuid_1 = require("@lukeed/uuid");
const rangeFromSignal_1 = require("../utilities/rangeFromSignal");
function checkNbAtoms(signals) {
    for (let signal of signals) {
        if (!signal.nbAtoms)
            throw new Error('nbAtoms is mandatory');
    }
}
function signalsToRanges(signals, options = {}) {
    checkNbAtoms(signals);
    const { tolerance = 0.05, frequency = 400 } = options;
    let wrapped = signals.map((signal) => ({
        original: signal,
    }));
    wrapped.forEach((signal) => {
        const fromTo = (0, rangeFromSignal_1.rangeFromSignal)(signal.original, { frequency, tolerance });
        signal.from = fromTo.from;
        signal.to = fromTo.to;
    });
    wrapped = wrapped.sort((signal1, signal2) => signal1.from - signal2.from);
    let ranges = [];
    let range = {};
    for (let signal of wrapped) {
        if (range.from === undefined || signal.from > range.to) {
            range = {
                id: (0, uuid_1.v4)(),
                from: signal.from,
                to: signal.to,
                integration: signal.original.nbAtoms,
                signals: [signal.original],
            };
            ranges.push(range);
        }
        else {
            range.integration += signal.original.nbAtoms;
            if (signal.to > range.to)
                range.to = signal.to;
            range.signals.push(signal.original);
        }
    }
    return ranges;
}
exports.signalsToRanges = signalsToRanges;

},{"../utilities/rangeFromSignal":513,"@lukeed/uuid":1}],502:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsToXY = void 0;
const ml_array_rescale_1 = __importDefault(require("ml-array-rescale"));
const ml_spectra_processing_1 = require("ml-spectra-processing");
const signalsToSpinSystem_1 = require("./simulation/signalsToSpinSystem");
const simulate1D_1 = __importDefault(require("./simulation/simulate1D"));
const splitSpinSystem_1 = require("./simulation/splitSpinSystem");
function checkForMandatory(signals) {
    for (const signal of signals) {
        if (!signal.js)
            throw new Error('There is not js');
        // if (!signal.diaID) throw new Error('There is not diaID');
        if (!signal.atoms)
            throw new Error('There is not atoms');
        for (const j of signal.js) {
            // if (!j.diaID) throw new Error('There is not diaID');
            if (!j.atoms)
                throw new Error('There is not atoms');
        }
    }
}
/**
 * Generate a spectrum from an array of singals
 */
function signalsToXY(signals, options = {}) {
    checkForMandatory(signals);
    let { frequency = 400, shape = {
        kind: 'gaussian',
    }, from = 0, to = 10, lineWidth = 1, nbPoints = 16 * 1024, maxValue = 1e8, maxClusterSize = 8, } = options;
    if (signals.length === 0) {
        return {
            x: (0, ml_spectra_processing_1.xSequentialFill)({ from, to, size: nbPoints }),
            y: Array.from(new Float64Array(nbPoints)),
        };
    }
    let spinSystem = (0, signalsToSpinSystem_1.signalsToSpinSystem)(signals);
    spinSystem.clusters = (0, splitSpinSystem_1.splitSpinSystem)(spinSystem, {
        frequency,
        maxClusterSize,
    });
    let spectrum = (0, simulate1D_1.default)(spinSystem, {
        frequency,
        from,
        to,
        nbPoints,
        lineWidth,
        shape,
    });
    if (maxValue) {
        spectrum.y = (0, ml_array_rescale_1.default)(spectrum.y, { max: maxValue });
    }
    return spectrum;
}
exports.signalsToXY = signalsToXY;

},{"./simulation/signalsToSpinSystem":504,"./simulation/simulate1D":505,"./simulation/splitSpinSystem":507,"ml-array-rescale":153,"ml-spectra-processing":208}],503:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_sparse_matrix_1 = require("ml-sparse-matrix");
function createPauli(mult) {
    const spin = (mult - 1) / 2;
    const prjs = new Array(mult);
    const temp = new Array(mult);
    for (let i = 0; i < mult; i++) {
        prjs[i] = mult - 1 - i - spin;
        temp[i] = Math.sqrt(spin * (spin + 1) - prjs[i] * (prjs[i] + 1));
    }
    const p = diag(temp, 1, mult, mult);
    for (let i = 0; i < mult; i++) {
        temp[i] = Math.sqrt(spin * (spin + 1) - prjs[i] * (prjs[i] - 1));
    }
    const m = diag(temp, -1, mult, mult);
    const x = p.clone().add(m).mul(0.5);
    const y = m.clone().mul(-1).add(p).mul(-0.5);
    const z = diag(prjs, 0, mult, mult);
    return { x, y, z, m, p };
}
function diag(A, d, n, m) {
    const diag = new ml_sparse_matrix_1.SparseMatrix(n, m, { initialCapacity: 20 });
    for (let i = 0; i < A.length; i++) {
        if (i - d >= 0 && i - d < n && i < m) {
            diag.set(i - d, i, A[i]);
        }
    }
    return diag;
}
const pauli2 = createPauli(2);
function getPauliMatrix(mult) {
    if (mult === 2)
        return pauli2;
    else
        return createPauli(mult);
}
exports.default = getPauliMatrix;

},{"ml-sparse-matrix":200}],504:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signalsToSpinSystem = void 0;
const ml_matrix_1 = require("ml-matrix");
const ml_simple_clustering_1 = __importDefault(require("ml-simple-clustering"));
function checkForMandatory(signals) {
    for (const signal of signals) {
        if (!signal.js)
            throw new Error('there is not js');
        if (!signal.atoms)
            throw new Error('there is not atoms');
        for (const jcoupling of signal.js) {
            if (!jcoupling.atoms)
                throw new Error('there is not atoms');
        }
    }
}
function signalsToSpinSystem(signals) {
    checkForMandatory(signals);
    const nSpins = signals.length;
    const chemicalShifts = new Array(nSpins);
    const multiplicity = new Array(nSpins);
    const couplingConstants = ml_matrix_1.Matrix.zeros(nSpins, nSpins);
    //create a list of assignments
    const ids = {};
    for (let i = 0; i < nSpins; i++) {
        multiplicity[i] = 2;
        chemicalShifts[i] = signals[i].delta;
        const index = signals[i].atoms[0];
        ids[index] = i;
    }
    //create the coupling matrix
    for (let i = 0; i < nSpins; i++) {
        let { atoms: signalAssignment, js: jCoupling } = signals[i];
        const fromIndex = signalAssignment[0];
        for (const jcoupling of jCoupling) {
            let { coupling, atoms } = jcoupling;
            const toIndex = atoms[0];
            couplingConstants.set(ids[fromIndex], ids[toIndex], coupling);
            couplingConstants.set(ids[toIndex], ids[fromIndex], coupling);
        }
    }
    const connectivity = ml_matrix_1.Matrix.ones(couplingConstants.rows, couplingConstants.rows);
    for (let i = 0; i < couplingConstants.rows; i++) {
        for (let j = i; j < couplingConstants.columns; j++) {
            if (couplingConstants.get(i, j) === 0) {
                connectivity.set(i, j, 0);
                connectivity.set(j, i, 0);
            }
        }
    }
    let clusters = (0, ml_simple_clustering_1.default)(connectivity.to2DArray(), {
        out: 'indexes',
    });
    return {
        clusters,
        couplingConstants,
        chemicalShifts,
        multiplicity,
        connectivity,
    };
}
exports.signalsToSpinSystem = signalsToSpinSystem;

},{"ml-matrix":186,"ml-simple-clustering":199}],505:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spectrum_generator_1 = require("spectrum-generator");
const simulateXYPeaks_1 = require("./simulateXYPeaks");
/**
 * This function simulates a one dimensional nmr spectrum. This function returns an array containing the relative intensities of the spectrum in the specified simulation window (from-to).
 */
function simulate1D(
/**
 * The SpinSystem object to be simulated
 */
spinSystem, options = {}) {
    let { lineWidth = 1, frequency: frequencyMHz = 400, from = 0, to = 10, nbPoints = 1024, shape = {
        kind: 'gaussian',
    }, } = options;
    let peakWidth = lineWidth / frequencyMHz;
    const xyPeaks = (0, simulateXYPeaks_1.simulateXYPeaks)(spinSystem, options);
    return (0, spectrum_generator_1.generateSpectrum)(xyPeaks, {
        generator: {
            from,
            to,
            nbPoints,
        },
        peakOptions: {
            shape,
            width: peakWidth,
        },
    });
}
exports.default = simulate1D;

},{"./simulateXYPeaks":506,"spectrum-generator":530}],506:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateXYPeaks = void 0;
const binary_search_1 = __importDefault(require("binary-search"));
const ml_matrix_1 = require("ml-matrix");
const ml_sparse_matrix_1 = require("ml-sparse-matrix");
const getPauliMatrix_1 = __importDefault(require("./getPauliMatrix"));
const smallValue = 1e-2;
function simulateXYPeaks(
/**
 * The SpinSystem object to be simulated
 */
spinSystem, options = {}) {
    let { lineWidth = 1, maxClusterSize = 8, frequency: frequencyMHz = 400, } = options;
    const chemicalShifts = spinSystem.chemicalShifts.slice();
    for (let i = 0; i < chemicalShifts.length; i++) {
        chemicalShifts[i] = chemicalShifts[i] * frequencyMHz;
    }
    const multiplicity = spinSystem.multiplicity;
    const xyPeaks = [];
    for (const cluster of spinSystem.clusters) {
        let clusterFake = cluster.map((cluster) => cluster < 0 ? -cluster - 1 : cluster);
        let weight = 1;
        let sumI = 0;
        let frequencies = [];
        let intensities = [];
        if (cluster.length > maxClusterSize) {
            // This is a single spin, but the cluster exceeds the maxClusterSize criteria
            // we use the simple multiplicity algorithm
            // Add the central peak. It will be split with every single J coupling.
            let index = 0;
            while (cluster[index++] < 0)
                ;
            index = cluster[index - 1];
            frequencies.push(-chemicalShifts[index]);
            for (let i = 0; i < cluster.length; i++) {
                if (cluster[i] < 0) {
                    let jc = spinSystem.couplingConstants.get(index, clusterFake[i]) / 2;
                    let currentSize = frequencies.length;
                    for (let j = 0; j < currentSize; j++) {
                        frequencies.push(frequencies[j] + jc);
                        frequencies[j] -= jc;
                    }
                }
            }
            frequencies.sort((a, b) => a - b);
            sumI = frequencies.length;
            weight = 1;
            for (let i = 0; i < sumI; i++) {
                intensities.push(1);
            }
        }
        else {
            const hamiltonian = getHamiltonian(chemicalShifts, spinSystem.couplingConstants, multiplicity, spinSystem.connectivity, clusterFake);
            const hamSize = hamiltonian.rows;
            // TODO: add support for sparse matrix in matrix types.
            // @ts-expect-error sparse matrix not supported
            const evd = new ml_matrix_1.EVD(hamiltonian);
            const V = evd.eigenvectorMatrix;
            const diagB = evd.realEigenvalues;
            const assignmentMatrix = new ml_sparse_matrix_1.SparseMatrix(hamSize, hamSize);
            const multLen = cluster.length;
            weight = 0;
            for (let n = 0; n < multLen; n++) {
                const L = (0, getPauliMatrix_1.default)(multiplicity[clusterFake[n]]);
                let temp = 1;
                for (let j = 0; j < n; j++) {
                    temp *= multiplicity[clusterFake[j]];
                }
                const A = ml_sparse_matrix_1.SparseMatrix.eye(temp);
                temp = 1;
                for (let j = n + 1; j < multLen; j++) {
                    temp *= multiplicity[clusterFake[j]];
                }
                const B = ml_sparse_matrix_1.SparseMatrix.eye(temp);
                const tempMat = A.kroneckerProduct(L.m).kroneckerProduct(B);
                if (cluster[n] >= 0) {
                    assignmentMatrix.add(tempMat.mul(cluster[n] + 1));
                    weight++;
                }
                else {
                    assignmentMatrix.add(tempMat.mul(cluster[n]));
                }
            }
            let rhoip = ml_matrix_1.Matrix.zeros(hamSize, hamSize);
            assignmentMatrix.forEachNonZero((i, j, v) => {
                if (v > 0) {
                    for (let k = 0; k < V.columns; k++) {
                        let element = V.get(j, k);
                        if (element !== 0) {
                            rhoip.set(i, k, rhoip.get(i, k) + element);
                        }
                    }
                }
                return v;
            });
            let rhoip2 = rhoip.clone();
            assignmentMatrix.forEachNonZero((i, j, v) => {
                if (v < 0) {
                    for (let k = 0; k < V.columns; k++) {
                        let element = V.get(j, k);
                        if (element !== 0) {
                            rhoip2.set(i, k, rhoip2.get(i, k) + element);
                        }
                    }
                }
                return v;
            });
            const tV = V.transpose();
            rhoip = tV.mmul(rhoip);
            const sparseRhoip = new ml_sparse_matrix_1.SparseMatrix(rhoip.to2DArray(), {
                threshold: smallValue,
            });
            triuTimesAbs(sparseRhoip, smallValue);
            rhoip2 = tV.mmul(rhoip2);
            const sparseRhoip2 = new ml_sparse_matrix_1.SparseMatrix(rhoip2.to2DArray(), {
                threshold: smallValue,
            });
            sparseRhoip2.forEachNonZero((i, j, v) => {
                return v;
            });
            triuTimesAbs(sparseRhoip2, smallValue);
            sparseRhoip2.forEachNonZero((i, j, v) => {
                let val = rhoip.get(i, j);
                val = Math.min(Math.abs(val), Math.abs(v));
                val *= val;
                sumI += val;
                let valFreq = diagB[i] - diagB[j];
                let insertIn = (0, binary_search_1.default)(frequencies, valFreq, (a, b) => a - b);
                if (insertIn < 0) {
                    frequencies.splice(-1 - insertIn, 0, valFreq);
                    intensities.splice(-1 - insertIn, 0, val);
                }
                else {
                    intensities[insertIn] += val;
                }
            });
        }
        const numFreq = frequencies.length;
        if (numFreq > 0) {
            weight /= sumI;
            const diff = lineWidth / 64;
            let valFreq = frequencies[0];
            let inte = intensities[0];
            let count = 1;
            for (let i = 1; i < numFreq; i++) {
                if (Math.abs(frequencies[i] - valFreq / count) < diff) {
                    inte += intensities[i];
                    valFreq += frequencies[i];
                    count++;
                }
                else {
                    xyPeaks.push({
                        x: -valFreq / count / frequencyMHz,
                        y: inte * weight,
                    });
                    valFreq = frequencies[i];
                    inte = intensities[i];
                    count = 1;
                }
            }
            xyPeaks.push({
                x: -valFreq / count / frequencyMHz,
                y: inte * weight,
            });
        }
    }
    return xyPeaks.filter((peak) => peak.x < 1000);
}
exports.simulateXYPeaks = simulateXYPeaks;
function triuTimesAbs(A, val) {
    A.forEachNonZero((i, j, v) => {
        if (i > j)
            return 0;
        if (Math.abs(v) <= val)
            return 0;
        return v;
    });
}
/**
 * Create a hamiltonian matrix for the given spinsystem
 * @param {Array} chemicalShifts - An array containing the chemical shift in Hz
 * @param {Array} couplingConstants - An array containing the coupling constants in Hz
 * @param {Array} multiplicity - An array specifiying the multiplicities of each scalar coupling
 * @param {Array} conMatrix - A one step connectivity matrix for the given spin system
 * @param {Array} cluster - An binary array specifiying the spins to be considered for this hamiltonial
 * @return {object}
 */
function getHamiltonian(chemicalShifts, couplingConstants, multiplicity, conMatrix, cluster) {
    let hamSize = 1;
    for (const element of cluster) {
        hamSize *= multiplicity[element];
    }
    const clusterHam = new ml_sparse_matrix_1.SparseMatrix(hamSize, hamSize);
    for (let pos = 0; pos < cluster.length; pos++) {
        let n = cluster[pos];
        const L = (0, getPauliMatrix_1.default)(multiplicity[n]);
        let A1, B1;
        let temp = 1;
        for (let i = 0; i < pos; i++) {
            temp *= multiplicity[cluster[i]];
        }
        A1 = ml_sparse_matrix_1.SparseMatrix.eye(temp);
        temp = 1;
        for (let i = pos + 1; i < cluster.length; i++) {
            temp *= multiplicity[cluster[i]];
        }
        B1 = ml_sparse_matrix_1.SparseMatrix.eye(temp);
        const alpha = chemicalShifts[n];
        const kronProd = A1.kroneckerProduct(L.z).kroneckerProduct(B1);
        clusterHam.add(kronProd.mul(alpha));
        for (let pos2 = 0; pos2 < cluster.length; pos2++) {
            const k = cluster[pos2];
            if (conMatrix.get(n, k) === 1) {
                const S = (0, getPauliMatrix_1.default)(multiplicity[k]);
                let A2, B2;
                let temp = 1;
                for (let i = 0; i < pos2; i++) {
                    temp *= multiplicity[cluster[i]];
                }
                A2 = ml_sparse_matrix_1.SparseMatrix.eye(temp);
                temp = 1;
                for (let i = pos2 + 1; i < cluster.length; i++) {
                    temp *= multiplicity[cluster[i]];
                }
                B2 = ml_sparse_matrix_1.SparseMatrix.eye(temp);
                const kron1 = A1.kroneckerProduct(L.x)
                    .kroneckerProduct(B1)
                    .mmul(A2.kroneckerProduct(S.x).kroneckerProduct(B2));
                kron1.add(A1.kroneckerProduct(L.y)
                    .kroneckerProduct(B1)
                    .mul(-1)
                    .mmul(A2.kroneckerProduct(S.y).kroneckerProduct(B2)));
                kron1.add(A1.kroneckerProduct(L.z)
                    .kroneckerProduct(B1)
                    .mmul(A2.kroneckerProduct(S.z).kroneckerProduct(B2)));
                clusterHam.add(kron1.mul(couplingConstants.get(n, k) / 2));
            }
        }
    }
    return clusterHam;
}

},{"./getPauliMatrix":503,"binary-search":3,"ml-matrix":186,"ml-sparse-matrix":200}],507:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitSpinSystem = void 0;
const ml_hclust_1 = require("ml-hclust");
const ml_matrix_1 = require("ml-matrix");
function splitSpinSystem(spinSystem, options = {}) {
    let { chemicalShifts, couplingConstants, connectivity } = spinSystem;
    let { frequency = 400, maxClusterSize = 8 } = options;
    let betas = calculateBetas(chemicalShifts, couplingConstants, frequency);
    let initClusters = (0, ml_hclust_1.agnes)(betas, { method: 'single', isDistanceMatrix: true });
    let clusterList = [];
    let nSpins = chemicalShifts.length;
    splitCluster(initClusters, clusterList, {
        maxClusterSize,
        force: false,
        nSpins,
        connectivity,
    });
    let mergedClusters = mergeClusters(clusterList, maxClusterSize);
    let nClusters = mergedClusters.length;
    let clusters = new Array(nClusters);
    for (let j = 0; j < nClusters; j++) {
        clusters[j] = [];
        for (let i = 0; i < nSpins; i++) {
            let element = mergedClusters[j][i];
            if (element === 0)
                continue;
            clusters[j].push(element < 0 ? -(i + 1) : i);
        }
    }
    return clusters;
}
exports.splitSpinSystem = splitSpinSystem;
function splitCluster(cluster, clusterList, options) {
    let { maxClusterSize, force, nSpins, connectivity } = options;
    if (!force && cluster.size <= maxClusterSize) {
        clusterList.push(getMembers(cluster.indices(), nSpins));
    }
    else {
        for (let child of cluster.children) {
            if (child.size <= maxClusterSize) {
                let members = getMembers(child.indices(), nSpins);
                // Add the neighbors that shares at least 1 coupling with the given cluster
                let count = 0;
                for (let i = 0; i < nSpins; i++) {
                    if (members[i] === 1) {
                        for (let j = 0; j < nSpins; j++) {
                            if (connectivity.get(i, j) === 1 && members[j] === 0) {
                                members[j] = -1;
                                count++;
                            }
                        }
                        count++;
                    }
                }
                if (count <= maxClusterSize) {
                    clusterList.push(members);
                }
                else if (child.index < 0) {
                    splitCluster(child, clusterList, {
                        maxClusterSize,
                        force: true,
                        nSpins,
                        connectivity,
                    });
                }
                else {
                    // We have to threat this spin alone and use the resurrection algorithm instead of the simulation
                    members[child.index] = 2;
                    clusterList.push(members);
                }
            }
            else {
                splitCluster(child, clusterList, {
                    maxClusterSize,
                    force: false,
                    nSpins,
                    connectivity,
                });
            }
        }
    }
}
function calculateBetas(chemicalShifts, couplingConstants, frequency) {
    let nRows = couplingConstants.rows;
    let nColumns = couplingConstants.columns;
    let betas = ml_matrix_1.Matrix.zeros(nRows, nRows);
    // Before clustering, we must add hidden couplingConstants, we could use molecular information if available
    for (let i = 0; i < nRows; i++) {
        for (let j = i; j < nColumns; j++) {
            let element = couplingConstants.get(i, j);
            if (chemicalShifts[i] - chemicalShifts[j] !== 0) {
                let value = 1 -
                    Math.abs(element / ((chemicalShifts[i] - chemicalShifts[j]) * frequency));
                betas.set(i, j, value);
                betas.set(j, i, value);
            }
            else if (!(i === j || element !== 0)) {
                betas.set(i, j, 1);
                betas.set(j, i, 1);
            }
        }
    }
    return betas.to2DArray();
}
function mergeClusters(list, maxClusterSize) {
    for (let i = list.length - 1; i >= 0; i--) {
        let clusterA = list[i];
        let nElements = clusterA.length;
        let index = 0;
        // Is it a candidate to be merged?
        while (index < nElements && clusterA[index++] !== -1)
            ;
        if (index >= nElements)
            continue;
        for (let j = list.length - 1; j >= i + 1; j--) {
            let clusterB = list[j];
            // Do they have common elements?
            let count = 0;
            let common = 0;
            for (let index = 0; index < nElements; index++) {
                if (clusterA[index] * clusterB[index] === -1)
                    common++;
                if (clusterA[index] !== 0 || clusterB[index] !== 0)
                    count++;
            }
            if (common > 0 && count <= maxClusterSize) {
                // Then we can merge those 2 clusters
                for (let index = 0; index < nElements; index++) {
                    if (clusterB[index] === 1) {
                        clusterA[index] = 1;
                    }
                    else if (clusterB[index] === -1 && clusterA[index] !== 1) {
                        clusterA[index] = -1;
                    }
                }
                list.splice(j, 1);
            }
        }
    }
    return list;
}
function getMembers(cluster, nSpins) {
    let members = new Int16Array(nSpins);
    for (let e of cluster) {
        members[e] = 1;
    }
    return members;
}

},{"ml-hclust":178,"ml-matrix":186}],508:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * This library implements the J analyser described by Cobas et al in the paper:
 * A two-stage approach to automatic determination of 1H NMR coupling constants
 */
const patterns = ['s', 'd', 't', 'q', 'quint', 'h', 'sept', 'o', 'n'];
let symRatio = 1.5;
let maxErrorIter1 = 2.5; // Hz
let maxErrorIter2 = 1; // Hz
let jAxisKeys = { jAxis: 'x', intensity: 'intensity' };
function checkSignalForCompilePattern(signal) {
    if (!('symRank' in signal)) {
        throw new Error('Internal error, symRank was not calculated');
    }
    if (!('mask' in signal)) {
        throw new Error('Internal Error, mask was not added');
    }
}
exports.default = {
    /**
     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.
     * embedding in peak-component-counting method described by Hoyes et al.
     * @param {object} signal
     * @private
     */
    compilePattern: (inputSignal, options = {}) => {
        let { jAxisKey = jAxisKeys } = options;
        // checkForPeaks(inputSignal);
        // const signal = JSON.parse(JSON.stringify(inputSignal));
        // 1.1 symmetrize
        // It will add a set of peaks(signal.peaksComp) to the signal that will be used during
        // the compilation process. The unit of those peaks will be in Hz
        const signal = symmetrizeChoiseBest(inputSignal, {
            maxError: maxErrorIter1,
            iteration: 1,
            jAxisKey,
        });
        signal.multiplicity = 'm';
        signal.asymmetric = true;
        //asserts the signal has all needed
        checkSignalForCompilePattern(signal);
        // Is the signal symmetric?
        if (signal.symRank >= 0.95 && signal.peaksComp.length < 32) {
            signal.asymmetric = false;
            let P1, n2, maxFlagged;
            let k = 1;
            let jCouplings = [];
            // Loop over the possible number of coupling contributing to the multiplet
            for (let n = 0; n < 9; n++) {
                // 1.2 Normalize. It makes a deep copy of the peaks before to modify them.
                let peaks = normalize(signal, n);
                let validPattern = false; // It will change to true, when we find the good patter
                // Lets check if the signal could be a singulet.
                if (peaks.length === 1 && n === 0) {
                    validPattern = true;
                }
                else if (peaks.length <= 1) {
                    continue;
                }
                // 1.3 Establish a range for the Heights Hi [peaks.intensity*0.85,peaks.intensity*1.15];
                let ranges = getRanges(peaks);
                n2 = Math.pow(2, n);
                // 1.4 Find a combination of integer heights Hi, one from each Si, that sums to 2^n.
                let heights = null;
                let counter = 1;
                while (!validPattern &&
                    (heights = getNextCombination(ranges, n2)) !== null &&
                    counter < 400) {
                    // 2.1 Number the components of the multiplet consecutively from 1 to 2n,
                    // starting at peak 1
                    let numbering = new Array(heights.length);
                    k = 1;
                    for (let i = 0; i < heights.length; i++) {
                        numbering[i] = new Array(heights[i]);
                        for (let j = 0; j < heights[i]; j++) {
                            numbering[i][j] = k++;
                        }
                    }
                    jCouplings = []; // The array to store the detected j-coupling
                    // 2.2 Set j = 1; J1 = P2 - P1. Flag components 1 and 2 as accounted for.
                    let j = 1;
                    jCouplings.push(peaks[1].x - peaks[0].x);
                    P1 = peaks[0].x;
                    numbering[0].splice(0, 1); // Flagged
                    numbering[1].splice(0, 1); // Flagged
                    k = 1;
                    let nFlagged = 2;
                    maxFlagged = Math.pow(2, n) - 1;
                    while (jCouplings.length < n &&
                        nFlagged < maxFlagged &&
                        k < peaks.length) {
                        counter += 1;
                        // 4.1. Increment j. Set k to the number of the first unflagged component.
                        j++;
                        while (k < peaks.length && numbering[k].length === 0) {
                            k++;
                        }
                        if (k < peaks.length) {
                            // 4.2 Jj = Pk - P1.
                            jCouplings.push(peaks[k].x - peaks[0].x);
                            // Flag component k and, for each sum of the...
                            numbering[k].splice(0, 1); // Flageed
                            nFlagged++;
                            // Flag the other components of the multiplet
                            for (let u = 2; u <= j; u++) {
                                let jSum = 0;
                                for (let i = 0; i < u; i++) {
                                    jSum += jCouplings[i];
                                }
                                for (let i = 1; i < numbering.length; i++) {
                                    // Maybe 0.25 Hz is too much?
                                    if (Math.abs(peaks[i].x - (P1 + jSum)) < 0.25) {
                                        numbering[i].splice(0, 1); // Flageed
                                        nFlagged++;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    // Calculate the ideal patter by using the extracted j-couplings
                    let pattern = idealPattern(jCouplings);
                    // Compare the ideal pattern with the proposed intensities.
                    // All the intensities have to match to accept the multiplet
                    validPattern = true;
                    for (let i = 0; i < pattern.length; i++) {
                        if (pattern[i].intensity !== heights[i]) {
                            validPattern = false;
                        }
                    }
                }
                // If we found a valid pattern we should inform about the pattern.
                if (validPattern) {
                    updateSignal(signal, jCouplings);
                }
            }
        }
        // Before to return, change the units of peaksComp from Hz to PPM again
        for (let peakComp of signal.peaksComp) {
            peakComp.x /= signal.observe;
            peakComp.width *= signal.observe;
        }
        return signal;
    },
};
/**
 * @private
 * update the signal
 * @param {*} signal
 * @param {*} jCouplings
 */
function updateSignal(signal, jCouplings) {
    // Update the limits of the signal
    let peaks = signal.peaksComp; // Always in Hz
    let nbPeaks = peaks.length;
    signal.startX = peaks[0].x / signal.observe - peaks[0].width;
    signal.stopX =
        peaks[nbPeaks - 1].x / signal.observe + peaks[nbPeaks - 1].width;
    signal.integralData.from = peaks[0].x / signal.observe - peaks[0].width * 3;
    signal.integralData.to =
        peaks[nbPeaks - 1].x / signal.observe + peaks[nbPeaks - 1].width * 3;
    // Compile the pattern and format the constant couplings
    signal.maskPattern = signal.mask2;
    signal.multiplicity = abstractPattern(signal, jCouplings);
    signal.pattern = signal.multiplicity; // Our library depends on this parameter, but it is old
}
/**
 * Returns the multiplet in the compact format
 * @param {object} signal
 * @param {object} jCouplings
 * @return {String}
 * @private
 */
function abstractPattern(signal, jCouplings) {
    let tol = 0.05;
    let pattern = '';
    let cont = 1;
    let newNmrJs = [];
    if (jCouplings && jCouplings.length > 0) {
        jCouplings.sort((a, b) => {
            return b - a;
        });
        for (let i = 0; i < jCouplings.length - 1; i++) {
            if (Math.abs(jCouplings[i] - jCouplings[i + 1]) < tol) {
                cont++;
            }
            else {
                newNmrJs.push({
                    coupling: Math.abs(jCouplings[i]),
                    multiplicity: patterns[cont],
                });
                pattern += patterns[cont];
                cont = 1;
            }
        }
        let index = jCouplings.length - 1;
        newNmrJs.push({
            coupling: Math.abs(jCouplings[index]),
            multiplicity: patterns[cont],
        });
        pattern += patterns[cont];
        signal.nmrJs = newNmrJs;
    }
    else {
        pattern = 's';
        if (Math.abs(signal.startX - signal.stopX) * signal.observe > 16) {
            pattern = 'br s';
        }
    }
    return pattern;
}
/**
 * This function creates an ideal pattern from the given J-couplings
 * @private
 * @param {Array} jCouplings
 * @return {*[]}
 * @private
 */
function idealPattern(jCouplings) {
    let hsum = Math.pow(2, jCouplings.length);
    let pattern = [{ x: 0, intensity: hsum }];
    // To split the initial height
    for (const jc of jCouplings) {
        for (let j = pattern.length - 1; j >= 0; j--) {
            pattern.push({
                x: pattern[j].x + jc / 2,
                intensity: pattern[j].intensity / 2,
            });
            pattern[j].x = pattern[j].x - jc / 2;
            pattern[j].intensity = pattern[j].intensity / 2;
        }
    }
    // To sum the heights in the same positions
    pattern.sort((a, b) => {
        return a.x - b.x;
    });
    for (let j = pattern.length - 2; j >= 0; j--) {
        if (Math.abs(pattern[j].x - pattern[j + 1].x) < 0.1) {
            pattern[j].intensity += pattern[j + 1].intensity;
            pattern.splice(j + 1, 1);
        }
    }
    return pattern;
}
/**
 * Find a combination of integer heights Hi, one from each Si, that sums to 2n.
 * @param {object} ranges
 * @param {Number} value
 * @return {*}
 * @private
 */
function getNextCombination(ranges, value) {
    let half = Math.ceil(ranges.values.length * 0.5);
    let lng = ranges.values.length;
    let sum = 0;
    let ok;
    while (sum !== value) {
        // Update the indexes to point at the next possible combination
        ok = false;
        while (!ok) {
            ok = true;
            ranges.currentIndex[ranges.active]++;
            if (ranges.currentIndex[ranges.active] >=
                ranges.values[ranges.active].length) {
                // In this case, there is no more possible combinations
                if (ranges.active + 1 === half) {
                    return null;
                }
                else {
                    // If this happens we need to try the next active peak
                    ranges.currentIndex[ranges.active] = 0;
                    ok = false;
                    ranges.active++;
                }
            }
            else {
                ranges.active = 0;
            }
        }
        // Sum the heights for this combination
        sum = 0;
        for (let i = 0; i < half; i++) {
            sum += ranges.values[i][ranges.currentIndex[i]] * 2;
        }
        if (ranges.values.length % 2 !== 0) {
            sum -= ranges.values[half - 1][ranges.currentIndex[half - 1]];
        }
    }
    // If the sum is equal to the expected value, fill the array to return
    if (sum === value) {
        let heights = new Array(lng);
        for (let i = 0; i < half; i++) {
            heights[i] = ranges.values[i][ranges.currentIndex[i]];
            heights[lng - i - 1] = ranges.values[i][ranges.currentIndex[i]];
        }
        return heights;
    }
    return null;
}
/**
 * This function generates the possible values that each peak can contribute
 * to the multiplet.
 * @param {Array} peaks Array of objects with peaks information {intensity}
 * @return {{values: Array, currentIndex: Array, active: number}}
 * @private
 */
function getRanges(peaks) {
    let ranges = new Array(peaks.length);
    let currentIndex = new Array(peaks.length);
    let min, max;
    ranges[0] = [1];
    ranges[peaks.length - 1] = [1];
    currentIndex[0] = -1;
    currentIndex[peaks.length - 1] = 0;
    for (let i = 1; i < peaks.length - 1; i++) {
        min = Math.round(peaks[i].intensity * 0.85);
        max = Math.round(peaks[i].intensity * 1.15);
        ranges[i] = [];
        for (let j = min; j <= max; j++) {
            ranges[i].push(j);
        }
        currentIndex[i] = 0;
    }
    return { values: ranges, currentIndex, active: 0 };
}
/**
 * Performs a symmetrization of the signal by using different aproximations to the center.
 * It will return the result of the symmetrization that removes less peaks from the signal
 * @param {object} signal
 * @param {Number} maxError
 * @param {Number} iteration
 * @return {*}
 * @private
 */
function symmetrizeChoiseBest(signal, options) {
    let { maxError, iteration, jAxisKey = jAxisKeys } = options;
    //make a clone of signal
    let newSignal1 = symmetrize(signal, maxError, iteration, jAxisKey);
    if (!newSignal1.peaksComp) {
        throw new Error('internal peaksComp was not created');
    }
    let tmpPeaks = newSignal1.peaksComp;
    let tmpMask = newSignal1.mask;
    let cs = signal.delta;
    signal.delta =
        (signal.peaks[0].x + signal.peaks[signal.peaks.length - 1].x) / 2;
    let newSignal2 = symmetrize(signal, maxError, iteration, jAxisKey);
    if (!newSignal2.peaksComp) {
        throw new Error('internal peaksComp was not created');
    }
    if (newSignal2.peaksComp.length > tmpPeaks.length) {
        return newSignal2;
    }
    signal.delta = cs;
    signal.peaksComp = tmpPeaks;
    signal.mask = tmpMask;
    return newSignal1;
}
/**
 * This function will return a set of symmetric peaks that will
 * be the enter point for the patter compilation process.
 * @param {object} signal
 * @param {Number} maxError
 * @param {Number} iteration
 * @return {Number}
 * @private
 */
function symmetrize(signalInput, maxError, iteration, key) {
    let { jAxis, intensity } = key;
    const newSignal = JSON.parse(JSON.stringify(signalInput));
    // Before to symmetrize we need to keep only the peaks that possibly conforms the multiplete
    let max, min, avg, ratio, avgWidth;
    let peaks = new Array(newSignal.peaks.length);
    // Make a deep copy of the peaks and convert PPM ot HZ
    for (let i = 0; i < peaks.length; i++) {
        let peak = newSignal.peaks[i];
        peaks[i] = {
            x: peak[jAxis] * newSignal.observe,
            intensity: peak[intensity],
            width: peak.width / newSignal.observe,
        };
    }
    // Join the peaks that are closer than 0.25 Hz
    for (let i = peaks.length - 2; i >= 0; i--) {
        if (Math.abs(peaks[i].x - peaks[i + 1].x) < 0.25) {
            peaks[i].x =
                peaks[i].x * peaks[i].intensity +
                    peaks[i + 1].x * peaks[i + 1].intensity;
            peaks[i].intensity = peaks[i].intensity + peaks[i + 1].intensity;
            peaks[i].x /= peaks[i].intensity;
            peaks[i].intensity /= 2;
            peaks[i].width += peaks[i + 1].width;
            peaks.splice(i + 1, 1);
        }
    }
    newSignal.peaksComp = peaks;
    let nbPeaks = peaks.length;
    let mask = new Array(nbPeaks);
    newSignal.mask = mask;
    let left = 0;
    let right = peaks.length - 1;
    let cs = newSignal.delta * newSignal.observe;
    let middle = [(peaks[0].x + peaks[nbPeaks - 1].x) / 2, 1];
    maxError = error(Math.abs(cs - middle[0]));
    let heightSum = 0;
    // We try to symmetrize the extreme peaks. We consider as candidates for symmetricing those which have
    // ratio smaller than 3
    for (let i = 0; i < nbPeaks; i++) {
        mask[i] = true;
        // heightSum += signal.peaks[i].intensity;
        heightSum += peaks[i].intensity;
    }
    while (left <= right) {
        mask[left] = true;
        mask[right] = true;
        if (left === right) {
            if (nbPeaks > 2 && Math.abs(peaks[left].x - cs) > maxError) {
                mask[left] = false;
            }
        }
        else {
            max = Math.max(peaks[left].intensity, peaks[right].intensity);
            min = Math.min(peaks[left].intensity, peaks[right].intensity);
            ratio = max / min;
            if (ratio > symRatio) {
                if (peaks[left].intensity === min) {
                    mask[left] = false;
                    right++;
                }
                else {
                    mask[right] = false;
                    left--;
                }
            }
            else {
                let diffL = Math.abs(peaks[left].x - cs);
                let diffR = Math.abs(peaks[right].x - cs);
                if (Math.abs(diffL - diffR) < maxError) {
                    avg = Math.min(peaks[left].intensity, peaks[right].intensity);
                    avgWidth = Math.min(peaks[left].width, peaks[right].width);
                    peaks[left].intensity = avg;
                    peaks[right].intensity = avg;
                    peaks[left].width = avgWidth;
                    peaks[right].width = avgWidth;
                    middle = [
                        middle[0] + (peaks[right].x + peaks[left].x) / 2,
                        middle[1] + 1,
                    ];
                }
                else if (Math.max(diffL, diffR) === diffR) {
                    mask[right] = false;
                    left--;
                }
                else {
                    mask[left] = false;
                    right++;
                }
            }
        }
        left++;
        right--;
        // Only alter cs if it is the first iteration of the sym process.
        if (iteration === 1) {
            cs = chemicalShift(peaks, mask);
            // There is not more available peaks
            if (isNaN(cs)) {
                newSignal.symRank = 0;
                return newSignal;
            }
        }
        maxError = error(Math.abs(cs - middle[0] / middle[1]));
    }
    // To remove the weak peaks and recalculate the cs
    for (let i = nbPeaks - 1; i >= 0; i--) {
        if (mask[i] === false) {
            peaks.splice(i, 1);
        }
    }
    cs = chemicalShift(peaks);
    if (isNaN(cs)) {
        newSignal.symRank = 0;
        return newSignal;
    }
    newSignal.delta = cs / newSignal.observe;
    // Now, the peak should be symmetric in heights, but we need to know if it is symmetric in x
    let symFactor = 0;
    let weight = 0;
    if (peaks.length > 1) {
        for (let i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {
            symFactor +=
                ((3 +
                    Math.min(Math.abs(peaks[i].x - cs), Math.abs(peaks[peaks.length - 1 - i].x - cs))) /
                    (3 +
                        Math.max(Math.abs(peaks[i].x - cs), Math.abs(peaks[peaks.length - 1 - i].x - cs)))) *
                    peaks[i].intensity;
            weight += peaks[i].intensity;
        }
        symFactor /= weight;
    }
    else if (peaks.length === 1) {
        symFactor = 1;
    }
    let newSumHeights = 0;
    for (const peak of peaks) {
        newSumHeights += peak.intensity;
    }
    symFactor -= ((heightSum - newSumHeights) / heightSum) * 0.12; // Removed peaks penalty
    // Sometimes we need a second opinion after the first symmetrization.
    if (symFactor > 0.8 && symFactor < 0.97 && iteration < 2) {
        return symmetrize(newSignal, maxErrorIter2, 2, key);
    }
    else if (peaks.length > 1) {
        // Center the given pattern at cs and symmetrize x
        let dxi;
        for (let i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {
            dxi = (peaks[i].x - peaks[peaks.length - 1 - i].x) / 2.0;
            peaks[i].x = cs + dxi;
            peaks[peaks.length - 1 - i].x = cs - dxi;
        }
    }
    newSignal.symRank = symFactor;
    return newSignal;
}
/**
 * Error validator
 * @param {Number} value
 * @return {Number}
 * @private
 */
function error(value) {
    let maxError = value * 2.5;
    if (maxError < 0.75) {
        maxError = 0.75;
    }
    if (maxError > 3) {
        maxError = 3;
    }
    return maxError;
}
/**
 * @private
 * 2 stages normalizarion of the peaks heights to Math.pow(2,n).
 * Creates a new mask with the peaks that could contribute to the multiplete
 * @param {object} signal
 * @param {Number} n
 * @return {*}
 */
function normalize(signal, n) {
    // Perhaps this is slow
    let peaks = JSON.parse(JSON.stringify(signal.peaksComp));
    let norm = 0;
    let norm2 = 0;
    for (let peak of peaks) {
        norm += peak.intensity;
    }
    norm = Math.pow(2, n) / norm;
    signal.mask2 = signal.mask.slice();
    let index = signal.mask2.length - 1;
    for (let i = peaks.length - 1; i >= 0; i--) {
        peaks[i].intensity *= norm;
        while (index >= 0 && !signal.mask2[index]) {
            index--;
        }
        if (peaks[i].intensity < 0.75) {
            peaks.splice(i, 1);
            signal.mask2[index] = false;
        }
        else {
            norm2 += peaks[i].intensity;
        }
        index--;
    }
    norm2 = Math.pow(2, n) / norm2;
    for (let i = peaks.length - 1; i >= 0; i--) {
        peaks[i].intensity *= norm2;
    }
    return peaks;
}
/**
 * @private
 * Calculates the chemical shift as the weighted sum of the peaks
 * @param {Array} peaks
 * @param {Array} mask
 * @return {Number}
 */
function chemicalShift(peaks, mask = []) {
    let sum = 0;
    let cs = 0;
    let area;
    if (mask.length > 0) {
        for (let i = 0; i < peaks.length; i++) {
            if (mask[i]) {
                area = getArea(peaks[i]);
                sum += area;
                cs += area * peaks[i].x;
            }
        }
    }
    else {
        for (let peak of peaks) {
            area = getArea(peak);
            sum += area;
            cs += area * peak.x;
        }
    }
    return cs / sum;
}
/**
 * Return the area of a Lorentzian function
 * @param {object} peak - object with peak information
 * @return {Number}
 * @private
 */
function getArea(peak) {
    return Math.abs(peak.intensity * peak.width * 1.57); // 1.772453851);
}

},{}],509:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneArray = void 0;
const { stringify, parse } = JSON;
function cloneArray(data) {
    return parse(stringify(data));
}
exports.cloneArray = cloneArray;

},{}],510:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFrequency = void 0;
const gyromagnetic_ratio_1 = require("gyromagnetic-ratio");
/**
 * calculate the frequency of a nucleus with respect to a reference nucleus
 */
function getFrequency(
/**
 * nucleus to calculate the frequency
 */
nucleus, observedNucleusData) {
    const { nucleus: obsNucleus, frequency } = observedNucleusData;
    checkExistence(nucleus, obsNucleus);
    return ((frequency * gyromagnetic_ratio_1.gyromagneticRatio[nucleus]) /
        gyromagnetic_ratio_1.gyromagneticRatio[obsNucleus]);
}
exports.getFrequency = getFrequency;
function checkExistence(...nucleus) {
    let nuclei = [];
    for (const n of nucleus) {
        if (!(n in gyromagnetic_ratio_1.gyromagneticRatio)) {
            nuclei.push(n);
        }
    }
    if (nuclei.length !== 0) {
        throw new Error(`${nuclei.join(' , ')} is not supported`);
    }
}

},{"gyromagnetic-ratio":10}],511:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasProperty = void 0;
function hasProperty(data, key) {
    return key in data;
}
exports.hasProperty = hasProperty;

},{}],512:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinPatterns = void 0;
const couplingPatterns_1 = require("../constants/couplingPatterns");
const couplingValues_1 = require("../constants/couplingValues");
function joinPatterns(patterns) {
    const sum = patterns.reduce((sum, pattern) => {
        if (isNaN(couplingValues_1.couplingValues[pattern])) {
            throw new Error(`pattern ${pattern} is not in ${Object.keys(couplingValues_1.couplingValues).join(' ')}`);
        }
        return sum + couplingValues_1.couplingValues[pattern];
    }, 0);
    if (!couplingPatterns_1.couplingPatterns[sum]) {
        throw new Error("The joined pattern doesn't exist");
    }
    return couplingPatterns_1.couplingPatterns[sum];
}
exports.joinPatterns = joinPatterns;

},{"../constants/couplingPatterns":451,"../constants/couplingValues":452}],513:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangeFromSignal = void 0;
const couplingValues_1 = require("../constants/couplingValues");
function rangeFromSignal(signal, options) {
    const { nucleus = '1h', frequency = 400 } = options;
    const { tolerance = getTolerance(nucleus) / frequency } = options;
    let halfWidth = 0;
    const { js: jCouplings = [], multiplicity } = signal;
    if (jCouplings.length > 0) {
        for (const js of jCouplings) {
            const { coupling, multiplicity = 'd' } = js;
            halfWidth += (couplingValues_1.couplingValues[multiplicity] * coupling) / frequency;
        }
    }
    else if (multiplicity === 'm') {
        halfWidth = 16 / frequency;
    }
    else if (multiplicity === 'b' || multiplicity === 'br s') {
        halfWidth = 7 / frequency;
    }
    halfWidth = tolerance + halfWidth / 2;
    return {
        from: signal.delta - halfWidth,
        to: signal.delta + halfWidth,
    };
}
exports.rangeFromSignal = rangeFromSignal;
function getTolerance(nucleus) {
    switch (nucleus.toLocaleLowerCase()) {
        case '1h':
            return 1.5;
        case '13C':
            return 3;
        default:
            return 2;
    }
}

},{"../constants/couplingValues":452}],514:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resurrect = void 0;
const resurrectRange_1 = require("./resurrectRange");
const splitParenthesis_1 = require("./splitParenthesis");
function resurrect(acsString) {
    const data = {
        experiment: {},
        ranges: [],
        acsString,
        normalized: acsString
            .replace(/[\r\n\t]/g, ' ')
            .replace(/[;:]/g, ',')
            .replace(/\}/g, ')')
            .replace(/\{/g, '(')
            .replace(/[\u2011\u2012\u2013\u2014\u2015\u2212]/g, '-'),
    };
    createParts(data);
    parseParts(data);
    return data;
}
exports.resurrect = resurrect;
function parseParts(data) {
    for (const part of data.parts) {
        if (part.toLowerCase().includes('nmr')) {
            processExperiment(data, part);
        }
        else {
            const { frequency, nucleus } = data.experiment;
            const range = (0, resurrectRange_1.resurrectRange)(part, { frequency, nucleus });
            if (range)
                data.ranges.push(range);
        }
    }
}
function processExperiment(data, part) {
    const split = (0, splitParenthesis_1.splitParenthesis)(part);
    const before = split.before
        .replace(/[ -]*nmr[ -]*/i, '')
        .replace(/[ -]/g, '');
    if (/^[0-9]+[A-Z][a-z]?$/.exec(before)) {
        // 36Cl, 1H, 13C, ...
        data.experiment.nucleus = before;
    }
    if (/^[A-Z][a-z]?[0-9]+$/.exec(before)) {
        // Cl35, H1, C13, ...
        data.experiment.nucleus = before.replace(/^([A-Z][a-z]?)([0-9]+)$/, '$2$1');
    }
    if (split.inside) {
        // some frequency and solvent ???
        const insideParts = split.inside.split(/[,]/);
        const frequencyParts = insideParts.filter((part) => /[0-9]{2}/.exec(part));
        if (frequencyParts.length) {
            const frequency = frequencyParts[0].replace(/[^0-9]/g, '');
            if (frequency.length > 1)
                data.experiment.frequency = Number(frequency);
        }
        const solventParts = insideParts.filter((part) => !part.match(/[0-9]{2}/));
        if (solventParts.length) {
            data.experiment.solvent = solventParts[0];
        }
    }
}
function createParts(data) {
    const parts = data.normalized
        .split(/\)(?![^()]*\))/)
        .map((part) => part.replace(/^\s*(.*?)\s*$/, '$1'))
        .filter((part) => part)
        .map((part) => `${part})`)
        .map((part) => part.split(/[,;](?![^()]*\))/))
        .flat()
        .map((part) => part.replace(/^\s*(.*?)\s*$/, '$1'))
        .filter((part) => part);
    data.parts = parts;
}

},{"./resurrectRange":515,"./splitParenthesis":516}],515:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resurrectRange = void 0;
const rangeFromSignal_1 = require("./rangeFromSignal");
const splitParenthesis_1 = require("./splitParenthesis");
const splitPatterns_1 = require("./splitPatterns");
function resurrectRange(part, options = {}) {
    const { nucleus = '1h', frequency = 400 } = options;
    const split = (0, splitParenthesis_1.splitParenthesis)(part);
    if (!split.before)
        return;
    const beforeMatch = /.*?(?<from>-?[0-9.]+)-?(?<to>-?[0-9.]*).*/.exec(split.before);
    if (!beforeMatch || !beforeMatch.groups)
        return;
    const isARange = beforeMatch.groups.to !== '';
    const from = Number(beforeMatch.groups.from);
    const to = isARange ? Number(beforeMatch.groups.to) : from;
    const insideParts = split.inside.split(/ *, */);
    let signal = { delta: NaN, js: [] };
    let range = { from, to, signals: [signal] };
    const integrationParts = insideParts.filter((part) => part.match(/^[0-9]+H$/));
    if (integrationParts.length === 1) {
        range.integration = Number(integrationParts[0].replace('H', ''));
    }
    const multiplicityParts = insideParts.filter((part) => part.match(/^([br ]*)[a-zA-Z]+$/));
    if (multiplicityParts.length === 1) {
        const multiplicity = multiplicityParts[0];
        if (multiplicity === 'm') {
            if (isARange) {
                // a real range
                signal.delta = (from + to) / 2;
                signal.multiplicity = multiplicity;
            }
            else {
                // a complex signal
                signal.delta = from;
                signal.multiplicity = multiplicity;
            }
        }
        else if (!isARange) {
            // a complex signal
            signal.delta = from;
            signal.multiplicity = multiplicity;
        }
    }
    const jCouplings = insideParts
        .filter((part) => part.match(/(Hz|J|^[0-9.]+$)/))
        .map((jCoupling) => Number(jCoupling.replace(/[^0-9.]/g, '')));
    const multiplicities = (0, splitPatterns_1.splitPatterns)(signal.multiplicity || '');
    if (multiplicities.length === jCouplings.length) {
        for (let i = 0; i < multiplicities.length; i++) {
            if (!signal.js) {
                throw new Error('signal has not js');
            }
            signal.js.push({
                coupling: jCouplings[i],
                multiplicity: multiplicities[i],
            });
        }
    }
    if (range.from === range.to) {
        range = { ...range, ...(0, rangeFromSignal_1.rangeFromSignal)(signal, { nucleus, frequency }) };
    }
    return range;
}
exports.resurrectRange = resurrectRange;

},{"./rangeFromSignal":513,"./splitParenthesis":516,"./splitPatterns":517}],516:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitParenthesis = void 0;
function splitParenthesis(part) {
    const match = / *(?<before>[^(]*?) *\( *(?<inside>.*?) *\) *(?<after>.*?) */.exec(part);
    if (!match) {
        return { before: part, inside: '', after: '' };
    }
    return match.groups;
}
exports.splitParenthesis = splitParenthesis;

},{}],517:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitPatterns = void 0;
function splitPatterns(multiplet) {
    if (/^\s*$/.exec(multiplet))
        return [];
    let result = multiplet.match(/ *(quint|hex|sept|hept|oct|nona|non|s|d|t|q|h|o|n) */g);
    if (result)
        return result.map((entry) => entry.trim());
    return [multiplet];
}
exports.splitPatterns = splitPatterns;

},{}],518:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyAutoPeaksPicking = void 0;
const ml_gsd_1 = require("ml-gsd");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const convertWidthToHz_1 = require("../peaks/util/convertWidthToHz");
function xyAutoPeaksPicking(data, options) {
    const { from, to, frequency, noiseLevel, thresholdFactor = 3, minMaxRatio = 0.05, broadRatio = 0.00025, useSanPlot = false, smoothY = true, optimize = false, factorLimits = 4, realTopDetection = true, shape = { kind: 'gaussian' }, optimization = { kind: 'lm' }, broadWidth = 0.25, sgOptions = {}, direction = 'positive', } = options;
    let pointsPerHz = 1 / frequency / (data.x[1] - data.x[0]);
    // we can consider a peak with of 0.5 Hz for the windowSize
    let ws = Math.max(Math.round(pointsPerHz / 2), 5);
    const { windowSize = ws - (ws % 2) + 1, polynomial = 3 } = sgOptions;
    if (data.x.length < windowSize)
        return [];
    if (from !== undefined && to !== undefined) {
        data = (0, ml_spectra_processing_1.xyExtract)(data, { zones: [{ from, to }] });
    }
    const cutOff = getCutOff(data.y, { noiseLevel, useSanPlot, thresholdFactor });
    let getPeakOptions = {
        shape,
        frequency,
        broadWidth,
        optimize,
        factorLimits,
        maxCriteria: true,
        sgOptions: { windowSize, polynomial },
        minMaxRatio,
        broadRatio,
        noiseLevel: cutOff.positive,
        smoothY,
        optimization,
        realTopDetection,
    };
    switch (direction) {
        case 'positive': {
            return getPeakList(data, getPeakOptions);
        }
        case 'negative': {
            return getNegativePeaks(data, cutOff, getPeakOptions);
        }
        case 'both': {
            return [
                ...getPeakList(data, getPeakOptions),
                ...getNegativePeaks(data, cutOff, getPeakOptions),
            ];
        }
        default: {
            const unHandled = direction;
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw Error(`Unknown distribution ${unHandled}`);
        }
    }
}
exports.xyAutoPeaksPicking = xyAutoPeaksPicking;
function getNegativePeaks(data, cutOff, getPeakOptions) {
    getPeakOptions.noiseLevel = cutOff.negative;
    getPeakOptions.maxCriteria = false;
    return getPeakList(data, getPeakOptions);
}
function getPeakList(data, options) {
    const { shape, frequency, broadWidth, optimize, maxCriteria, factorLimits, sgOptions, minMaxRatio, broadRatio, noiseLevel, smoothY, optimization, realTopDetection, } = options;
    const peaks = (0, ml_gsd_1.gsd)(data, {
        sgOptions,
        maxCriteria,
        minMaxRatio,
        noiseLevel,
        smoothY,
        realTopDetection,
    });
    const peakList = (0, ml_gsd_1.setShape)(peaks, { output: peaks, shape });
    const newPeaks = broadWidth
        ? (0, ml_gsd_1.joinBroadPeaks)(peakList, {
            broadRatio,
            broadWidth,
            shape,
            optimization,
        }).map(toNMRPeak1DStructure)
        : peakList.map(toNMRPeak1DStructure);
    return (0, convertWidthToHz_1.convertWidthToHz)(optimize
        ? (0, ml_gsd_1.optimizePeaks)(data, newPeaks, {
            shape,
            factorLimits,
            optimization,
        }).map(toNMRPeak1DStructure)
        : newPeaks, { frequency });
}
function getCutOff(data, options) {
    const { noiseLevel, useSanPlot, thresholdFactor } = options;
    const formatResult = (noiseLevel) => typeof noiseLevel === 'number'
        ? { positive: noiseLevel, negative: -noiseLevel }
        : noiseLevel;
    if (noiseLevel) {
        return formatResult(noiseLevel);
    }
    else {
        return useSanPlot
            ? (0, ml_spectra_processing_1.xNoiseSanPlot)(data, { factorStd: thresholdFactor })
            : formatResult((0, ml_spectra_processing_1.xAbsoluteMedian)(data) * thresholdFactor);
    }
}
function toNMRPeak1DStructure(peak) {
    const { id, shape, x, y, width } = peak;
    return {
        id,
        x,
        y,
        width,
        shape,
    };
}

},{"../peaks/util/convertWidthToHz":465,"ml-gsd":167,"ml-spectra-processing":208}],519:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyAutoRangesPicking = void 0;
const peaksFilterImpurities_1 = require("../peaks/peaksFilterImpurities");
const peaksToRanges_1 = require("../peaks/peaksToRanges");
const xyAutoPeaksPicking_1 = require("./xyAutoPeaksPicking");
/**
 * Detect peaks, optimize parameters and compile multiplicity if required.
 */
function xyAutoRangesPicking(data, options) {
    let peaks = (0, xyAutoPeaksPicking_1.xyAutoPeaksPicking)(data, options.peakPicking);
    peaks = (0, peaksFilterImpurities_1.peaksFilterImpurities)(peaks, options.impurities);
    return (0, peaksToRanges_1.peaksToRanges)(data, peaks, options.ranges);
}
exports.xyAutoRangesPicking = xyAutoRangesPicking;

},{"../peaks/peaksFilterImpurities":459,"../peaks/peaksToRanges":460,"./xyAutoPeaksPicking":518}],520:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyPeaksOptimization = void 0;
const ml_gsd_1 = require("ml-gsd");
const convertWidthToHz_1 = require("../peaks/util/convertWidthToHz");
const convertWidthToPPM_1 = require("../peaks/util/convertWidthToPPM");
function xyPeaksOptimization(data, peaks, options) {
    const { frequency } = options;
    const newPeaks = (0, convertWidthToPPM_1.convertWidthToPPM)(peaks, { frequency });
    const optimizedPeaks = (0, ml_gsd_1.optimizePeaks)(data, newPeaks, options);
    const result = (0, convertWidthToHz_1.convertWidthToHz)(optimizedPeaks, {
        frequency,
        output: optimizedPeaks,
    });
    return result;
}
exports.xyPeaksOptimization = xyPeaksOptimization;

},{"../peaks/util/convertWidthToHz":465,"../peaks/util/convertWidthToPPM":466,"ml-gsd":167}],521:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatZones = void 0;
const uuid_1 = require("@lukeed/uuid");
function formatZones(signals) {
    let zones = [];
    for (const signal of signals) {
        let minMax1 = [Number.MAX_VALUE, 0];
        let minMax2 = [Number.MAX_VALUE, 0];
        for (const peak of signal.peaks || []) {
            if (peak.minX < minMax1[0]) {
                minMax1[0] = peak.minX;
            }
            if (peak.maxX > minMax1[1]) {
                minMax1[1] = peak.maxX;
            }
            if (peak.minY < minMax2[0]) {
                minMax2[0] = peak.minY;
            }
            if (peak.maxY > minMax2[1]) {
                minMax2[1] = peak.maxY;
            }
        }
        zones.push({
            id: (0, uuid_1.v4)(),
            x: {
                from: minMax1[0],
                to: minMax1[1],
            },
            y: {
                from: minMax2[0],
                to: minMax2[1],
            },
            signals: [signal],
        });
    }
    return zones;
}
exports.formatZones = formatZones;

},{"@lukeed/uuid":1}],522:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyzAutoZonesPicking = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_matrix_1 = require("ml-matrix");
const convolution = __importStar(require("ml-matrix-convolution"));
const matrixPeakFinders = __importStar(require("ml-matrix-peaks-finder"));
const ml_simple_clustering_1 = __importDefault(require("ml-simple-clustering"));
const addMissingIDs_1 = require("../peaks/util/addMissingIDs");
const determineRealTop_1 = require("../peaks/util/determineRealTop");
const getKernel_1 = require("../peaks/util/getKernel");
const PeakOptimizer = __importStar(require("../peaks/util/peakOptimizer"));
const formatZone_1 = require("./util/formatZone");
const smallFilter = [
    [0, 0, 1, 2, 2, 2, 1, 0, 0],
    [0, 1, 4, 7, 7, 7, 4, 1, 0],
    [1, 4, 5, 3, 0, 3, 5, 4, 1],
    [2, 7, 3, -12, -23, -12, 3, 7, 2],
    [2, 7, 0, -23, -40, -23, 0, 7, 2],
    [2, 7, 3, -12, -23, -12, 3, 7, 2],
    [1, 4, 5, 3, 0, 3, 5, 4, 1],
    [0, 1, 3, 7, 7, 7, 3, 1, 0],
    [0, 0, 1, 2, 2, 2, 1, 0, 0],
];
function xyzAutoZonesPicking(spectraData, options) {
    let { sizeToPad = 14, realTopDetection = true, thresholdFactor = 0.5, nuclei = ['1H', '1H'], observedFrequencies, enhanceSymmetry = false, clean = true, maxPercentCutOff = 0.03, tolerances = [24, 24], convolutionByFFT = true, kernel: kernelOptions, } = options;
    if (!Array.isArray(observedFrequencies) &&
        !ArrayBuffer.isView(observedFrequencies)) {
        throw new Error('observedFrequencies is mandatory');
    }
    thresholdFactor = thresholdFactor === 0 ? 1 : Math.abs(thresholdFactor);
    let nbPoints = spectraData.z[0].length;
    let nbSubSpectra = spectraData.z.length;
    if (nbSubSpectra < sizeToPad) {
        spectraData = padData(spectraData, { width: sizeToPad });
        nbPoints = spectraData.z[0].length;
        nbSubSpectra = spectraData.z.length;
    }
    let absoluteData = new Float64Array(nbPoints * nbSubSpectra);
    let originalData = new Float64Array(nbPoints * nbSubSpectra);
    for (let iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {
        let spectrum = spectraData.z[iSubSpectra];
        for (let iCol = 0; iCol < nbPoints; iCol++) {
            let index = iSubSpectra * nbPoints + iCol;
            absoluteData[index] = Math.abs(spectrum[iCol]);
            originalData[index] = spectrum[iCol]; //@todo pensar si se puede evitar originalData
        }
    }
    const kernel = kernelOptions ? (0, getKernel_1.getKernel)(kernelOptions) : smallFilter;
    let convolutedSpectrum = convolutionByFFT
        ? convolution.fft(absoluteData, kernel, {
            rows: nbSubSpectra,
            cols: nbPoints,
        })
        : convolution.direct(absoluteData, kernel, {
            rows: nbSubSpectra,
            cols: nbPoints,
        });
    let peaksMC1 = matrixPeakFinders.findPeaks2DRegion(absoluteData, {
        originalData,
        filteredData: convolutedSpectrum,
        rows: nbSubSpectra,
        cols: nbPoints,
        nStdDev: thresholdFactor,
    });
    if (clean) {
        // Remove peaks with less than x% of the intensity of the highest peak
        peaksMC1 = PeakOptimizer.clean(peaksMC1, maxPercentCutOff);
    }
    let signals = createSignals2D((0, addMissingIDs_1.addMissingIDs)(peaksMC1), {
        nRows: nbSubSpectra,
        nCols: nbPoints,
        minX: spectraData.minX,
        maxX: spectraData.maxX,
        minY: spectraData.minY,
        maxY: spectraData.maxY,
        absoluteData,
        originalData,
        tolerances,
        nuclei,
        observedFrequencies,
        realTopDetection,
    });
    if (enhanceSymmetry) {
        signals = PeakOptimizer.enhanceSymmetry(signals);
    }
    return (0, formatZone_1.formatZones)(signals);
}
exports.xyzAutoZonesPicking = xyzAutoZonesPicking;
function createSignals2D(peaks, options) {
    let { nCols, nRows, absoluteData, originalData, observedFrequencies, tolerances, nuclei, realTopDetection, minY, maxY, minX, maxX, } = options;
    let [nucleusX, nucleusY] = nuclei;
    let [toleranceX, toleranceY] = tolerances;
    let [observeFrequencyX, observeFrequencyY] = observedFrequencies;
    let dy = (maxY - minY) / (nRows - 1);
    let dx = (maxX - minX) / (nCols - 1);
    if (realTopDetection) {
        peaks = (0, determineRealTop_1.determineRealTop)(peaks, {
            nCols,
            absoluteData,
            originalData,
            minX,
            maxX,
            minY,
            maxY,
        });
    }
    for (let i = peaks.length - 1; i >= 0; i--) {
        let { x, y } = peaks[i];
        peaks[i].x = minX + dx * x;
        peaks[i].y = minY + dy * y;
        peaks[i].minX = minX + dx * peaks[i].minX;
        peaks[i].minY = minY + dy * peaks[i].minY;
        peaks[i].maxX = minX + dx * peaks[i].maxX;
        peaks[i].maxY = minY + dy * peaks[i].maxY;
        // Still having problems to correctly detect peaks on those areas. So I'm removing everything there.
    }
    // The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an
    // array like form
    let connectivity = [];
    for (let i = 0; i < peaks.length; i++) {
        for (let j = i; j < peaks.length; j++) {
            if (Math.abs(peaks[i].x - peaks[j].x) * observeFrequencyX < toleranceX &&
                Math.abs(peaks[i].y - peaks[j].y) * observeFrequencyY < toleranceY) {
                // 24*24Hz We cannot distinguish peaks with less than 20 Hz of separation
                connectivity.push(1);
            }
            else {
                connectivity.push(0);
            }
        }
    }
    let clusters = (0, ml_simple_clustering_1.default)(connectivity);
    let signals = [];
    if (clusters) {
        for (const cluster of clusters) {
            let signal = {
                id: (0, uuid_1.v4)(),
                x: {
                    delta: 0,
                    nucleus: nucleusX,
                    resolution: dx,
                },
                y: {
                    delta: 0,
                    nucleus: nucleusY,
                    resolution: dy,
                },
            };
            let peaks2D = [];
            let sumZ = 0;
            for (let jPeak = 0; jPeak < cluster.length; jPeak++) {
                if (cluster[jPeak] === 1) {
                    peaks2D.push(peaks[jPeak]);
                    signal.x.delta += peaks[jPeak].x * peaks[jPeak].z;
                    signal.y.delta += peaks[jPeak].y * peaks[jPeak].z;
                    sumZ += peaks[jPeak].z;
                }
            }
            signal.x.delta /= sumZ;
            signal.y.delta /= sumZ;
            signal.peaks = peaks2D;
            signals.push(signal);
        }
    }
    return signals;
}
function padData(spectraData, options) {
    let { minX, maxX, minY, maxY } = spectraData;
    const width = options.width;
    let nbPoints = spectraData.z[0].length;
    let nbSubSpectra = spectraData.z.length;
    let yInterval = (maxY - minY) / (nbSubSpectra - 1);
    let xInterval = (maxX - minX) / (nbPoints - 1);
    let yDiff = width - nbSubSpectra;
    let xDiff = Math.max(width - nbPoints, 0);
    if (xDiff % 2)
        xDiff++;
    if (yDiff % 2)
        yDiff++;
    let xOffset = xDiff / 2;
    let yOffset = yDiff / 2;
    let newMatrix = ml_matrix_1.Matrix.zeros(nbSubSpectra + yDiff, nbPoints + xDiff);
    for (let i = 0; i < nbSubSpectra; i++) {
        for (let j = 0; j < nbPoints; j++) {
            newMatrix.set(i + yOffset, j + xOffset, spectraData.z[i][j]);
        }
    }
    return {
        z: newMatrix.to2DArray(),
        minX: minX - xOffset * xInterval,
        maxX: maxX + xOffset * xInterval,
        minY: minY - yOffset * yInterval,
        maxY: maxY + yOffset * yInterval,
    };
}

},{"../peaks/util/addMissingIDs":463,"../peaks/util/determineRealTop":467,"../peaks/util/getKernel":468,"../peaks/util/peakOptimizer":469,"./util/formatZone":521,"@lukeed/uuid":1,"ml-matrix":186,"ml-matrix-convolution":184,"ml-matrix-peaks-finder":185,"ml-simple-clustering":199}],523:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyzJResAnalyzer = void 0;
const uuid_1 = require("@lukeed/uuid");
const ml_simple_clustering_1 = __importDefault(require("ml-simple-clustering"));
const addMissingIDs_1 = require("../peaks/util/addMissingIDs");
const jAnalyzer_1 = __importDefault(require("../signals/utils/jAnalyzer"));
const formatZone_1 = require("./util/formatZone");
const { parse, stringify } = JSON;
function xyzJResAnalyzer(signals, options = {}) {
    let { reference = 0, getZones = false, referenceMaxShiftError = 0.08, tolerances = [10, 100], nuclei = ['1H', '1H'], observedFrequencies = [400, 400], jAnalyzer = {
        jAxisKey: { jAxis: 'y', intensity: 'z' },
    }, } = options;
    let temporalSignals = compilePattern(signals, {
        observedFrequencies,
        tolerances,
        nuclei,
        jAnalyzer,
    });
    //check if the signal are symmetric around the reference
    let signals2D = [];
    for (const tempSignal of temporalSignals) {
        let delta = tempSignal.y.delta;
        if (Math.abs(delta - reference) > referenceMaxShiftError)
            continue;
        signals2D.push(tempSignal);
    }
    signals2D = (0, addMissingIDs_1.addMissingIDs)(signals2D);
    return getZones ? (0, formatZone_1.formatZones)(signals2D) : signals2D;
}
exports.xyzJResAnalyzer = xyzJResAnalyzer;
function compilePattern(signals, options) {
    let { observedFrequencies, tolerances, nuclei, jAnalyzer: jAnalyzerOptions, } = options;
    let signalOptions = {
        observedFrequencies,
        tolerances,
        nuclei,
        dx: signals[0].x.resolution,
        dy: signals[0].y.resolution,
    };
    const defaultWidth = 0.02 * observedFrequencies[0];
    const newSignals = parse(stringify(signals));
    //adapt to 1D jAnalyzer
    for (const signal of newSignals) {
        let peaks = signal.peaks;
        signal.nbPeaks = signal.peaks.length;
        signal.multiplicity = '';
        signal.pattern = '';
        signal.delta1 = signal.shiftY;
        signal.observe = observedFrequencies[1];
        signal.integralData = {
            from: Number.MAX_SAFE_INTEGER,
            to: Number.MIN_SAFE_INTEGER,
        };
        for (const peak of peaks) {
            if (!peak.width)
                peak.width = defaultWidth;
        }
        peaks.sort((a, b) => a.y - b.y);
    }
    for (let i = 0; i < signals.length; i++) {
        jAnalyzer_1.default.compilePattern(newSignals[i], jAnalyzerOptions);
        if (newSignals[i].maskPattern &&
            newSignals[i].multiplicity !== 'm' &&
            newSignals[i].multiplicity !== '') {
            // Create a new signal with the removed peaks
            let peaksO = [];
            for (let j = newSignals[i].maskPattern.length - 1; j >= 0; j--) {
                if (newSignals[i].maskPattern[j] === false) {
                    let peakR = newSignals[i].peaks.splice(j, 1)[0];
                    peaksO.push(peakR);
                    newSignals[i].mask.splice(j, 1);
                    newSignals[i].mask2.splice(j, 1);
                    newSignals[i].maskPattern.splice(j, 1);
                    newSignals[i].nbPeaks--;
                }
            }
            if (peaksO.length > 0) {
                peaksO.reverse();
                let signals2D = createSignals2D(peaksO, signalOptions);
                for (const signal of signals2D) {
                    newSignals.push(signal);
                }
            }
        }
    }
    signals.sort((a, b) => {
        return b.x.delta - a.x.delta;
    });
    return signals;
}
function createSignals2D(peaksInput, options) {
    let { observedFrequencies, tolerances, nuclei, dx, dy } = options;
    const peaks = parse(stringify(peaksInput));
    let [nucleusX, nucleusY] = nuclei;
    let [toleranceX, toleranceY] = tolerances;
    let [observeFrequencyX, observeFrequencyY] = observedFrequencies;
    // The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an
    // array like form
    let connectivity = [];
    for (let i = 0; i < peaks.length; i++) {
        for (let j = i; j < peaks.length; j++) {
            if (Math.abs(peaks[i].x - peaks[j].x) * observeFrequencyX < toleranceX &&
                Math.abs(peaks[i].y - peaks[j].y) * observeFrequencyY < toleranceY) {
                // 24*24Hz We cannot distinguish peaks with less than 20 Hz of separation
                connectivity.push(1);
            }
            else {
                connectivity.push(0);
            }
        }
    }
    let clusters = (0, ml_simple_clustering_1.default)(connectivity);
    let signals = [];
    if (clusters) {
        for (let cluster of clusters) {
            let signal = {
                id: (0, uuid_1.v4)(),
                nucleusX,
                nucleusY,
                integralData: {
                    from: Number.MAX_SAFE_INTEGER,
                    to: Number.MIN_SAFE_INTEGER,
                },
                nbPeaks: 0,
                multiplicity: '',
                pattern: '',
                observe: observeFrequencyY,
                resolutionX: dx,
                resolutionY: dy,
                shiftX: 0,
                shiftY: 0,
            };
            let peaks2D = [];
            let minMax1 = [Number.MAX_VALUE, 0];
            let minMax2 = [Number.MAX_VALUE, 0];
            let sumZ = 0;
            for (let jPeak = cluster.length - 1; jPeak >= 0; jPeak--) {
                if (cluster[jPeak] === 1) {
                    signal.nbPeaks++;
                    if (!peaks[jPeak].width)
                        peaks[jPeak].width = 0.02;
                    peaks2D.push(peaks[jPeak]);
                    signal.shiftX += peaks[jPeak].x * peaks[jPeak].z;
                    signal.shiftY += peaks[jPeak].y * peaks[jPeak].z;
                    sumZ += peaks[jPeak].z;
                    if (peaks[jPeak].minX < minMax1[0]) {
                        minMax1[0] = peaks[jPeak].minX;
                    }
                    if (peaks[jPeak].maxX > minMax1[1]) {
                        minMax1[1] = peaks[jPeak].maxX;
                    }
                    if (peaks[jPeak].minY < minMax2[0]) {
                        minMax2[0] = peaks[jPeak].minY;
                    }
                    if (peaks[jPeak].maxY > minMax2[1]) {
                        minMax2[1] = peaks[jPeak].maxY;
                    }
                }
            }
            signal.fromTo = [
                { from: minMax1[0], to: minMax1[1] },
                { from: minMax2[0], to: minMax2[1] },
            ];
            signal.shiftX /= sumZ;
            signal.shiftY /= sumZ;
            signal.delta1 = signal.shiftY;
            signal.peaks = peaks2D;
            signals.push(signal);
        }
    }
    return signals;
}

},{"../peaks/util/addMissingIDs":463,"../signals/utils/jAnalyzer":508,"./util/formatZone":521,"@lukeed/uuid":1,"ml-simple-clustering":199}],524:[function(require,module,exports){
'use strict';

function assertNumber(number) {
	if (typeof number !== 'number') {
		throw new TypeError('Expected a number');
	}
}

exports.ascending = (left, right) => {
	assertNumber(left);
	assertNumber(right);

	if (Number.isNaN(left)) {
		return -1;
	}

	if (Number.isNaN(right)) {
		return 1;
	}

	return left - right;
};

exports.descending = (left, right) => {
	assertNumber(left);
	assertNumber(right);

	if (Number.isNaN(left)) {
		return 1;
	}

	if (Number.isNaN(right)) {
		return -1;
	}

	return right - left;
};

},{}],525:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var mlFloydWarshall = require('ml-floyd-warshall');
var mlMatrix = require('ml-matrix');
var atomSorter = require('atom-sorter');
var ensureString = require('ensure-string');
var Papa = require('papaparse');
var sdfParser = require('sdf-parser');

let xAtomicNumber = 0;

/**
 * Tag an atom to be able to visualize it
 * @param {import('openchemlib').Molecule} molecule
 * @param {number} iAtom
 */
function tagAtom(molecule, iAtom) {
  let customLabel = `${molecule.getAtomLabel(iAtom)}*`;
  molecule.setAtomCustomLabel(iAtom, customLabel);
  if (molecule.getAtomicNo(iAtom) === 1) {
    molecule.setAtomicNo(iAtom, getXAtomicNumber(molecule));
  } else {
    // we can not use X because we would have problems with valencies if it is
    // expanded hydrogens or not
    // we can not only use a custom label because it does not count for the canonisation
    molecule.setAtomMass(iAtom, molecule.getAtomMass(iAtom) + 5);
  }
  return customLabel;
}

function getXAtomicNumber(molecule) {
  if (!xAtomicNumber) {
    const OCL = molecule.getOCL();
    xAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(
      'X',
      OCL.Molecule.cPseudoAtomX,
    );
  }
  return xAtomicNumber;
}

/**
 * Add either missing chirality of diastereotopic missing chirality
 * The problem is that sometimes we need to add chiral bond that was not planned because it is the same group
 * This is the case for example for the valine where the 2 C of the methyl groups are diastereotopic
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} [options={}]
 * @param {number} [options.esrType=cESRTypeAnd]
 */
function addDiastereotopicMissingChirality(molecule, options = {}) {
  const { Molecule } = molecule.getOCL();
  const { esrType = Molecule.cESRTypeAnd } = options;

  for (let iAtom = 0; iAtom < molecule.getAllAtoms(); iAtom++) {
    let tempMolecule = molecule.getCompactCopy();
    tagAtom(tempMolecule, iAtom);
    // After copy, helpers must be recalculated
    tempMolecule.ensureHelperArrays(Molecule.cHelperBitsStereo);
    // We need to have >0 and not >1 because there could be unspecified chirality in racemate

    for (let i = 0; i < tempMolecule.getAtoms(); i++) {
      // changed from from handling below; TLS 9.Nov.2015
      if (
        tempMolecule.isAtomStereoCenter(i) &&
        tempMolecule.getStereoBond(i) === -1
      ) {
        let stereoBond = tempMolecule.getAtomPreferredStereoBond(i);
        if (stereoBond !== -1) {
          molecule.setBondType(stereoBond, Molecule.cBondTypeUp);
          if (molecule.getBondAtom(1, stereoBond) === i) {
            let connAtom = molecule.getBondAtom(0, stereoBond);
            molecule.setBondAtom(0, stereoBond, i);
            molecule.setBondAtom(1, stereoBond, connAtom);
          }
          // To me it seems that we have to add all stereo centers into AND group 0. TLS 9.Nov.2015
          molecule.setAtomESR(i, esrType, 0);
        }
      }
    }
  }
}

/**
 *
 * @param {import('openchemlib').Molecule} [molecule] An instance of a molecule
 * @param {object} [options={}]
 * @param {object} [options.OCL] openchemlib library
 */
function makeRacemic(molecule) {
  const { Molecule } = molecule.getOCL();

  // if we don't calculate this we have 2 epimers
  molecule.ensureHelperArrays(Molecule.cHelperCIP);

  // we need to make one group "AND" for chiral (to force to racemic, this means diastereotopic and not enantiotopic)
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomParity(i) !== Molecule.cAtomParityNone) {
      molecule.setAtomESR(i, Molecule.cESRTypeAnd, 0); // changed to group 0; TLS 9.Nov.2015
    }
  }
}

/**
 * Returns an array of diastereotopic ID (as oclCode)
 * @param {import('openchemlib').Molecule} molecule
 */
function getDiastereotopicAtomIDs(molecule) {
  const OCL = molecule.getOCL();
  addDiastereotopicMissingChirality(molecule);

  let numberAtoms = molecule.getAllAtoms();
  let ids = [];
  for (let iAtom = 0; iAtom < numberAtoms; iAtom++) {
    let tempMolecule = molecule.getCompactCopy();
    tagAtom(tempMolecule, iAtom);
    makeRacemic(tempMolecule);
    // We need to ensure the helper array in order to get correctly the result of racemisation
    ids[iAtom] = tempMolecule.getCanonizedIDCode(
      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
    );
  }
  return ids;
}

/**
 *
 * @param {import('openchemlib').Molecule} molecule
 */
function getDiastereotopicAtomIDsAndH(molecule) {
  const OCL = molecule.getOCL();
  molecule = molecule.getCompactCopy();
  molecule.addImplicitHydrogens();
  // TODO Temporary code ???
  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);

  const diaIDs = getDiastereotopicAtomIDs(molecule);
  const newDiaIDs = [];

  for (let i = 0; i < diaIDs.length; i++) {
    const diaID = diaIDs[i];
    const newDiaID = {
      oclID: diaID,
      hydrogenOCLIDs: [],
      nbHydrogens: 0,
    };
    if (molecule.getAtomicNo(i) === 1) {
      const atom = molecule.getConnAtom(i, 0);
      newDiaID.heavyAtom = diaIDs[atom];
    }
    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {
      const atom = molecule.getConnAtom(i, j);
      if (molecule.getAtomicNo(atom) === 1) {
        newDiaID.nbHydrogens++;
        if (newDiaID.hydrogenOCLIDs.indexOf(diaIDs[atom]) === -1) {
          newDiaID.hydrogenOCLIDs.push(diaIDs[atom]);
        }
      }
    }

    newDiaIDs.push(newDiaID);
  }

  return newDiaIDs;
}

/**
 * Returns a SVG
 * @param {*} molecule
 * @param {*} [options={}]
 */
function toDiastereotopicSVG(molecule, options = {}) {
  let {
    width = 300,
    height = 200,
    prefix = 'ocl',
    heavyAtomHydrogen = false,
  } = options;
  let svg = options.svg;
  let diaIDs = [];

  let hydrogenInfo = {};
  getDiastereotopicAtomIDsAndH(molecule).forEach((line) => {
    hydrogenInfo[line.oclID] = line;
  });

  if (heavyAtomHydrogen) {
    for (let i = 0; i < molecule.getAtoms(); i++) {
      diaIDs.push([]);
    }
    let groupedDiaIDs = molecule.getGroupedDiastereotopicAtomIDs();
    groupedDiaIDs.forEach((diaID) => {
      if (
        hydrogenInfo[diaID.oclID] &&
        hydrogenInfo[diaID.oclID].nbHydrogens > 0
      ) {
        diaID.atoms.forEach((atom) => {
          hydrogenInfo[diaID.oclID].hydrogenOCLIDs.forEach((id) => {
            if (!diaIDs[atom * 1].includes(id)) diaIDs[atom].push(id);
          });
        });
      }
    });
  } else {
    diaIDs = molecule.getDiastereotopicAtomIDs().map((a) => [a]);
  }

  if (!svg) svg = molecule.toSVG(width, height, prefix);

  svg = svg.replace(/Atom:[0-9]+"/g, (value) => {
    let atom = value.replace(/[^0-9]/g, '');
    return `${value} data-diaid="${diaIDs[atom].join(',')}"`;
  });

  return svg;
}

function groupDiastereotopicAtomIDs(diaIDs, molecule, options = {}) {
  const { atomLabel } = options;
  const diaIDsObject = {};
  for (let i = 0; i < diaIDs.length; i++) {
    if (!atomLabel || molecule.getAtomLabel(i) === atomLabel) {
      let diaID = diaIDs[i];
      if (!diaIDsObject[diaID]) {
        diaIDsObject[diaID] = {
          counter: 0,
          atoms: [],
          oclID: diaID,
          atomLabel: molecule.getAtomLabel(i),
        };
      }
      diaIDsObject[diaID].counter++;
      diaIDsObject[diaID].atoms.push(i);
    }
  }

  return Object.keys(diaIDsObject).map((key) => diaIDsObject[key]);
}

/**
 * This function groups the diasterotopic atomIds of the molecule based on equivalence of atoms. The output object contains
 * a set of chemically equivalent atoms(element.atoms) and the groups of magnetically equivalent atoms (element.magneticGroups)
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [options.atomLabel] Select atoms of the given atomLabel. By default it returns all the explicit atoms in the molecule
 * @returns {Array}
 */

function getGroupedDiastereotopicAtomIDs(molecule, options = {}) {
  let diaIDs = getDiastereotopicAtomIDs(molecule);
  return groupDiastereotopicAtomIDs(diaIDs, molecule, options);
}

/**
 * Parse a molfile and returns an object containing the molecule, the map and the diaIDs
 * The map allows to reload properties assigned to the atom molfile
 * Pelase take care than numbering of atoms starts at 0 !
 * @param {import('openchemlib')} OCL - openchemlib library
 * @param {string} molfile
 * @returns
 */
function getDiastereotopicAtomIDsFromMolfile(OCL, molfile) {
  const { map, molecule } = OCL.Molecule.fromMolfileWithAtomMap(molfile);

  const diaIDsArray = getDiastereotopicAtomIDsAndH(molecule);
  const diaIDs = {};

  for (let i = 0; i < map.length; i++) {
    diaIDs[map[i]] = { source: map[i], destination: i, ...diaIDsArray[i] };
  }

  return { map: diaIDs, molecule, diaIDs: diaIDsArray };
}

/**
 * Check if a specific atom is a sp3 carbon
 * @param {import('openchemlib').Molecule} molecule
 * @param {number} atomID
 */

function isCsp3(molecule, atomID) {
  if (molecule.getAtomicNo(atomID) !== 6) return false;
  if (molecule.getAtomCharge(atomID) !== 0) return false;
  if (
    molecule.getImplicitHydrogens(atomID) + molecule.getConnAtoms(atomID) !==
    4
  ) {
    return false;
  }
  return true;
}

const FULL_HOSE_CODE = 1;
const HOSE_CODE_CUT_C_SP3_SP3 = 2;

/**
 * Returns the hose code for a specific atom number
 * @param {import('openchemlib').Molecule} originalMolecule - The OCL molecule to be fragmented
 * @param {number[]} rootAtoms
 * @param {object} [options={}]
 * @param {boolean} [options.isTagged] Specify is the atoms are already tagged
 * @param {number} [options.minSphereSize=0] Smallest hose code sphere
 * @param {number} [options.maxSphereSize=4] Largest hose code sphere
 * @param {number} [options.kind=FULL_HOSE_CODE] Kind of hose code, default usual sphere
 */
function getHoseCodesForAtoms(
  originalMolecule,
  rootAtoms = [],
  options = {},
) {
  const OCL = originalMolecule.getOCL();
  const {
    minSphereSize = 0,
    maxSphereSize = 4,
    kind = FULL_HOSE_CODE,
    isTagged = false,
  } = options;

  const molecule = originalMolecule.getCompactCopy();

  if (!isTagged) {
    const tags = [];
    for (let i = 0; i < rootAtoms.length; i++) {
      let rootAtom = rootAtoms[i];
      tags.push(tagAtom(molecule, rootAtom));
      molecule.addImplicitHydrogens();
      molecule.addMissingChirality();
      molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);
      // because ensuring helper reorder atoms we need to look again for it
    }
    rootAtoms.length = 0;
    for (let j = 0; j < molecule.getAllAtoms(); j++) {
      if (tags.includes(molecule.getAtomCustomLabel(j))) {
        rootAtoms.push(j);
      }
    }
  }

  let fragment = new OCL.Molecule(0, 0);
  let results = [];
  let min = 0;
  let max = 0;
  let atomMask = new Array(molecule.getAllAtoms());
  let atomList = new Array(molecule.getAllAtoms());

  for (let sphere = 0; sphere <= maxSphereSize; sphere++) {
    if (max === 0) {
      for (let rootAtom of rootAtoms) {
        atomList[max] = rootAtom;
        atomMask[rootAtom] = true;
        max++;
      }
    } else {
      let newMax = max;
      for (let i = min; i < max; i++) {
        let atom = atomList[i];
        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {
          let connAtom = molecule.getConnAtom(atom, j);
          if (!atomMask[connAtom]) {
            switch (kind) {
              case FULL_HOSE_CODE:
                atomMask[connAtom] = true;
                atomList[newMax++] = connAtom;
                break;
              case HOSE_CODE_CUT_C_SP3_SP3:
                if (!(isCsp3(molecule, atom) && isCsp3(molecule, connAtom))) {
                  atomMask[connAtom] = true;
                  atomList[newMax++] = connAtom;
                }
                break;
              default:
                throw new Error('getHoseCoesForAtom unknown kind');
            }
          }
        }
      }
      min = max;
      max = newMax;
    }
    molecule.copyMoleculeByAtoms(fragment, atomMask, true, null);
    if (sphere >= minSphereSize) {
      makeRacemic(fragment);
      results.push(
        fragment.getCanonizedIDCode(
          OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
        ),
      );
    }
  }
  return results;
}

/**
 * Returns the hose code for a specific atom number
 * @param {import('openchemlib').Molecule} originalMolecule
 * @param {number} rootAtom
 * @param {object} [options={}]
 * @param {boolean} [options.isTagged] Specify is the atom is already tagged
 * @param {number} [options.minSphereSize=0] Smallest hose code sphere
 * @param {number} [options.maxSphereSize=4] Largest hose code sphere
 * @param {number} [options.kind=FULL_HOSE_CODE] Kind of hose code, default usual sphere
 */
function getHoseCodesForAtom(originalMolecule, rootAtom, options = {}) {
  return getHoseCodesForAtoms(originalMolecule, [rootAtom], options);
}

/**
 * Returns the hose code for a specific marked atom
 * @param {import('openchemlib').Molecule} diastereotopicID
 * @param {object} options
 */

function getHoseCodesFromDiastereotopicID(molecule, options = {}) {
  molecule.addImplicitHydrogens();
  molecule.addMissingChirality();

  // One of the atom has to be marked !
  let atomID = -1;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    // we need to find the marked atom
    const atomCustomLabel = molecule.getAtomCustomLabel(i);
    if (atomCustomLabel != null && atomCustomLabel.endsWith('*')) {
      atomID = i;
      break;
    }
  }
  if (atomID >= 0) {
    options.isTagged = true;
    return getHoseCodesForAtom(molecule, atomID, options);
  }
  return undefined;
}

/**
 * Returns an array containing one entry per atom containing
 * diaID and hose code
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} options
 */

function getHoseCodesAndDiastereotopicIDs(molecule, options) {
  const diaIDs = getDiastereotopicAtomIDs(molecule).map((oclID) => ({
    oclID,
  }));
  const OCL = molecule.getOCL();
  // TODO: seems like a very slow approach
  diaIDs.forEach((diaID) => {
    const hoses = getHoseCodesFromDiastereotopicID(
      OCL.Molecule.fromIDCode(diaID.oclID),
      options,
    );
    diaID.hoses = [];
    let sphere = 0;
    for (const hose of hoses) {
      diaID.hoses.push({
        sphere: sphere++,
        oclID: hose,
      });
    }
  });
  return diaIDs;
}

let fragment$1;

/**
 * Returns the hose code for a specific atom number
 * @param {import('openchemlib').Molecule} molecule
 */
function getHoseCodesForPath(molecule, from, to, maxLength) {
  const OCL = molecule.getOCL();
  const originalFrom = from;
  const originalTo = to;
  molecule = molecule.getCompactCopy();

  let originalAtoms = []; // path before renumbering
  molecule.getPath(originalAtoms, from, to, maxLength + 1);
  let torsion;
  if (originalAtoms.length === 4) {
    torsion = molecule.calculateTorsion(originalAtoms);
  }

  const tag1 = tagAtom(molecule, from);
  const tag2 = tagAtom(molecule, to);

  molecule.addImplicitHydrogens();
  molecule.addMissingChirality();

  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);

  from = -1;
  to = -1;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (tag1 === tag2) {
      if (molecule.getAtomCustomLabel(i) === tag1) {
        if (from === -1) {
          from = i;
        } else {
          to = i;
        }
      }
    } else {
      if (tag1 === molecule.getAtomCustomLabel(i)) {
        from = i;
      }
      if (tag2 === molecule.getAtomCustomLabel(i)) {
        to = i;
      }
    }
  }

  if (!fragment$1) fragment$1 = new OCL.Molecule(0, 0);

  let atoms = [];
  molecule.getPath(atoms, from, to, maxLength + 1);

  let min = 0;
  let max = 0;
  let atomMask = new Array(molecule.getAllAtoms()).fill(false);
  let atomList = new Array(molecule.getAllAtoms()).fill(-1);
  let hoses = [];

  for (let sphere = 0; sphere <= 2; sphere++) {
    if (max === 0) {
      for (let atom of atoms) {
        atomMask[atom] = true;
        atomList[max++] = atom;
      }
    } else {
      let newMax = max;
      for (let i = min; i < max; i++) {
        let atom = atomList[i];
        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {
          let connAtom = molecule.getConnAtom(atom, j);
          if (!atomMask[connAtom]) {
            atomMask[connAtom] = true;
            atomList[newMax++] = connAtom;
          }
        }
      }
      min = max;
      max = newMax;
    }
    let atomMap = [];

    molecule.copyMoleculeByAtoms(fragment$1, atomMask, true, atomMap);
    makeRacemic(fragment$1);
    let oclID = fragment$1.getCanonizedIDCode(
      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
    );

    hoses.push({
      sphere,
      oclID,
    });
  }

  return {
    atoms: originalAtoms,
    from: originalFrom,
    to: originalTo,
    torsion,
    hoses,
    length: originalAtoms.length - 1,
  };
}

const MAX_R = 10;

/**
 * Generate molecules and calcule predicted properties form a list of smiles and fragments
 * @param {string} [coreSmiles]
 * @param {array} [fragments] Array of {smiles,R1,R2,...}
 * @param {import('openchemlib')} OCL - openchemlib library
 * @param {object} [options={}]
 * @param {function} [options.onStep] method to execute each new molecules
 * @param {boolean} [options.complexity] returns only the number of molecules to evaluate
 * @return {Promise} promise that resolves to molecules or complexity as a number
 */
async function combineSmiles(coreSmiles, fragments, OCL, options = {}) {
  const { complexity = false } = options;
  const core = getCore(coreSmiles);
  const rGroups = getRGroups(core, fragments);
  if (complexity) {
    return getComplexity(rGroups);
  }
  return generate(core, rGroups, OCL, options);
}

function getComplexity(rGroups) {
  let complexity = 1;
  for (let rGroup of rGroups) {
    complexity *= rGroup.smiles.length;
  }
  return complexity;
}

async function generate(core, rGroups, OCL, options = {}) {
  const { onStep } = options;
  const molecules = {};
  const sizes = new Array(rGroups.length);
  const currents = new Array(rGroups.length);
  for (let i = 0; i < rGroups.length; i++) {
    sizes[i] = rGroups[i].smiles.length - 1;
    currents[i] = 0;
  }
  let position = 0;
  let counter = 0;

  while (true) {
    counter++;
    while (position < currents.length) {
      if (currents[position] < sizes[position]) {
        if (onStep) {
          await onStep(counter);
        }
        appendMolecule(molecules, core, rGroups, currents, OCL);
        currents[position]++;
        for (let i = 0; i < position; i++) {
          currents[i] = 0;
        }
        position = 0;
      } else {
        position++;
      }
    }
    if ((position = currents.length)) {
      if (onStep) {
        await onStep(counter);
      }
      appendMolecule(molecules, core, rGroups, currents, OCL);
      break;
    }
  }
  return Object.keys(molecules)
    .map((key) => molecules[key])
    .sort((m1, m2) => m1.mw - m2.mw);
}

function appendMolecule(molecules, core, rGroups, currents, OCL) {
  let newSmiles = core.smiles;
  for (let i = 0; i < currents.length; i++) {
    newSmiles += `.${rGroups[i].smiles[currents[i]]}`;
  }

  const currentMol = OCL.Molecule.fromSmiles(newSmiles);
  const idCode = currentMol.getIDCode();

  if (!molecules[idCode]) {
    let molecule = {};
    molecules[idCode] = molecule;
    molecule.smiles = currentMol.toSmiles();
    molecule.combinedSmiles = newSmiles;
    molecule.idCode = idCode;
    molecule.molfile = currentMol.toMolfile();

    const props = new OCL.MoleculeProperties(currentMol);
    molecule.nbHAcceptor = props.acceptorCount;
    molecule.nbHDonor = props.donorCount;
    molecule.logP = props.logP;
    molecule.logS = props.logS;
    molecule.PSA = props.polarSurfaceArea;
    molecule.nbRottable = props.rotatableBondCount;
    molecule.nbStereoCenter = props.stereoCenterCount;
    let mf = currentMol.getMolecularFormula();
    molecule.mf = mf.formula;
    molecule.mw = mf.relativeWeight;
  }
}

function getCore(coreSmiles) {
  let core = {
    originalSmiles: coreSmiles,
    smiles: coreSmiles.replace(/\[R(?<group>[1-4])\]/g, '%5$<group>'),
  };

  for (let i = 0; i < MAX_R; i++) {
    if (core.originalSmiles.indexOf(`[R${i}]`) > -1) core[`R${i}`] = true;
  }
  return core;
}

function getRGroups(core, fragments) {
  let rGroups = {};
  for (const fragment of fragments) {
    if (fragment.smiles) {
      const smiles = updateRPosition(fragment.smiles);
      for (let i = 0; i < MAX_R; i++) {
        if (core[`R${i}`]) {
          // we only consider the R that are in the core
          if (fragment[`R${i}`]) {
            if (!rGroups[`R${i}`]) {
              rGroups[`R${i}`] = {
                group: `R${i}`,
                smiles: [],
              };
            }
            rGroups[`R${i}`].smiles.push(smiles.replace(/\[R\]/, `(%5${i})`));
          }
        }
      }
    }
  }
  return Object.keys(rGroups).map((key) => rGroups[key]);
}

function updateRPosition(smiles) {
  // R group should not be at the beginning
  if (smiles.indexOf('[R]') !== 0) return smiles;
  if (smiles.length === 3) return '[H][R]';
  // we are in trouble ... we need to move the R
  let newSmiles = smiles.replace('[R]', '');
  // we need to check where we should put the R group
  let level = 0;
  for (let j = 0; j < newSmiles.length; j++) {
    let currentChar = newSmiles.charAt(j);
    let currentSubstring = newSmiles.substr(j);
    if (currentChar === '(') {
      level++;
    } else if (currentChar === ')') {
      level--;
    } else if (level === 0) {
      if (currentSubstring.match(/^[a-z]/)) {
        return `${newSmiles.substr(0, j + 1)}([R])${newSmiles.substr(j + 1)}`;
      } else if (currentSubstring.match(/^[A-Z][a-z]/)) {
        return `${newSmiles.substr(0, j + 2)}([R])${newSmiles.substr(j + 2)}`;
      } else if (currentSubstring.match(/^[A-Z]/)) {
        return `${newSmiles.substr(0, j + 1)}([R])${newSmiles.substr(j + 1)}`;
      }
    }
  }
  return smiles;
}

/**
 * Returns various information about atoms in the molecule
 * @param {import('openchemlib').Molecule} [molecule]
 */
function getAtomsInfo(molecule) {
  const OCL = molecule.getOCL();
  molecule.ensureHelperArrays(OCL.Molecule.cHelperRings);

  let diaIDs = getDiastereotopicAtomIDs(molecule);

  let results = [];
  for (let i = 0; i < diaIDs.length; i++) {
    let result = {
      oclID: diaIDs[i],
      extra: {
        singleBonds: 0,
        doubleBonds: 0,
        tripleBonds: 0,
        aromaticBonds: 0,
        cnoHybridation: 0, // should be 1 (sp), 2 (sp2) or 3 (sp3)
      },
    };
    let extra = result.extra;
    results.push(result);
    result.abnormalValence = molecule.getAtomAbnormalValence(i); // -1 is normal otherwise specified
    result.charge = molecule.getAtomCharge(i);
    result.cipParity = molecule.getAtomCIPParity(i);
    result.color = molecule.getAtomColor(i);
    result.customLabel = molecule.getAtomCustomLabel(i);
    //        result.esrGroup=molecule.getAtomESRGroup(i);
    //        result.esrType=molecule.getAtomESRType(i);
    result.atomicNo = molecule.getAtomicNo(i);
    result.label = molecule.getAtomLabel(i);
    //        result.list=molecule.getAtomList(i);
    //        result.listString=molecule.getAtomListString(i);
    //        result.mapNo=molecule.getAtomMapNo(i);
    result.mass = molecule.getAtomMass(i);
    //        result.parity=molecule.getAtomParity(i);
    //        result.pi=molecule.getAtomPi(i);
    //        result.preferredStereoBond=molecule.getAtomPreferredStereoBond(i);
    //        result.queryFeatures=molecule.getAtomQueryFeatures(i);
    result.radical = molecule.getAtomRadical(i);
    result.ringBondCount = molecule.getAtomRingBondCount(i);
    //        result.ringCount=molecule.getAtomRingCount(i);
    result.ringSize = molecule.getAtomRingSize(i);
    result.x = molecule.getAtomX(i);
    result.y = molecule.getAtomY(i);
    result.z = molecule.getAtomZ(i);
    result.allHydrogens = molecule.getAllHydrogens(i);
    result.connAtoms = molecule.getConnAtoms(i);
    result.allConnAtoms = molecule.getAllConnAtoms(i);

    result.implicitHydrogens =
      result.allHydrogens + result.connAtoms - result.allConnAtoms;

    result.isAromatic = molecule.isAromaticAtom(i);
    result.isAllylic = molecule.isAllylicAtom(i);
    result.isStereoCenter = molecule.isAtomStereoCenter(i);
    result.isRing = molecule.isRingAtom(i);
    result.isSmallRing = molecule.isSmallRingAtom(i);
    result.isStabilized = molecule.isStabilizedAtom(i);

    // todo HACK to circumvent bug in OCL that consider than an hydrogen is connected to itself
    result.extra.singleBonds =
      result.atomicNo === 1 ? 0 : result.implicitHydrogens;
    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {
      let bond = molecule.getConnBond(i, j);
      let bondOrder = molecule.getBondOrder(bond);
      if (molecule.isAromaticBond(bond)) {
        extra.aromaticBonds++;
      } else if (bondOrder === 1) {
        // not an hydrogen
        extra.singleBonds++;
      } else if (bondOrder === 2) {
        extra.doubleBonds++;
      } else if (bondOrder === 3) {
        extra.tripleBonds++;
      }
    }
    result.extra.totalBonds =
      result.extra.singleBonds +
      result.extra.doubleBonds +
      result.extra.tripleBonds +
      result.extra.aromaticBonds;

    if (result.atomicNo === 6) {
      result.extra.cnoHybridation = result.extra.totalBonds - 1;
    } else if (result.atomicNo === 7) {
      result.extra.cnoHybridation = result.extra.totalBonds;
    } else if (result.atomicNo === 8) {
      result.extra.cnoHybridation = result.extra.totalBonds + 1;
    } else if (result.atomicNo === 1) {
      let connectedAtom =
        molecule.getAllConnAtoms(i) === 0
          ? 0
          : molecule.getAtomicNo(molecule.getConnAtom(i, 0));
      result.extra.hydrogenOnAtomicNo = connectedAtom;
      if (connectedAtom === 7 || connectedAtom === 8) {
        result.extra.labileHydrogen = true;
      }
    }
  }
  return results;
}

/**
 * Returns a connectivity matrix
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} [options={}]
 * @param {boolean} [options.pathLength=false] get the path length between atoms
 * @param {boolean} [options.mass=false] set the nominal mass of the atoms on diagonal
 * @param {boolean} [options.atomicNo=false] set the atomic number of the atom on diagonal
 * @param {boolean} [options.negativeAtomicNo=false] set the atomic number * -1 of the atom on diagonal
 * @param {boolean} [options.sdt=false] set 1, 2 or 3 depending if single, double or triple bond
 * @param {boolean} [options.sdta=false] set 1, 2, 3 or 4 depending if single, double, triple or aromatic  bond
 */
function getConnectivityMatrix(molecule, options = {}) {
  const OCL = molecule.getOCL();
  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);
  let nbAtoms = molecule.getAllAtoms();

  let result = new Array(nbAtoms).fill();
  result = result.map(() => new Array(nbAtoms).fill(0));

  if (!options.pathLength) {
    if (options.atomicNo) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = molecule.getAtomicNo(i);
      }
    } else if (options.negativeAtomicNo) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = -molecule.getAtomicNo(i);
      }
    } else if (options.mass) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = OCL.Molecule.cRoundedMass[molecule.getAtomicNo(i)];
      }
    } else {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = 1;
      }
    }
  }

  if (options.sdt) {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        result[i][molecule.getConnAtom(i, j)] = molecule.getConnBondOrder(i, j);
      }
    }
  } else if (options.sdta) {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        let bondNumber = molecule.getConnBond(i, j);
        if (molecule.isAromaticBond(bondNumber)) {
          result[i][molecule.getConnAtom(i, j)] = 4;
        } else {
          result[i][molecule.getConnAtom(i, j)] = molecule.getConnBondOrder(
            i,
            j,
          );
        }
      }
    }
  } else {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        result[i][molecule.getConnAtom(i, j)] = 1;
      }
    }
  }

  if (options.pathLength) {
    result = mlFloydWarshall.floydWarshall(new mlMatrix.Matrix(result)).to2DArray();
  }
  return result;
}

/**
 * Calculate the molecular formula in 'chemcalc' notation taking into account fragments, isotopes and charges
 * {OCL.Molecule} [molecule] an instance of OCL.Molecule
 * @returns {object}
 */

function getMF(molecule) {
  let entries = molecule.getFragments();
  let result = {};
  let parts = [];
  let allAtoms = [];

  entries.forEach((entry) => {
    let mf = getFragmentMF(entry, allAtoms);
    parts.push(mf);
  });

  let counts = {};
  for (let part of parts) {
    if (!counts[part]) counts[part] = 0;
    counts[part]++;
  }
  parts = [];
  for (let key of Object.keys(counts).sort()) {
    if (counts[key] > 1) {
      parts.push(counts[key] + key);
    } else {
      parts.push(key);
    }
  }

  result.parts = parts;
  result.mf = toMFString(allAtoms);
  return result;
}

function getFragmentMF(molecule, allAtoms) {
  let atoms = [];
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    let atom = {};
    atom.charge = molecule.getAtomCharge(i);
    atom.label = molecule.getAtomLabel(i);
    atom.mass = molecule.getAtomMass(i);
    atom.implicitHydrogens = molecule.getImplicitHydrogens(i);
    atoms.push(atom);
    allAtoms.push(atom);
  }
  return toMFString(atoms);
}

function toMFString(atoms) {
  let charge = 0;
  let mfs = {};
  for (let atom of atoms) {
    let label = atom.label;
    charge += atom.charge;
    if (atom.mass) {
      label = `[${atom.mass}${label}]`;
    }
    let mfAtom = mfs[label];
    if (!mfAtom) {
      mfs[label] = 0;
    }
    mfs[label] += 1;
    if (atom.implicitHydrogens) {
      if (!mfs.H) mfs.H = 0;
      mfs.H += atom.implicitHydrogens;
    }
  }

  let mf = '';
  let keys = Object.keys(mfs).sort(atomSorter.atomSorter);
  for (let key of keys) {
    mf += key;
    if (mfs[key] > 1) mf += mfs[key];
  }

  if (charge > 0) {
    mf += `(+${charge > 1 ? charge : ''})`;
  } else if (charge < 0) {
    mf += `(${charge < -1 ? charge : '-'})`;
  }
  return mf;
}

/**
 * Return the number of Hydroxyl groups in a molecule or fragment
 * @param {import('openchemlib').Molecule} molecule
 * @returns {number} 'Number of Hydroxyl groups'
 */

function nbOH(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let carbonyl = false;
      let hydroxyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (
            molecule.getBondOrder(neighbourBond) === 1 &&
            molecule.getAllHydrogens(neighbourAtom) > 0
          ) {
            // If there is more than a Hydroxyl in the same carbon atome they are not couted as Hydroxyl groups
            if (hydroxyl) {
              hydroxyl = false;
              break;
            }
            hydroxyl = true;
          } else if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is Carbonyl group on the same carbon atom it is not couted as Hydroxyl group
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Hydroxyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl === false && hydroxyl && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Carboxyl groups in a molecule or fragment
 * @param {import('openchemlib').Molecule} molecule
 * @returns {number} 'Number of Carboxyl groups'
 */

function nbCOOH(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let carbonyl = false;
      let hydroxyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (
            molecule.getBondOrder(neighbourBond) === 1 &&
            molecule.getAllHydrogens(neighbourAtom) > 0
          ) {
            // If there is more than a Hydroxyl in the same carbon atom it is not couted as Carboxyl group
            if (hydroxyl) {
              hydroxyl = false;
              break;
            }
            hydroxyl = true;
          } else if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is more than one carbonyl in the same carbon atom it is not count as Carboxyl group
            if (carbonyl) {
              carbonyl = false;
              break;
            }
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Carboxyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl && hydroxyl && carbonOrHydrogen) counter++;
    }
  }
  return counter;
}

/**
 * Return the number of Carbonyl groups in a molecule or fragment
 * @param {import('openchemlib').Molecule} molecule
 * @returns {number} 'Number of Carbonyl groups'
 */

function nbCHO(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    // if there is not at least one hydrogen in the carbon atom there can not be a carbonyl group
    if (molecule.getAtomicNo(i) === 6 && molecule.getAllHydrogens(i) > 0) {
      let carbonyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is more than one carbonyl group on the same carbon atom they are not counted as carbonyl groups
            if (carbonyl) {
              carbonyl = false;
              break;
            }
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Carbonyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Primary amine groups in a molecule or fragment
 * @param {import('openchemlib').Molecule} molecule
 * @returns {number} 'Number of Primary amine groups'
 */

function nbNH2(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let amine = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);

        if (
          molecule.getAtomicNo(neighbourAtom) === 7 &&
          molecule.getBondOrder(neighbourBond) === 1 &&
          molecule.getAllHydrogens(neighbourAtom) > 1
        ) {
          // If there is more than a Primary amine in the same carbon atom they are not couted as Primary amines groups
          if (amine) {
            amine = false;
            break;
          }
          amine = true;
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Primary amine group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (amine && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Nitrile groups in a molecule or fragment
 * @param {import('openchemlib').Molecule} molecule
 * @returns {number} 'Number of Nitrile groups'
 */

function nbCN(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let cn = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);

        if (
          molecule.getAtomicNo(neighbourAtom) === 7 &&
          molecule.getBondOrder(neighbourBond) === 3
        ) {
          // If there is more than one Nitrile group in the same carbon atome they are not counted as Nitrile groups
          if (cn) {
            cn = false;
            break;
          }
          cn = true;
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Nitrile group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }

      if (cn && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Calculates the path between 2 atoms
 * @param {import('openchemlib').Molecule} molecule
 * @param {number} from - index of the first atom
 * @param {number} to - index of the end atom
 * @param {number} maxLength - maximal length of the path
 */
function getPathAndTorsion(molecule, from, to, maxLength) {
  let originalAtoms = []; // path before renumbering
  molecule.getPath(originalAtoms, from, to, maxLength + 1);
  let torsion;
  if (originalAtoms.length === 4) {
    torsion = molecule.calculateTorsion(originalAtoms);
  }

  return {
    atoms: originalAtoms,
    from,
    to,
    torsion,
    length: originalAtoms.length - 1,
  };
}

let fragment;

/**
 *
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [options.fromLabel='H']
 * @param {string} [options.toLabel='H']
 * @param {number} [options.minLength=1]
 * @param {number} [options.maxLength=4]
 * @param {boolean} [options.withHOSES=false]

 */
function getPathsInfo(molecule, options = {}) {
  const {
    fromLabel = 'H',
    toLabel = 'H',
    minLength = 1,
    maxLength = 4,
    withHOSES = false,
  } = options;

  const OCL = molecule.getOCL();

  if (!fragment) {
    fragment = new OCL.Molecule(0, 0);
  }

  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);
  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);

  // we need to find all the atoms 'fromLabel' and 'toLabel'
  let atomsInfo = getAtomsInfo(molecule);

  let pathLengthMatrix = getConnectivityMatrix(molecule, {
    pathLength: true,
  });

  for (let from = 0; from < molecule.getAllAtoms(); from++) {
    atomsInfo[from].paths = [];
    for (let to = 0; to < molecule.getAllAtoms(); to++) {
      if (from !== to) {
        if (molecule.getAtomicNo(from) === fromAtomicNumber) {
          if (molecule.getAtomicNo(to) === toAtomicNumber) {
            let pathLength = pathLengthMatrix[from][to];
            if (pathLength >= minLength && pathLength <= maxLength) {
              if (withHOSES) {
                atomsInfo[from].paths.push(
                  getHoseCodesForPath(molecule, from, to, pathLength),
                );
              } else {
                atomsInfo[from].paths.push(
                  getPathAndTorsion(molecule, from, to, pathLength),
                );
              }
            }
          }
        }
      }
    }
  }

  return atomsInfo;
}

/**
 * Get the shortest path between each pair of atoms in the molecule
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [opions.fromLabel='H']
 * @param {string} [opions.toLabel='H']
 * @param {string} [opions.maxLength=4]
 * @returns {Array<Array>} A matrix containing on each cell (i,j) the shortest path from atom i to atom j
 */
function getShortestPaths(molecule, options = {}) {
  const OCL = molecule.getOCL();
  const { fromLabel = '', toLabel = '', maxLength = 3 } = options;

  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);
  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);

  const nbAtoms = molecule.getAllAtoms();
  let allShortestPaths = new Array(nbAtoms);
  for (let i = 0; i < nbAtoms; i++) {
    allShortestPaths[i] = new Array(nbAtoms);
  }

  for (let from = 0; from < nbAtoms; from++) {
    allShortestPaths[from][from] = [from];
    for (let to = from + 1; to < nbAtoms; to++) {
      if (
        (fromAtomicNumber === 0 ||
          molecule.getAtomicNo(from) === fromAtomicNumber) &&
        (toAtomicNumber === 0 || molecule.getAtomicNo(to) === toAtomicNumber)
      ) {
        let path = [];
        molecule.getPath(path, from, to, maxLength);
        if (path.length) {
          allShortestPaths[from][to] = path.slice();
          allShortestPaths[to][from] = path.reverse();
        } else {
          allShortestPaths[from][to] = null;
          allShortestPaths[to][from] = null;
        }
      } else {
        allShortestPaths[from][to] = null;
        allShortestPaths[to][from] = null;
      }
    }
  }

  return allShortestPaths;
}

function getMoleculeCreators(Molecule) {
  const fields = new Map();

  fields.set('oclid', Molecule.fromIDCode);
  fields.set('idcode', Molecule.fromIDCode);
  fields.set('smiles', Molecule.fromSmiles);
  fields.set('molfile', Molecule.fromMolfile);

  return fields;
}

const defaultCSVOptions = {
  header: true,
  dynamicTyping: true,
  skipEmptyLines: true,
};

async function appendCSV(moleculesDB, csv, options = {}) {
  const { onStep } = options;
  csv = ensureString.ensureString(csv);
  const moleculeCreators = getMoleculeCreators(moleculesDB.OCL.Molecule);

  if (typeof csv !== 'string') {
    throw new TypeError('csv must be a string');
  }
  options = { ...defaultCSVOptions, ...options };

  const parsed = Papa.parse(csv, options);
  const fields = parsed.meta.fields;
  const stats = new Array(fields.length);
  const firstElement = parsed.data[0];
  let moleculeCreator, moleculeField;
  for (let i = 0; i < fields.length; i++) {
    stats[i] = {
      label: fields[i],
      isNumeric: typeof firstElement[fields[i]] === 'number',
    };
    const lowerField = fields[i].toLowerCase();
    if (moleculeCreators.has(lowerField)) {
      moleculeCreator = moleculeCreators.get(lowerField);
      moleculeField = fields[i];
    }
  }
  if (!moleculeCreator) {
    throw new Error('this document does not contain any molecule field');
  }
  moleculesDB.statistics = stats;

  for (let i = 0; i < parsed.data.length; i++) {
    moleculesDB.pushEntry(
      moleculeCreator(parsed.data[i][moleculeField]),
      parsed.data[i],
    );
    if (onStep) {
      await onStep(i + 1, parsed.data.length);
    }
  }
}

function appendColor(moleculesDB, options = {}) {
  const {
    dataLabel,
    propertyLabel,
    minValue,
    maxValue,
    minHue = 0,
    maxHue = 360,
    saturation = 65,
    lightness = 65,
    colorLabel = 'color',
  } = options;

  const db = moleculesDB.getDB();
  let values;
  if (dataLabel) {
    values = db
      .map((result) =>
        result.data.map((datum) => ({ value: datum[dataLabel], data: datum })),
      )
      .flat();
  } else if (propertyLabel) {
    values = db
      .map((result) =>
        result.data.map((datum) => ({
          value: result.properties[propertyLabel],
          data: datum,
        })),
      )
      .flat();
  } else {
    values = db
      .map((result) =>
        result.data.map((datum) => ({ value: undefined, data: datum })),
      )
      .flat();
  }

  if (minValue !== undefined) {
    values = values.forEach((value) => {
      if (value.value !== undefined && value.value < minValue) {
        value.value = minValue;
      }
    });
  }

  if (maxValue !== undefined) {
    values = values.forEach((value) => {
      if (value.value !== undefined && value.value > maxValue) {
        value.value = maxValue;
      }
    });
  }

  const definedValues = values.filter((value) => value.value !== undefined);
  const min = Math.min(...definedValues.map((value) => value.value));
  const max = Math.max(...definedValues.map((value) => value.value));

  for (let value of values) {
    if (value.value !== undefined) {
      value.data[colorLabel] = `hsl(${Math.floor(
        ((value.value - min) / (max - min)) * (maxHue - minHue) + minHue,
      )},${saturation}%,${lightness}%)`;
    } else {
      value.data.color = 'black';
    }
  }
}

async function appendSDF(moleculesDB, sdf, options = {}) {
  const { onStep } = options;
  sdf = ensureString.ensureString(sdf);
  if (typeof sdf !== 'string') {
    throw new TypeError('sdf must be a string');
  }
  const parsed = sdfParser.parse(sdf);
  moleculesDB.statistics = parsed.statistics;
  for (let i = 0; i < parsed.molecules.length; i++) {
    const molecule = parsed.molecules[i];
    moleculesDB.pushEntry(
      moleculesDB.OCL.Molecule.fromMolfile(molecule.molfile),
      molecule,
    );
    if (onStep) {
      await onStep(i + 1, parsed.molecules.length);
    }
  }
}

async function appendSmilesList(
  moleculesDB,
  text,
  options = {},
) {
  const { onStep } = options;
  text = ensureString.ensureString(text);
  if (typeof text !== 'string') {
    throw new TypeError('text must be a string');
  }
  const smilesArray = text
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line);
  for (let i = 0; i < smilesArray.length; i++) {
    const oneSmiles = smilesArray[i];
    moleculesDB.pushEntry(moleculesDB.OCL.Molecule.fromSmiles(oneSmiles));
    if (onStep) {
      await onStep(i + 1, smilesArray.length);
    }
  }
}

/**
 *
 * @param {MoleculesDB} moleculesDB
 * @param {import('openchemlib').Molecule} molecule
 * @param {object} data
 * @param {object} [moleculeInfo]
 * @param {string} [moleculeInfo.idCode]
 * @param {number[]} [moleculeInfo.index]
 */

function pushEntry(
  moleculesDB,
  molecule,
  data = {},
  moleculeInfo = {},
) {
  // the following line could be the source of problems if the idCode version
  // changes

  let moleculeIDCode = moleculeInfo.idCode
    ? moleculeInfo.idCode
    : molecule.getIDCode();
  let entry = moleculesDB.db[moleculeIDCode];
  if (!entry) {
    // a new molecule
    entry = { molecule, properties: {}, data: [], idCode: moleculeIDCode };
    moleculesDB.db[moleculeIDCode] = entry;

    // ensure helper arrays needed for substructure search
    molecule.ensureHelperArrays(moleculesDB.OCL.Molecule.cHelperRings);
    if (!moleculeInfo.index) {
      entry.index = molecule.getIndex();
    } else {
      entry.index = moleculeInfo.index;
    }

    let molecularFormula;
    if (!moleculeInfo.mw) {
      molecularFormula = molecule.getMolecularFormula();
      entry.properties.mw = molecularFormula.relativeWeight;
    } else {
      entry.properties.mw = moleculeInfo.mw;
    }

    if (moleculesDB.computeProperties) {
      if (!molecularFormula) {
        molecularFormula = molecule.getMolecularFormula();
      }
      const properties = new moleculesDB.OCL.MoleculeProperties(molecule);
      entry.properties.em = molecularFormula.absoluteWeight;
      entry.properties.mf = molecularFormula.formula;
      entry.properties.acceptorCount = properties.acceptorCount;
      entry.properties.donorCount = properties.donorCount;
      entry.properties.logP = properties.logP;
      entry.properties.logS = properties.logS;
      entry.properties.polarSurfaceArea = properties.polarSurfaceArea;
      entry.properties.rotatableBondCount = properties.rotatableBondCount;
      entry.properties.stereoCenterCount = properties.stereoCenterCount;
    }
  }
  entry.data.push(data);
}

function pushMoleculeInfo(moleculesDB, moleculeInfo, data = {}) {
  if (typeof moleculeInfo !== 'object') {
    throw new Error('pushMoleculeInfo requires an object as first parameter');
  }
  const Molecule = moleculesDB.OCL.Molecule;
  let molecule;
  if (moleculeInfo.molfile) {
    molecule = Molecule.fromMolfile(moleculeInfo.molfile);
  }
  if (moleculeInfo.smiles) molecule = Molecule.fromSmiles(moleculeInfo.smiles);
  if (moleculeInfo.idCode) {
    if (moleculesDB.db[moleculeInfo.idCode]) {
      molecule = moleculesDB.db[moleculeInfo.idCode].molecule;
    } else {
      molecule = Molecule.fromIDCode(
        moleculeInfo.idCode,
        moleculeInfo.coordinates || false,
      );
    }
  }

  if (molecule) {
    moleculesDB.pushEntry(molecule, data, moleculeInfo);
  }
}

async function noWait() {
  return new Promise((resolve) => {
    if (typeof setImmediate === 'function') {
      setImmediate(() => resolve());
    } else {
      // didn't find a better way to do it in the browser
      setTimeout(() => resolve(), 0);
    }
  });
}

class AbortError extends Error {
  name = 'AbortError';
  code = 20;
}

function getQuery(moleculesDB, query, options) {
  const { format = 'idCode' } = options;

  if (typeof query === 'string') {
    const moleculeCreators = getMoleculeCreators(moleculesDB.OCL.Molecule);
    query = moleculeCreators.get(format.toLowerCase())(query);
  } else if (!(query instanceof moleculesDB.OCL.Molecule)) {
    throw new TypeError('toSearch must be a Molecule or string');
  }
  return query;
}

function search(moleculesDB, query = '', options = {}) {
  const { mode = 'substructure' } = options;

  query = getQuery(moleculesDB, query, options);

  let result;
  switch (mode.toLowerCase()) {
    case 'exact':
      result = exactSearch(moleculesDB, query);
      break;
    case 'substructure':
      result = subStructureSearch(moleculesDB, query);
      break;
    case 'similarity':
      result = similaritySearch(moleculesDB, query);
      break;
    default:
      throw new Error(`unknown search mode: ${options.mode}`);
  }
  return processResult(result, options);
}

async function searchAsync(moleculesDB, query = '', options = {}) {
  const { mode = 'substructure' } = options;

  query = getQuery(moleculesDB, query, options);

  let result;
  switch (mode.toLowerCase()) {
    case 'exact':
      result = exactSearch(moleculesDB, query);
      break;
    case 'substructure':
      result = await subStructureSearchAsync(moleculesDB, query, options);
      break;
    case 'similarity':
      result = similaritySearch(moleculesDB, query);
      break;
    default:
      throw new Error(`unknown search mode: ${options.mode}`);
  }
  return processResult(result, options);
}

function exactSearch(moleculesDB, query) {
  const queryIDCode = query.getIDCode();
  let searchResult = moleculesDB.db[queryIDCode]
    ? [moleculesDB.db[queryIDCode]]
    : [];
  return searchResult;
}

function substructureSearchBegin(moleculesDB, query) {
  let resetFragment = false;
  if (!query.isFragment()) {
    resetFragment = true;
    query.setFragment(true);
  }

  const queryMW = getMW(query);
  const searchResult = [];
  if (query.getAllAtoms() === 0) {
    for (let idCode in moleculesDB.db) {
      searchResult.push(moleculesDB.db[idCode]);
    }
  }
  return { resetFragment, queryMW, searchResult };
}

function substructureSearchEnd(searchResult, queryMW, resetFragment, query) {
  searchResult.sort((a, b) => {
    return (
      Math.abs(queryMW - a.properties.mw) - Math.abs(queryMW - b.properties.mw)
    );
  });

  if (resetFragment) {
    query.setFragment(false);
  }

  return searchResult;
}

function subStructureSearch(moleculesDB, query) {
  const { resetFragment, queryMW, searchResult } = substructureSearchBegin(
    moleculesDB,
    query,
  );

  if (searchResult.length === 0) {
    const queryIndex = query.getIndex();
    const searcher = moleculesDB.searcher;
    searcher.setFragment(query, queryIndex);
    for (let idCode in moleculesDB.db) {
      let entry = moleculesDB.db[idCode];
      searcher.setMolecule(entry.molecule, entry.index);
      if (searcher.isFragmentInMolecule()) {
        searchResult.push(entry);
      }
    }
  }

  return substructureSearchEnd(searchResult, queryMW, resetFragment, query);
}

async function subStructureSearchAsync(moleculesDB, query, options = {}) {
  const { interval = 100, onStep, controller } = options;
  let shouldAbort = false;

  if (controller) {
    const abortEventListener = () => {
      shouldAbort = true;
    };
    controller.signal.addEventListener('abort', abortEventListener);
  }

  const { resetFragment, queryMW, searchResult } = substructureSearchBegin(
    moleculesDB,
    query,
  );

  let begin = performance.now();

  if (searchResult.length === 0) {
    const queryIndex = query.getIndex();
    const searcher = moleculesDB.searcher;
    searcher.setFragment(query, queryIndex);
    let index = 0;
    let length = Object.keys(moleculesDB.db).length;
    for (let idCode in moleculesDB.db) {
      if (shouldAbort) {
        throw new AbortError('Query aborted');
      }
      let entry = moleculesDB.db[idCode];
      searcher.setMolecule(entry.molecule, entry.index);
      if (searcher.isFragmentInMolecule()) {
        searchResult.push(entry);
      }
      if ((onStep || controller) && performance.now() - begin >= interval) {
        begin = performance.now();
        if (onStep) {
          onStep(index, length);
        }
        if (controller && !onStep) {
          await noWait();
        }
      }
      index++;
    }
  }
  return substructureSearchEnd(searchResult, queryMW, resetFragment, query);
}

function similaritySearch(moleculesDB, query) {
  const queryIndex = query.getIndex();
  const queryMW = getMW(query);
  const queryIdCode = query.getIDCode();

  const searchResult = [];
  let similarity;
  for (let idCode in moleculesDB.db) {
    let entry = moleculesDB.db[idCode];
    if (entry.idCode === queryIdCode) {
      similarity = Number.MAX_SAFE_INTEGER;
    } else {
      similarity =
        moleculesDB.OCL.SSSearcherWithIndex.getSimilarityTanimoto(
          queryIndex,
          entry.index,
        ) *
          1000000 -
        Math.abs(queryMW - entry.properties.mw) / 10000;
    }
    searchResult.push({ similarity, entry });
  }
  searchResult.sort((a, b) => {
    return b.similarity - a.similarity;
  });
  return searchResult.map((entry) => entry.entry);
}

function getMW(query) {
  let copy = query.getCompactCopy();
  copy.setFragment(false);
  return copy.getMolecularFormula().relativeWeight;
}

function processResult(entries, options = {}) {
  const {
    flattenResult = true,
    keepMolecule = false,
    limit = Number.MAX_SAFE_INTEGER,
  } = options;
  let results = [];

  if (flattenResult) {
    for (let entry of entries) {
      for (let data of entry.data) {
        results.push({
          data,
          idCode: entry.idCode,
          properties: entry.properties,
          molecule: keepMolecule ? entry.molecule : undefined,
        });
      }
    }
  } else {
    for (let entry of entries) {
      results.push({
        data: entry.data,
        idCode: entry.idCode,
        properties: entry.properties,
        molecule: keepMolecule ? entry.molecule : undefined,
      });
    }
  }
  if (limit < results.length) results.length = limit;
  return results;
}

/*
    this.db is an object with properties 'oclID' that has as value
    an object that contains the following properties:
    * molecule: an OCL molecule instance
    * index: OCL index used for substructure searching
    * properties: all the calculates properties
    * data: array containing free data associated with this molecule
  */

class MoleculesDB {
  /**
   *
   * @param {import('openchemlib')} OCL - openchemlib library
   * @param {object} [options={}]
   * @param {boolean} [options.computeProperties=false]
   */
  constructor(OCL, options = {}) {
    const { computeProperties = false } = options;
    this.OCL = OCL;
    this.db = {};
    this.statistics = null;
    this.computeProperties = computeProperties;
    this.searcher = new OCL.SSSearcherWithIndex();
  }

  /**
   * append to the current database a CSV file
   * @param {string|ArrayBuffer} csv - text file containing the comma separated value file
   * @param {object} [options={}]
   * @param {boolean} [options.header=true]
   * @param {boolean} [options.dynamicTyping=true]
   * @param {boolean} [options.skipEmptyLines=true]
   * @param {function} [options.onStep] call back to execute after each molecule
   */

  appendCSV(csv, options) {
    return appendCSV(this, csv, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Append a SDF to the current database
   * @param {string|ArrayBuffer} sdf - text file containing the sdf
   * @param {object} [options={}]
   * @param {function} [options.onStep] call back to execute after each molecule
   * @returns {DB}
   */

  appendSDF(sdf, options) {
    return appendSDF(this, sdf, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Append a SDF to the current database
   * @param {string|ArrayBuffer} smiles - text file containing a list of smiles
   * @param {object} [options={}]
   * @param {function} [options.onStep] call back to execute after each molecule
   * @returns {DB}
   */

  appendSmilesList(text, options) {
    return appendSmilesList(this, text, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Add a molecule to the current database
   * @param {import('openchemlib').Molecule} molecule
   * @param {object} [data={}]
   * @param {object} [moleculeInfo={}] may contain precalculated index and mw
   */

  pushEntry(molecule, data, moleculeInfo) {
    pushEntry(this, molecule, data, moleculeInfo);
  }

  /**
   * Add an entry in the database
   * @param {object} moleculeInfo - a molecule as a JSON that may contain the following properties: molfile, smiles, idCode, mf, index
   * @param {object} [data={}]
   */

  pushMoleculeInfo(moleculeInfo, data) {
    return pushMoleculeInfo(this, moleculeInfo, data);
  }

  /**
   * Search in a MoleculesDB
   * Inside the database all the same molecules are group together
   * @param {string|OCL.Molecule} [query] smiles, molfile, oclCode or instance of Molecule to look for
   * @param {object} [options={}]
   * @param {string} [options.format='idCode'] - query is in the format 'smiles', 'oclid' or 'molfile'
   * @param {string} [options.mode='substructure'] - search by 'substructure', 'exact' or 'similarity'
   * @param {boolean} [options.flattenResult=true] - The database group the data for the same product. This allows to flatten the result
   * @param {boolean} [options.keepMolecule=false] - keep the OCL.Molecule object in the result
   * @param {number} [options.limit=Number.MAX_SAFE_INTEGER] - maximal number of result
   * @return {Array} array of object of the type {(molecule), idCode, data, properties}
   */
  search(query, options) {
    return search(this, query, options);
  }

  /**
   * Search in a MoleculesDB
   * Inside the database all the same molecules are group together
   * @param {string|OCL.Molecule} [query] smiles, molfile, oclCode or instance of Molecule to look for
   * @param {object} [options={}]
   * @param {string} [options.format='idCode'] - query is in the format 'smiles', 'oclid' or 'molfile'
   * @param {string} [options.mode='substructure'] - search by 'substructure', 'exact' or 'similarity'
   * @param {boolean} [options.flattenResult=true] - The database group the data for the same product. This allows to flatten the result
   * @param {boolean} [options.keepMolecule=false] - keep the OCL.Molecule object in the result
   * @param {number} [options.limit=Number.MAX_SAFE_INTEGER] - maximal number of result
   * @param {number} [options.interval=100] - interval in ms to call the onStep callback
   * @param {function} [options.onStep] - callback to execute after each interval
   * @param {AbortController} [options.controler] - callback to execute to check if the search should be aborted
   * @return {Promise<Array>} array of object of the type {(molecule), idCode, data, properties}
   */
  searchAsync(query, options) {
    return searchAsync(this, query, options);
  }

  /**
   * Returns an array with the current database
   * @returns
   */
  getDB() {
    return Object.keys(this.db).map((key) => this.db[key]);
  }

  /**
   * Append the property `data.color` to each entry based on a data or property label
   * {object} [options={}]
   * {string} [options.dataLabel] name of the property from `data` to use
   * {string} [options.propertyLabel] name of the property from `properties` to use
   * {number} [options.colorLabel='color'] name of the property to add in data that will contain the color
   * {number} [options.minValue]
   * {number} [options.maxValue]
   * {number} [options.minHue=0]
   * {number} [options.maxHue=360]
   * {number} [options.saturation=65] percent of color saturation
   * {number} [options.lightness=65] percent of color lightness
   */
  appendColor(options) {
    appendColor(this, options);
  }
}

function getAtomFeatures(originalMolecule, options = {}) {
  const OCL = originalMolecule.getOCL();

  const { sphere = 1 } = options;
  const fragment = new OCL.Molecule(0, 0);
  const results = [];

  for (
    let rootAtom = 0;
    rootAtom < originalMolecule.getAllAtoms();
    rootAtom++
  ) {
    let min = 0;
    let max = 0;
    let atomMask = new Array(originalMolecule.getAtoms());
    let atomList = new Array(originalMolecule.getAtoms());

    const molecule = originalMolecule.getCompactCopy();
    for (let currentSphere = 0; currentSphere <= sphere; currentSphere++) {
      if (max === 0) {
        atomList[max] = rootAtom;
        atomMask[rootAtom] = true;
        max++;
      } else {
        let newMax = max;
        for (let i = min; i < max; i++) {
          let atom = atomList[i];
          for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {
            let connAtom = molecule.getConnAtom(atom, j);
            if (!atomMask[connAtom]) {
              atomMask[connAtom] = true;
              atomList[newMax++] = connAtom;
            }
          }
        }
        min = max;
        max = newMax;
      }
      molecule.copyMoleculeByAtoms(fragment, atomMask, true, null);
      if (currentSphere === sphere) {
        makeRacemic(fragment);
        results.push(fragment.getCanonizedIDCode());
      }
    }
  }

  const atoms = {};
  for (let result of results) {
    if (!atoms[result]) {
      atoms[result] = 1;
    } else {
      atoms[result]++;
    }
  }

  return atoms;
}

function toVisualizerMolfile(molecule, options = {}) {
  const { diastereotopic, heavyAtomHydrogen } = options;

  let highlight = [];
  let atoms = {};
  if (diastereotopic) {
    let hydrogenInfo = {};
    let extendedIDs = getDiastereotopicAtomIDsAndH(molecule);
    for (let line of extendedIDs) {
      hydrogenInfo[line.oclID] = line;
    }

    let diaIDs = getGroupedDiastereotopicAtomIDs(molecule);
    for (const diaID of diaIDs) {
      atoms[diaID.oclID] = diaID.atoms;
      highlight.push(diaID.oclID);
      if (heavyAtomHydrogen) {
        if (
          hydrogenInfo[diaID.oclID] &&
          hydrogenInfo[diaID.oclID].nbHydrogens > 0
        ) {
          for (let id of hydrogenInfo[diaID.oclID].hydrogenOCLIDs) {
            highlight.push(id);
            atoms[id] = diaID.atoms;
          }
        }
      }
    }
  } else {
    let size = molecule.getAllAtoms();
    highlight = new Array(size).fill(0).map((a, index) => index);
    atoms = highlight.map((a) => [a]);
  }

  let molfile = {
    type: 'mol2d',
    value: molecule.toMolfile(),
    _highlight: highlight,
    _atoms: atoms,
  };

  return molfile;
}

function getParts(text) {
  const lines = text.split(/\r?\n/);
  let parts = { data: [] };
  let currentPart = parts.data;
  let currentLabel = '';
  for (let line of lines) {
    if (line.startsWith('</')) {
      // close existing part
      if (!currentLabel === line.slice(2, -1)) {
        throw new Error('This should not happen');
      }
      currentLabel = '';
      currentPart = parts.data;
    } else if (line.startsWith('<') && !line.includes('=')) {
      // open new part
      if (currentLabel) {
        throw new Error('This should not happen');
      }
      currentLabel = line.slice(1, -1);
      const target = getCamelCase(currentLabel);
      parts[target] = [];
      currentPart = parts[target];
    } else if (currentLabel) {
      // add line to current part
      currentPart.push(line);
    } else {
      //data lines
      currentPart.push(line);
    }
  }
  return parts;
}

function parseColumnbProperties(lines) {
  lines = lines.map((line) => {
    const [key, value] = line.slice(1, -1).split('=');
    return { key, value: value.slice(1, -1) };
  });
  const columnProperties = {};
  let currentColumnName = '';
  for (let line of lines) {
    switch (line.key) {
      case 'columnName':
        currentColumnName = line.value;
        columnProperties[currentColumnName] = {};
        break;
      case 'columnProperty':
        {
          if (!currentColumnName) {
            throw new Error('This should not happen');
          }
          const [key, value] = line.value.split('\t');
          columnProperties[currentColumnName][key] = value;
        }
        break;
      default:
        throw new Error('This should not happen');
    }
  }
  for (let key in columnProperties) {
    const columnPropery = columnProperties[key];
    if (columnProperties[key].parent) {
      const target = columnProperties[columnPropery.parent];
      if (!target) {
        throw new Error('Parent column not found');
      }
      if (!target.related) {
        target.related = {};
      }
      target.related[columnPropery.specialType] = key;
    }
  }

  return columnProperties;
}

function parseData(lines, options = {}) {
  lines = lines.filter((line) => !line.match(/^\s*$/));
  const { columnProperties = {} } = options;
  const headers = lines
    .shift()
    .split('\t')
    .map((header) => {
      if (columnProperties[header]) {
        return { label: header, ...columnProperties[header] };
      }
      return { label: header };
    });
  const entries = [];
  const rawEntries = [];

  for (let line of lines) {
    const fields = line.split('\t');
    const rawEntry = {};
    headers.forEach((header, index) => {
      rawEntry[header.label] = fields[index];
    });
    rawEntries.push(rawEntry);
    const entry = {};
    headers.forEach((header) => {
      if (header.parent) return;
      entry[header.label] = valueEhnhancer(header, rawEntry);
    });
    entries.push(entry);
  }

  return { entries, rawEntries };
}

function valueEhnhancer(header, rawEntry) {
  if (header?.specialType === 'rxncode') {
    return `${rawEntry[header.label]}#${rawEntry[header.related.atomMapping]}#${
      rawEntry[header.related.idcoordinates2D]
    }`;
  }

  return rawEntry[header.label];
}

/*
entry.rxnCode =
*/

/**
 * Convert a DataWarrior database into a JSON object
 * @param {string} text
 * @returns
 */
function parseDwar(text) {
  text = ensureString.ensureString(text);
  const parts = getParts(text);
  improveParts(parts);
  return parts;
}

function getCamelCase(name) {
  return name.replace(/[ -][a-z]/g, (string) => string[1].toUpperCase());
}

function improveParts(parts) {
  for (let key in parts) {
    switch (key) {
      case 'columnProperties':
        parts[key] = parseColumnbProperties(parts[key]);
        break;
      case 'data':
        break;
      default:
        parts[key] = parseDefault(parts[key]);
    }
  }
  const data = parseData(parts.data, {
    columnProperties: parts.columnProperties,
  });
  parts.data = data.entries;
  parts.rawData = data.rawEntries;
}

function parseDefault(lines) {
  const result = {};
  for (let line of lines) {
    const [key, value] = line.slice(1, -1).split('=');
    result[key] = value.slice(1, -1);
  }
  return result;
}

function fragmentAcyclicSingleBonds(molecule) {
  const OCL = molecule.getOCL();
  let atoms = [];
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    let atom = {};
    atoms.push(atom);
    atom.i = i;
    atom.links = []; // we will store connected atoms of broken bonds
  }

  let bonds = [];
  for (let i = 0; i < molecule.getAllBonds(); i++) {
    let bond = {};
    bonds.push(bond);
    bond.i = i;
    bond.order = molecule.getBondOrder(i);
    bond.atom1 = molecule.getBondAtom(0, i);
    bond.atom2 = molecule.getBondAtom(1, i);
    bond.type = molecule.getBondType(i);
    bond.isAromatic = molecule.isAromaticBond(i);
    bond.isRingBond = molecule.isRingBond(i);
    if (!bond.isAromatic && (bond.type & 0b11) === 1 && !bond.isRingBond) {
      bond.selected = true;
      atoms[bond.atom1].links.push(bond.atom2);
      atoms[bond.atom2].links.push(bond.atom1);
    }
  }

  //  console.log(bonds);

  let brokenMolecule = molecule.getCompactCopy();
  for (let bond of bonds) {
    if (bond.selected) {
      brokenMolecule.markBondForDeletion(bond.i);
    }
  }

  brokenMolecule.deleteMarkedAtomsAndBonds();
  let fragmentMap = [];
  let nbFragments = brokenMolecule.getFragmentNumbers(fragmentMap);
  let results = [];
  for (let i = 0; i < nbFragments; i++) {
    let result = {};
    result.atomMap = [];
    let includeAtom = fragmentMap.map((id) => {
      return id === i;
    });
    let fragment = new OCL.Molecule(0, 0);
    let atomMap = [];
    brokenMolecule.copyMoleculeByAtoms(fragment, includeAtom, false, atomMap);
    // we will add some R groups at the level of the broken bonds
    for (let j = 0; j < atomMap.length; j++) {
      if (atomMap[j] > -1) {
        result.atomMap.push(j);
        if (atoms[j].links.length > 0) {
          for (let k = 0; k < atoms[j].links.length; k++) {
            fragment.addBond(atomMap[j], fragment.addAtom(154), 1);
          }
        }
      }
    }
    fragment.setFragment(false);
    result.idCode = fragment.getIDCode();
    result.mf = getMF(fragment).mf.replace(/R[1-9]?/, '');
    results.push(result);
  }

  return results;
}

/**
 *
 * @param {import('openchemlib').Molecule} molecule
 * @param {Map} moleculesInfo
 * @returns
 */
function getInfo(molecule, moleculesInfo) {
  if (moleculesInfo.has(molecule)) {
    return moleculesInfo.get(molecule);
  }
  const reactantInfo = {
    molfile: molecule.toMolfile(),
    idCode: molecule.getIDCode(),
    mf: getMF(molecule).mf,
  };
  moleculesInfo.set(molecule, reactantInfo);
  return reactantInfo;
}

function applyOneReactantReaction(reactants, reactions, options) {
  const { currentDepth, maxDepth, moleculesInfo, processedMolecules, results } =
    options;
  const todoNextDepth = [];
  if (currentDepth >= maxDepth) return [];
  if (!Array.isArray(reactants)) {
    reactants = [reactants];
  }
  const { OCL } = options;
  for (const reactant of reactants) {
    const idCode = reactant.getIDCode();
    if (processedMolecules.has(idCode)) {
      continue;
    } else {
      processedMolecules.add(idCode);
    }
    for (const reaction of reactions) {
      const reactor = new OCL.Reactor(reaction.oclReaction);
      const isMatching = Boolean(reactor.setReactant(0, reactant));
      if (isMatching) {
        const oneReactionProducts = reactor.getProducts();
        for (let i = 0; i < oneReactionProducts.length; i++) {
          const products = [];
          for (let j = 0; j < oneReactionProducts[i].length; j++) {
            const moleculeInfo = getInfo(
              oneReactionProducts[i][j],
              moleculesInfo,
            );
            if (!processedMolecules.has(moleculeInfo.idCode)) {
              const product = {
                ...moleculeInfo,
                children: [],
              };
              products.push(product);

              todoNextDepth.push(() => {
                return applyOneReactantReaction(
                  oneReactionProducts[i][j],
                  reactions,
                  {
                    ...options,
                    currentDepth: options.currentDepth + 1,
                    results: product.children,
                  },
                );
              });
            }
          }
          if (products.length > 0) {
            // eslint-disable-next-line no-unused-vars
            const { oclReaction, ...reactionWithoutOCL } = reaction;
            const oneReaction = {
              reaction: reactionWithoutOCL,
              reactant: getInfo(reactant, moleculesInfo),
              products,
            };
            results.push(oneReaction);
          }
        }
      }
    }
  }
  return todoNextDepth;
}

/**
 * Create a tree of products based on reactions and reactants
 * @param {import('openchemlib').Molecule[]} reactants
 * @param {Array} reactions
 * @param {object} options
 * @param {number} [options.maxDepth=10]
 * @returns
 */
function applyReactions(reactants, reactions, options = {}) {
  const { maxDepth = 10 } = options;
  const moleculesInfo = new Map();
  const processedMolecules = new Set();
  if (!reactants.length) {
    throw new Error('Can not extract OCL because there is no reactants');
  }
  const OCL = reactants[0].getOCL();

  reactions = appendOCLReaction(reactions, OCL);

  const results = [];

  let todoCurrentLevel = applyOneReactantReaction(reactants, reactions, {
    OCL,
    currentDepth: 0,
    moleculesInfo,
    processedMolecules,
    maxDepth,
    results,
  });

  do {
    const nexts = [];
    for (const todo of todoCurrentLevel) {
      nexts.push(todo());
    }
    todoCurrentLevel = nexts.flat();
  } while (todoCurrentLevel.length > 0);

  return results;
}

function appendOCLReaction(reactions, OCL) {
  reactions = JSON.parse(JSON.stringify(reactions)).filter(
    (reaction) => reaction.rxnCode,
  );
  for (const reaction of reactions) {
    reaction.oclReaction = OCL.ReactionEncoder.decode(reaction.rxnCode);
  }
  return reactions;
}

exports.FULL_HOSE_CODE = FULL_HOSE_CODE;
exports.HOSE_CODE_CUT_C_SP3_SP3 = HOSE_CODE_CUT_C_SP3_SP3;
exports.MoleculesDB = MoleculesDB;
exports.addDiastereotopicMissingChirality = addDiastereotopicMissingChirality;
exports.applyReactions = applyReactions;
exports.combineSmiles = combineSmiles;
exports.fragmentAcyclicSingleBonds = fragmentAcyclicSingleBonds;
exports.getAtomFeatures = getAtomFeatures;
exports.getAtomsInfo = getAtomsInfo;
exports.getCamelCase = getCamelCase;
exports.getConnectivityMatrix = getConnectivityMatrix;
exports.getDiastereotopicAtomIDs = getDiastereotopicAtomIDs;
exports.getDiastereotopicAtomIDsAndH = getDiastereotopicAtomIDsAndH;
exports.getDiastereotopicAtomIDsFromMolfile = getDiastereotopicAtomIDsFromMolfile;
exports.getGroupedDiastereotopicAtomIDs = getGroupedDiastereotopicAtomIDs;
exports.getHoseCodesAndDiastereotopicIDs = getHoseCodesAndDiastereotopicIDs;
exports.getHoseCodesForAtom = getHoseCodesForAtom;
exports.getHoseCodesForAtoms = getHoseCodesForAtoms;
exports.getHoseCodesForPath = getHoseCodesForPath;
exports.getHoseCodesFromDiastereotopicID = getHoseCodesFromDiastereotopicID;
exports.getMF = getMF;
exports.getPathAndTorsion = getPathAndTorsion;
exports.getPathsInfo = getPathsInfo;
exports.getShortestPaths = getShortestPaths;
exports.groupDiastereotopicAtomIDs = groupDiastereotopicAtomIDs;
exports.isCsp3 = isCsp3;
exports.makeRacemic = makeRacemic;
exports.nbCHO = nbCHO;
exports.nbCN = nbCN;
exports.nbCOOH = nbCOOH;
exports.nbNH2 = nbNH2;
exports.nbOH = nbOH;
exports.parseDwar = parseDwar;
exports.tagAtom = tagAtom;
exports.toDiastereotopicSVG = toDiastereotopicSVG;
exports.toVisualizerMolfile = toVisualizerMolfile;

}).call(this)}).call(this,require("timers").setImmediate)
},{"atom-sorter":2,"ensure-string":7,"ml-floyd-warshall":162,"ml-matrix":186,"papaparse":526,"sdf-parser":527,"timers":537}],526:[function(require,module,exports){
/* @license
Papa Parse
v5.4.1
https://github.com/mholt/PapaParse
License: MIT
*/
!function(e,t){"function"==typeof define&&define.amd?define([],t):"object"==typeof module&&"undefined"!=typeof exports?module.exports=t():e.Papa=t()}(this,function s(){"use strict";var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",i,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,"string"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,r=!1,i=null,o=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");i=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s);("boolean"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\-@\t\r].*$/)}();var u=new RegExp(Q(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if("object"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error("Unable to serialize unrecognized input");function h(e,t,r){var i="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y)}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h="greedy"===r?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c])}h=""===d.join("").trim()}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p)}o<t.length-1&&(!r||0<u&&!f)&&(i+=y)}}return i}function v(e,t){if(null==e)return"";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0);var i=e.toString().replace(u,a);return(r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)})}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if("skip"===s.action)return void h();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if("skip"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h()},b.parse(n.file,n.instanceConfig)}else J(o.complete)&&o.complete()}function h(){u.splice(0,1),e()}}}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r)}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine="";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t])}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader("Range","bytes="+this._start+"-"+r)}try{i.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===i.status&&this._chunkError()}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(i),this.parseChunk(i.responseText)))},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t))}}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=""),this._finished=!r,this.parseChunk(e)}}}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0},this._streamData=v(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData("")},this),this._streamCleanUp=v(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,h=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function y(e){return"greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return!y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?"__parsed_extra":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+r,f+t):r<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return!0}return!1}(t)?parseFloat(t):h.test(t)?new Date(t):""===t?null:t):t;var r}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n)}this.parse=function(e,t,r){var i=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+"([^]*?)"+Q(t),"gm"),i=(e=e.replace(r,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return"\n";for(var a=0,o=0;o<i.length;o++)"\n"===i[o][0]&&a++;return a>=i.length/2?"\r\n":"\r"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,r,i,n){var s,a,o,u;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?"":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a=""}}function Q(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),("string"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=","),U===M)throw new Error("Comment character same as delimiter");!0===U?U="#":("string"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),"\n"!==P&&"\r"!==P&&"\r\n"!==P&&(P="\n");var W=0,H=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+"_"+v),p[m]=v+1;c.includes(y);)y=y+"_"+v;c.push(y)}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P)}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),"g"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W)}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else{if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:u.length,index:W}),S++}}else S++}return T();function I(e){u.push(e),d=W}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&""===r.trim()&&(t=r.length)}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W)}function L(e){return{data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[]}},this.abort=function(){H=!0},this.getCharIndex=function(){return W}}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!i&&m(t.workerId,t.results)}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e]}function y(){throw new Error("Not implemented.")}function w(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments)}}function J(e){return"function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0})}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b});
},{}],527:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ensureString = require('ensure-string');
var readline = require('readline');
var dynamicTyping = require('dynamic-typing');

function getEntriesBoundaries(string, substring, eol) {
  const res = [];
  let previous = 0;
  let next = 0;
  while (next !== -1) {
    next = string.indexOf(substring, previous);
    if (next !== -1) {
      res.push([previous, next]);
      const nextMatch = string.indexOf(eol, next + substring.length);
      if (nextMatch === -1) {
        next = -1;
      } else {
        previous = nextMatch + eol.length;
        next = previous;
      }
    } else {
      res.push([previous, string.length]);
    }
  }
  return res;
}

function getMolecule$1(sdfPart, labels, currentLabels, options) {
  let parts = sdfPart.split(`${options.eol}>`);
  if (parts.length === 0 || parts[0].length <= 5) return;
  let molecule = {};
  molecule.molfile = parts[0] + options.eol;
  for (let j = 1; j < parts.length; j++) {
    let lines = parts[j].split(options.eol);
    let from = lines[0].indexOf('<');
    let to = lines[0].indexOf('>');
    let label = lines[0].substring(from + 1, to);
    currentLabels.push(label);
    if (!labels[label]) {
      labels[label] = {
        counter: 0,
        isNumeric: options.dynamicTyping,
        keep: false,
      };
      if (
        (!options.exclude || options.exclude.indexOf(label) === -1) &&
        (!options.include || options.include.indexOf(label) > -1)
      ) {
        labels[label].keep = true;
        if (options.modifiers[label]) {
          labels[label].modifier = options.modifiers[label];
        }
        if (options.forEach[label]) {
          labels[label].forEach = options.forEach[label];
        }
      }
    }
    if (labels[label].keep) {
      for (let k = 1; k < lines.length - 1; k++) {
        if (molecule[label]) {
          molecule[label] += options.eol + lines[k];
        } else {
          molecule[label] = lines[k];
        }
      }
      if (labels[label].modifier) {
        let modifiedValue = labels[label].modifier(molecule[label]);
        if (modifiedValue === undefined || modifiedValue === null) {
          delete molecule[label];
        } else {
          molecule[label] = modifiedValue;
        }
      }
      if (labels[label].isNumeric) {
        if (!isFinite(molecule[label]) || molecule[label].match(/^0[0-9]/)) {
          labels[label].isNumeric = false;
        }
      }
    }
  }
  return molecule;
}

/**
 *  Parse a SDF file
 * @param {string|ArrayBuffer|Uint8Array} sdf SDF file to parse
 * @param {object} [options={}]
 * @param {string[]} [options.include] List of fields to include
 * @param {string[]} [options.exclude] List of fields to exclude
 * @param {Function} [options.filter] Callback allowing to filter the molecules
 * @param {boolean} [options.dynamicTyping] Dynamically type the data
 * @param {object} [options.modifiers] Object containing callbacks to apply on some specific fields
 * @param {boolean} [options.mixedEOL=false] Set to true if you know there is a mixture between \r\n and \n
 * @param {string} [options.eol] Specify the end of line character. Default will be the one found in the file
 */
function parse(sdf, options = {}) {
  options = { ...options };
  if (options.modifiers === undefined) options.modifiers = {};
  if (options.forEach === undefined) options.forEach = {};
  if (options.dynamicTyping === undefined) options.dynamicTyping = true;

  sdf = ensureString.ensureString(sdf);
  if (typeof sdf !== 'string') {
    throw new TypeError('Parameter "sdf" must be a string');
  }

  if (options.eol === undefined) {
    options.eol = '\n';
    if (options.mixedEOL) {
      sdf = sdf.replace(/\r\n/g, '\n');
      sdf = sdf.replace(/\r/g, '\n');
    } else {
      // we will find the delimiter in order to be much faster and not use regular expression
      let header = sdf.substr(0, 1000);
      if (header.indexOf('\r\n') > -1) {
        options.eol = '\r\n';
      } else if (header.indexOf('\r') > -1) {
        options.eol = '\r';
      }
    }
  }

  let entriesBoundaries = getEntriesBoundaries(
    sdf,
    `${options.eol}$$$$`,
    options.eol,
  );
  let molecules = [];
  let labels = {};

  let start = Date.now();

  for (let i = 0; i < entriesBoundaries.length; i++) {
    let sdfPart = sdf.substring(...entriesBoundaries[i]);

    let currentLabels = [];
    const molecule = getMolecule$1(sdfPart, labels, currentLabels, options);
    if (!molecule) continue;
    if (!options.filter || options.filter(molecule)) {
      molecules.push(molecule);
      // only now we can increase the counter
      for (let j = 0; j < currentLabels.length; j++) {
        labels[currentLabels[j]].counter++;
      }
    }
  }
  // all numeric fields should be converted to numbers
  for (let label in labels) {
    let currentLabel = labels[label];
    if (currentLabel.isNumeric) {
      currentLabel.minValue = Infinity;
      currentLabel.maxValue = -Infinity;
      for (let j = 0; j < molecules.length; j++) {
        if (molecules[j][label]) {
          let value = parseFloat(molecules[j][label]);
          molecules[j][label] = value;
          if (value > currentLabel.maxValue) {
            currentLabel.maxValue = value;
          }
          if (value < currentLabel.minValue) {
            currentLabel.minValue = value;
          }
        }
      }
    }
  }

  // we check that a label is in all the records
  for (let key in labels) {
    if (labels[key].counter === molecules.length) {
      labels[key].always = true;
    } else {
      labels[key].always = false;
    }
  }

  let statistics = [];
  for (let key in labels) {
    let statistic = labels[key];
    statistic.label = key;
    statistics.push(statistic);
  }

  return {
    time: Date.now() - start,
    molecules,
    labels: Object.keys(labels),
    statistics,
  };
}

/**
 *  Parse a SDF file
 * @param {NodeJS.ReadableStream} readStream SDF file to parse
 * @param {object} [options={}]
 * @param {Function} [options.filter] Callback allowing to filter the molecules
 * @param {boolean} [options.dynamicTyping] Dynamically type the data
 */

async function* iterator(readStream, options = {}) {
  const lines = readline.createInterface(readStream);
  const currentLines = [];
  options = { ...options };
  if (options.dynamicTyping === undefined) options.dynamicTyping = true;

  options.eol = '\n';
  for await (let line of lines) {
    if (line.startsWith('$$$$')) {
      const molecule = getMolecule(currentLines.join(options.eol), options);
      if (!options.filter || options.filter(molecule)) {
        yield molecule;
      }
      currentLines.length = 0;
    } else {
      currentLines.push(line);
    }
  }
}

function getMolecule(sdfPart, options) {
  let parts = sdfPart.split(`${options.eol}>`);
  if (parts.length === 0 || parts[0].length <= 5) return;
  let molecule = {};
  molecule.molfile = parts[0] + options.eol;
  for (let j = 1; j < parts.length; j++) {
    let lines = parts[j].split(options.eol);
    let from = lines[0].indexOf('<');
    let to = lines[0].indexOf('>');
    let label = lines[0].substring(from + 1, to);
    for (let k = 1; k < lines.length - 1; k++) {
      if (molecule[label]) {
        molecule[label] += options.eol + lines[k];
      } else {
        molecule[label] = lines[k];
      }
    }
    if (options.dynamicTyping) {
      molecule[label] = dynamicTyping.parseString(molecule[label]);
    }
  }
  return molecule;
}

exports.iterator = iterator;
exports.parse = parse;

},{"dynamic-typing":6,"ensure-string":7,"readline":535}],528:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSpectrum2D = exports.Spectrum2DGenerator = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const ml_spectra_processing_1 = require("ml-spectra-processing");
const axis2D = ['x', 'y'];
const peakCoordinates = ['x', 'y', 'z'];
const convertWidthToFWHM = (shape, width) => {
    const widthData = ensureXYNumber(width);
    for (let key of axis2D) {
        widthData[key] = shape.widthToFWHM(widthData[key]);
    }
    return widthData;
};
class Spectrum2DGenerator {
    constructor(options = {}) {
        let { from = 0, to = 100, nbPoints = 1001, peakWidthFct = () => 5, shape = {
            kind: 'gaussian',
        }, } = options;
        from = ensureXYNumber(from);
        to = ensureXYNumber(to);
        nbPoints = ensureXYNumber(nbPoints);
        for (const axis of axis2D) {
            assertNumber(from[axis], `from-${axis}`);
            assertNumber(to[axis], `to-${axis}`);
            assertInteger(nbPoints[axis], `nbPoints-${axis}`);
        }
        this.from = from;
        this.to = to;
        this.nbPoints = nbPoints;
        this.interval = calculeIntervals(from, to, nbPoints);
        this.peakWidthFct = peakWidthFct;
        this.maxPeakHeight = Number.MIN_SAFE_INTEGER;
        let shapeGenerator = (0, ml_peak_shape_generator_1.getShape2D)(shape);
        this.shape = shapeGenerator;
        this.data = {
            x: new Float64Array(nbPoints.x),
            y: new Float64Array(nbPoints.y),
            z: createMatrix(this.nbPoints),
        };
        for (const axis of axis2D) {
            if (this.to[axis] <= this.from[axis]) {
                throw new RangeError('to option must be larger than from');
            }
        }
        if (typeof this.peakWidthFct !== 'function') {
            throw new TypeError('peakWidthFct option must be a function');
        }
        this.reset();
    }
    addPeaks(peaks, options) {
        if (!Array.isArray(peaks) &&
            (typeof peaks !== 'object' ||
                peaks.x === undefined ||
                peaks.y === undefined ||
                !Array.isArray(peaks.x) ||
                !Array.isArray(peaks.y) ||
                peaks.x.length !== peaks.y.length)) {
            throw new TypeError('peaks must be an array or an object containing x[] and y[]');
        }
        if (Array.isArray(peaks)) {
            for (const peak of peaks) {
                this.addPeak(peak, options);
            }
        }
        else {
            let nbPeaks = peaks.x.length;
            for (const c of peakCoordinates) {
                if (peaks[c] && Array.isArray(peaks[c])) {
                    if (nbPeaks !== peaks[c].length) {
                        throw new Error('x, y, z should have the same length');
                    }
                }
            }
            for (let i = 0; i < peaks.x.length; i++) {
                this.addPeak([peaks.x[i], peaks.y[i], peaks.z[i]], options);
            }
        }
        return this;
    }
    addPeak(peak, options = {}) {
        if (Array.isArray(peak) && peak.length < 3) {
            throw new Error('peak must be an array with three (or four) values or an object with {x,y,z,width?}');
        }
        if (!Array.isArray(peak) &&
            peakCoordinates.some((e) => peak[e] === undefined)) {
            throw new Error('peak must be an array with three (or four) values or an object with {x,y,z,width?}');
        }
        let xPosition;
        let yPosition;
        let intensity;
        let peakFWHM;
        let peakWidth;
        let peakShapeOptions;
        if (Array.isArray(peak)) {
            [xPosition, yPosition, intensity, peakFWHM, peakShapeOptions] = peak;
        }
        else {
            xPosition = peak.x;
            yPosition = peak.y;
            intensity = peak.z;
            peakFWHM = peak.fwhm;
            peakWidth = peak.width;
            peakShapeOptions = peak.shape;
        }
        const position = { x: xPosition, y: yPosition };
        if (intensity > this.maxPeakHeight)
            this.maxPeakHeight = intensity;
        let { shape: shapeOptions, width } = options;
        if (peakShapeOptions) {
            shapeOptions = shapeOptions
                ? { ...shapeOptions, ...peakShapeOptions }
                : peakShapeOptions;
        }
        const shape = shapeOptions
            ? (0, ml_peak_shape_generator_1.getShape2D)(shapeOptions)
            : Object.assign(Object.create(Object.getPrototypeOf(this.shape)), JSON.parse(JSON.stringify(this.shape)));
        let { fwhm = peakFWHM !== undefined
            ? peakFWHM
            : peakWidth
                ? convertWidthToFWHM(shape, peakWidth)
                : width
                    ? convertWidthToFWHM(shape, width)
                    : this.peakWidthFct(xPosition, yPosition), } = options;
        fwhm = ensureXYNumber(fwhm);
        let factor = options.factor === undefined ? shape.getFactor() : options.factor;
        factor = ensureXYNumber(factor);
        const firstPoint = { x: 0, y: 0 };
        const lastPoint = { x: 0, y: 0 };
        for (const axis of axis2D) {
            const first = position[axis] - (fwhm[axis] / 2) * factor[axis];
            const last = position[axis] + (fwhm[axis] / 2) * factor[axis];
            firstPoint[axis] = Math.max(0, Math.floor((first - this.from[axis]) / this.interval[axis]));
            lastPoint[axis] = Math.min(this.nbPoints[axis], Math.ceil((last - this.from[axis]) / this.interval[axis]));
        }
        shape.fwhm = fwhm;
        for (let xIndex = firstPoint.x; xIndex < lastPoint.x; xIndex++) {
            for (let yIndex = firstPoint.y; yIndex < lastPoint.y; yIndex++) {
                const value = intensity *
                    shape.fct(this.data.x[xIndex] - position.x, this.data.y[yIndex] - position.y);
                if (value > 1e-6) {
                    this.data.z[yIndex][xIndex] += value;
                }
            }
        }
        return this;
    }
    getSpectrum(options = {}) {
        if (typeof options === 'boolean') {
            options = { copy: options };
        }
        const { copy = true } = options;
        let minMaxZ = (0, ml_spectra_processing_1.matrixMinMaxZ)(this.data.z);
        return {
            minX: this.from.x,
            maxX: this.to.x,
            maxY: this.to.y,
            minY: this.from.y,
            minZ: minMaxZ.min,
            maxZ: minMaxZ.max,
            z: copy ? this.data.z.slice() : this.data.z,
        };
    }
    reset() {
        const spectrum = this.data;
        for (const axis of axis2D) {
            for (let i = 0; i < this.nbPoints[axis]; i++) {
                spectrum[axis][i] = this.from[axis] + i * this.interval[axis];
            }
        }
        for (let row of spectrum.z) {
            for (let j = 0; j < row.length; j++) {
                row[j] = 0;
            }
        }
        return this;
    }
}
exports.Spectrum2DGenerator = Spectrum2DGenerator;
function generateSpectrum2D(peaks, options = {}) {
    const { generator: generatorOptions, peaks: addPeaksOptions } = options;
    const generator = new Spectrum2DGenerator(generatorOptions);
    generator.addPeaks(peaks, addPeaksOptions);
    return generator.getSpectrum();
}
exports.generateSpectrum2D = generateSpectrum2D;
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function calculeIntervals(from, to, nbPoints) {
    return {
        x: (to.x - from.x) / (nbPoints.x - 1),
        y: (to.y - from.y) / (nbPoints.y - 1),
    };
}
function assertInteger(value, name) {
    if (!Number.isInteger(value)) {
        throw new TypeError(`${name} option must be an integer`);
    }
}
function assertNumber(value, name) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`${name} option must be a number`);
    }
}
function createMatrix(nbPoints) {
    const zMatrix = new Array(nbPoints.y);
    for (let i = 0; i < nbPoints.y; i++) {
        zMatrix[i] = new Float64Array(nbPoints.x);
    }
    return zMatrix;
}

},{"ml-peak-shape-generator":187,"ml-spectra-processing":208}],529:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSpectrum = exports.SpectrumGenerator = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const addBaseline_1 = __importDefault(require("./util/addBaseline"));
const addNoise_1 = __importDefault(require("./util/addNoise"));
class SpectrumGenerator {
    constructor(options = {}) {
        const { from = 0, to = 1000, nbPoints = 10001, peakWidthFct, shape = { kind: 'gaussian', fwhm: 5 }, } = options;
        this.from = from;
        this.to = to;
        this.nbPoints = nbPoints;
        this.interval = (this.to - this.from) / (this.nbPoints - 1);
        this.peakWidthFct = peakWidthFct;
        this.maxPeakHeight = Number.MIN_SAFE_INTEGER;
        this.data = {
            x: new Float64Array(this.nbPoints),
            y: new Float64Array(this.nbPoints),
        };
        let shapeGenerator = (0, ml_peak_shape_generator_1.getShape1D)(shape);
        this.shape = shapeGenerator;
        assertNumber(this.from, 'from');
        assertNumber(this.to, 'to');
        assertInteger(this.nbPoints, 'nbPoints');
        if (this.to <= this.from) {
            throw new RangeError('to option must be larger than from');
        }
        if (this.peakWidthFct && typeof this.peakWidthFct !== 'function') {
            throw new TypeError('peakWidthFct option must be a function');
        }
        this.reset();
    }
    /**
     * Add a series of peaks to the spectrum.
     * @param peaks - Peaks to add.
     */
    addPeaks(peaks, options) {
        if (!Array.isArray(peaks) &&
            (typeof peaks !== 'object' ||
                peaks.x === undefined ||
                peaks.y === undefined ||
                !Array.isArray(peaks.x) ||
                !Array.isArray(peaks.y) ||
                peaks.x.length !== peaks.y.length)) {
            throw new TypeError('peaks must be an array or an object containing x[] and y[]');
        }
        if (Array.isArray(peaks)) {
            for (const peak of peaks) {
                this.addPeak(peak, options);
            }
        }
        else {
            for (let i = 0; i < peaks.x.length; i++) {
                this.addPeak([peaks.x[i], peaks.y[i]], options);
            }
        }
    }
    /**
     * Add a single peak to the spectrum.
     * A peak may be either defined as [x,y,fwhm,...] or as {x, y, shape}
     * @param peak
     * @param options
     */
    addPeak(peak, options = {}) {
        if (Array.isArray(peak) && peak.length < 2) {
            throw new Error('peak must be an array with two (or three) values or an object with {x,y,width?}');
        }
        if (!Array.isArray(peak) &&
            (peak.x === undefined || peak.y === undefined)) {
            throw new Error('peak must be an array with two (or three) values or an object with {x,y,width?}');
        }
        let xPosition;
        let intensity;
        let peakFWHM;
        let peakWidth;
        let peakShapeOptions;
        if (Array.isArray(peak)) {
            [xPosition, intensity, peakFWHM, peakShapeOptions] = peak;
        }
        else {
            xPosition = peak.x;
            intensity = peak.y;
            peakWidth = peak.width;
            peakShapeOptions = peak.shape;
        }
        if (intensity > this.maxPeakHeight)
            this.maxPeakHeight = intensity;
        let { shape: shapeOptions } = options;
        if (peakShapeOptions) {
            shapeOptions = shapeOptions
                ? { ...shapeOptions, ...peakShapeOptions }
                : peakShapeOptions;
        }
        const shape = shapeOptions
            ? (0, ml_peak_shape_generator_1.getShape1D)(shapeOptions)
            : Object.assign(Object.create(Object.getPrototypeOf(this.shape)), this.shape);
        let { width, widthLeft, widthRight } = options;
        /*
         if we don't force the fwhm we just take the one from the shape
         however we have many way to force it:
         - use [x,y,fwhm]
         - define `width` that will be converted to fwhm
         - define `widthLeft` and `widthRight` to define asymmetric peaks
         - have a callback `peakWidthFct`
         This should evolve in the future because we will not always have `fwhm`
         */
        const fwhm = peakFWHM !== undefined
            ? peakFWHM
            : peakWidth
                ? shape.widthToFWHM(peakWidth)
                : this.peakWidthFct
                    ? this.peakWidthFct(xPosition)
                    : width !== undefined
                        ? width
                        : shape.fwhm;
        if (!widthLeft)
            widthLeft = fwhm;
        if (!widthRight)
            widthRight = fwhm;
        if (!widthLeft || !widthRight) {
            throw new Error('Width left or right is undefined or zero');
        }
        let factor = options.factor === undefined ? shape.getFactor() : options.factor;
        const firstValue = xPosition - (widthLeft / 2) * factor;
        const lastValue = xPosition + (widthRight / 2) * factor;
        const firstPoint = Math.max(0, Math.floor((firstValue - this.from) / this.interval));
        const lastPoint = Math.min(this.nbPoints - 1, Math.ceil((lastValue - this.from) / this.interval));
        const middlePoint = Math.round((xPosition - this.from) / this.interval);
        // PEAK SHAPE MAY BE ASYMMETRC (widthLeft and widthRight) !
        // we calculate the left part of the shape
        shape.fwhm = widthLeft;
        for (let index = firstPoint; index < Math.max(middlePoint, 0); index++) {
            this.data.y[index] +=
                intensity * shape.fct(this.data.x[index] - xPosition);
        }
        // we calculate the right part of the gaussian
        shape.fwhm = widthRight;
        for (let index = Math.min(middlePoint, lastPoint); index <= lastPoint; index++) {
            this.data.y[index] +=
                intensity * shape.fct(this.data.x[index] - xPosition);
        }
    }
    /**
     * Add a baseline to the spectrum.
     * @param baselineFct - Mathematical function producing the baseline you want.
     */
    addBaseline(baselineFct) {
        (0, addBaseline_1.default)(this.data, baselineFct);
        return this;
    }
    /**
     * Add noise to the spectrum.
     *
     * @param percent - Noise's amplitude in percents of the spectrum max value. Default: 1.
     */
    addNoise(options) {
        (0, addNoise_1.default)(this.data, options);
        return this;
    }
    /**
     * Get the generated spectrum.
     */
    getSpectrum(options = {}) {
        if (typeof options === 'boolean') {
            options = { copy: options };
        }
        const { copy = true, threshold = 0 } = options;
        if (threshold) {
            let minPeakHeight = this.maxPeakHeight * threshold;
            let x = [];
            let y = [];
            for (let i = 0; i < this.data.x.length; i++) {
                if (this.data.y[i] >= minPeakHeight) {
                    x.push(this.data.x[i]);
                    y.push(this.data.y[i]);
                }
            }
            return { x, y };
        }
        if (copy) {
            return {
                x: this.data.x.slice(),
                y: this.data.y.slice(),
            };
        }
        else {
            return this.data;
        }
    }
    /**
     * Resets the generator with an empty spectrum.
     */
    reset() {
        const spectrum = this.data;
        for (let i = 0; i < this.nbPoints; i++) {
            spectrum.x[i] = this.from + i * this.interval;
        }
        return this;
    }
}
exports.SpectrumGenerator = SpectrumGenerator;
function assertInteger(value, name) {
    if (!Number.isInteger(value)) {
        throw new TypeError(`${name} option must be an integer`);
    }
}
function assertNumber(value, name) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`${name} option must be a number`);
    }
}
/**
 * Generates a spectrum and returns it.
 * @param peaks - List of peaks to put in the spectrum.
 * @param options
 */
function generateSpectrum(peaks, options = {}) {
    const { generator: generatorOptions, noise, baseline, threshold, peakOptions, } = options;
    const generator = new SpectrumGenerator(generatorOptions);
    generator.addPeaks(peaks, peakOptions);
    if (baseline)
        generator.addBaseline(baseline);
    if (noise) {
        generator.addNoise(noise);
    }
    return generator.getSpectrum({
        threshold,
    });
}
exports.generateSpectrum = generateSpectrum;

},{"./util/addBaseline":531,"./util/addNoise":532,"ml-peak-shape-generator":187}],530:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SpectrumGenerator"), exports);
__exportStar(require("./Spectrum2DGenerator"), exports);

},{"./Spectrum2DGenerator":528,"./SpectrumGenerator":529}],531:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function addBaseline(data, baselineFct) {
    if (!baselineFct)
        return data;
    let xs = data.x;
    let ys = data.y;
    for (let i = 0; i < xs.length; i++) {
        ys[i] += baselineFct(xs[i]);
    }
    return data;
}
exports.default = addBaseline;

},{}],532:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_spectra_processing_1 = require("ml-spectra-processing");
function addNoise(data, options = {}) {
    const { seed = 0, distribution = 'normal', percent = 1 } = options;
    const range = ((0, ml_spectra_processing_1.xMaxValue)(data.y) * percent) / 100;
    const noise = (0, ml_spectra_processing_1.createRandomArray)({
        distribution,
        seed,
        mean: 0,
        standardDeviation: range,
        range,
        length: data.x.length,
    });
    data.y = (0, ml_spectra_processing_1.xAdd)(data.y, noise);
    return data;
}
exports.default = addNoise;

},{"ml-spectra-processing":208}],533:[function(require,module,exports){
const {bisectRight} = require('d3-array')

const quincunx = (u, v, w, q) => {
  const n = u.length - 1

  u[0] = 0
  v[0] = 0
  w[0] = 0
  v[1] = v[1] / u[1]
  w[1] = w[1] / u[1]
  for (let i = 2; i < n; ++i) {
    u[i] = u[i] - u[i - 2] * w[i - 2] * w[i - 2] - u[i - 1] * v[i - 1] * v[i - 1]
    v[i] = (v[i] - u[i - 1] * v[i - 1] * w[i - 1]) / u[i]
    w[i] = w[i] / u[i]
  }

  for (let i = 2; i < n; ++i) {
    q[i] = q[i] - v[i - 1] * q[i - 1] - w[i - 2] * q[i - 2]
  }
  for (let i = 1; i < n; ++i) {
    q[i] = q[i] / u[i]
  }

  q[n - 2] = q[n - 2] - v[n - 2] * q[n - 1]
  for (let i = n - 3; i > 0; --i) {
    q[i] = q[i] - v[i] * q[i + 1] - w[i] * q[i + 2]
  }
}

const smoothingSpline = (x, y, sigma, lambda) => {
  const n = x.length - 1
  const h = new Array(n + 1)
  const r = new Array(n + 1)
  const f = new Array(n + 1)
  const p = new Array(n + 1)
  const q = new Array(n + 1)
  const u = new Array(n + 1)
  const v = new Array(n + 1)
  const w = new Array(n + 1)
  const params = x.map(() => [0, 0, 0, 0])
  params.pop()

  const mu = 2 * (1 - lambda) / (3 * lambda)
  for (let i = 0; i < n; ++i) {
    h[i] = x[i + 1] - x[i]
    r[i] = 3 / h[i]
  }
  q[0] = 0
  for (let i = 1; i < n; ++i) {
    f[i] = -(r[i - 1] + r[i])
    p[i] = 2 * (x[i + 1] - x[i - 1])
    q[i] = 3 * (y[i + 1] - y[i]) / h[i] - 3 * (y[i] - y[i - 1]) / h[i - 1]
  }
  q[n] = 0

  for (let i = 1; i < n; ++i) {
    u[i] = r[i - 1] * r[i - 1] * sigma[i - 1] + f[i] * f[i] * sigma[i] + r[i] * r[i] * sigma[i + 1]
    u[i] = mu * u[i] + p[i]
  }
  for (let i = 1; i < n - 1; ++i) {
    v[i] = f[i] * r[i] * sigma[i] + r[i] * f[i + 1] * sigma[i + 1]
    v[i] = mu * v[i] + h[i]
  }
  for (let i = 1; i < n - 2; ++i) {
    w[i] = mu * r[i] * r[i + 1] * sigma[i + 1]
  }

  quincunx(u, v, w, q)

  params[0][3] = y[0] - mu * r[0] * q[1] * sigma[0]
  params[1][3] = y[1] - mu * (f[1] * q[1] + r[1] * q[2]) * sigma[0]
  params[0][0] = q[1] / (3 * h[0])
  params[0][1] = 0
  params[0][2] = (params[1][3] - params[0][3]) / h[0] - q[1] * h[0] / 3
  r[0] = 0
  for (let i = 1; i < n; ++i) {
    params[i][0] = (q[i + 1] - q[i]) / (3 * h[i])
    params[i][1] = q[i]
    params[i][2] = (q[i] + q[i - 1]) * h[i - 1] + params[i - 1][2]
    params[i][3] = r[i - 1] * q[i - 1] + f[i] * q[i] + r[i] * q[i + 1]
    params[i][3] = y[i] - mu * params[i][3] * sigma[i]
  }
  return params
}

class SplineInterpolator {
  constructor (xIn, yIn, lambda = 1) {
    const indices = xIn.map((_, i) => i)
    indices.sort((i, j) => xIn[i] - xIn[j])
    const x = indices.map((i) => xIn[i])
    const y = indices.map((i) => yIn[i])
    const n = indices.length
    const sigma = indices.map(() => 1)
    this.n = n
    this.x = x
    this.y = y
    this.params = smoothingSpline(x, y, sigma, lambda)
  }

  interpolate (v) {
    if (v === this.x[this.n - 1]) {
      return this.y[this.n - 1]
    }
    const i = Math.min(Math.max(0, bisectRight(this.x, v) - 1), this.n - 2)
    const [a, b, c, d] = this.params[i]
    v = v - this.x[i]
    return a * v * v * v + b * v * v + c * v + d
  }

  max (step = 100) {
    const xStart = this.x[0]
    const xStop = this.x[this.n - 1]
    const delta = (xStop - xStart) / step
    let maxValue = -Infinity
    for (let i = 0, x = xStart; i < step; ++i, x += delta) {
      const y = this.interpolate(x)
      if (y > maxValue) {
        maxValue = y
      }
    }
    return maxValue
  }

  min (step = 100) {
    const xStart = this.x[0]
    const xStop = this.x[this.n - 1]
    const delta = (xStop - xStart) / step
    let minValue = Infinity
    for (let i = 0, x = xStart; i < step; ++i, x += delta) {
      const y = this.interpolate(x)
      if (y < minValue) {
        minValue = y
      }
    }
    return minValue
  }

  domain () {
    return [this.x[0], this.x[this.x.length - 1]]
  }

  range () {
    return [this.min(), this.max()]
  }

  curve (nInterval, domain = null) {
    domain = domain || this.domain()
    const delta = (domain[1] - domain[0]) / (nInterval - 1)
    const vals = new Array(nInterval)
    for (let i = 0; i < nInterval; ++i) {
      const x = delta * i + domain[0]
      vals[i] = [x, this.interpolate(x)]
    }
    return vals
  }
}

module.exports = SplineInterpolator

},{"d3-array":5}],534:[function(require,module,exports){
(function (global){(function (){
global.nmrProcessing = require('/Users/abernal/node_modules/nmr-processing');
global.spectraProcessing = require('/Users/abernal/node_modules/ml-spectra-processing');
global.referenceDeconvolution = require('/Users/abernal/node_modules/ml-reference-deconvolution/')

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/abernal/node_modules/ml-reference-deconvolution/":196,"/Users/abernal/node_modules/ml-spectra-processing":208,"/Users/abernal/node_modules/nmr-processing":457}],535:[function(require,module,exports){

},{}],536:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],537:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":536,"timers":537}]},{},[534]);
