% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{smatplot}
\alias{smatplot}
\title{Fast spectra overlay plot}
\usage{
smatplot(
  ppm,
  y,
  roi,
  by,
  lty = 1,
  legend,
  label,
  reverse = TRUE,
  resolution = c("full", "dev", ifelse(length(as.matrix(y)) > 1200000, "dev", "full"))[3],
  reduce,
  col = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628",
    "#F781BF", "#999999"),
  ...
)
}
\arguments{
\item{ppm}{numeric, spectra ppm scale}

\item{y}{numeric vector or matrix, nmr intensities, spectra in rows. If neither
vector nor matrix, argument is cast as.matrix. Type compliance is recommended.}

\item{roi}{numeric, optional, limits of the Region of Interest to be plotted.
Defaults to the range of \code{ppm}.}

\item{by}{numeric, optional, number of spectra to be overlayed on each plot}

\item{lty}{optional, line type, defaults to 1 (continuous line). Note that this
parameter is passed both to \code{\link[graphics]{matplot}} and \code{\link[graphics]{legend}},
so you always get lines in your legend (see ... below)}

\item{legend, }{optional, position of the legend as specified in
\code{\link[graphics]{legend}}}

\item{label, }{character, optional, series labels for the legend}

\item{reverse}{logic, optional, if TRUE (default) the x scale of the plot
increases from right to left as it's customary in NMR spectroscopy}

\item{resolution, }{character. If "full" all data are passed to
\code{\link[graphics]{matplot}}. If "dev", data are binned to fit the graphic
device's resolution before plotting. By default \code{smatplot} chooses
according to data size. See Details.}

\item{reduce, }{function used to compute bin values. See Details}

\item{col}{vector of series colors. The default is \emph{Set1} copied from
\code{\link[RColorBrewer]{RColorBrewer}}.}

\item{..., }{additional arguments for customization. These arguments are
passed either to \code{\link[graphics]{matplot}} for plot customization, or
to  \code{\link[graphics]{legend}} for legend customization. Beware that some
of these parameters are shared, such as \code{ltw} and the non-optional
parameters \code{lty} and \code{col}. This means, for instance, that it is
not possible to get a legend without lines or to unmatch legend linewidths
from the plot's.}
}
\description{
Wrapper to \code{\link[graphics]{matplot}} for plotting spectra. Crude
compared to \code{ggplot2} but faster.
This is similar to \code{\link[graphics]{matplot}} with \code{interactive==FALSE}
but uses a slightly different interface, allows to split spectra in multiple
plots, handles \code{...} parameters more accurately, implements a more
advanced \code{resolution} system, etc.
}
\details{
tl;dr: For spectra with less than ~1.2 million points the default method
renders fast and exact plots. Otherwise:
\itemize{
\item the default method adds a quick pre-processing step to make the plot fast
to render, at the cost of inaccurate peak heights
\item \code{resolution="dev", reduce=max} pre-processes slower, renders as fast
and gives accurate peak heights, but introduces ppm inaccuracies visible when
zooming in
\item \code{resolution="full"} is exact but very slow to render.
}

Further details follow.

When working with high resolution spectra it is likely that the resolution
of the spectrum is higher than the pixel resolution of the graphic device,
which places an unnecessary burden on the renderer. By default \code{smatplot}
bins the spectra matrix to match the pixel resolution of the active graphic
device (as reported by \code{\link[grDevices]{dev.size}}) if the input spectra
contain more than 1.2 million points total. The user can force full resolution
or binned resolution by setting \code{resolution} to "full" or "dev"
respectively.

By default, bin values are computed by sampling each spectrum at regular
intervals. This method is fast, which is good for the visualization of large
datasets, but it produces inaccurate estimates of peak height. Alternatively,
the user may pass a function to the \code{reduce} parameter that will be used
to compute the bins. In this case, each spectrum is partitioned with
\code{\link[base]{split}} and the \code{reduce} function is applied to compute
each bin's intensity value and ppm. This adds a expensive pre-processing
step that makes the plot slower to compute but the result renders much
faster than \code{resolution="full"}. Beware that spectra rendered in this manner
are chemical shift-accurate only up to the current graphic resolution.
This means that inaccuracies in the frequency coordinate may appear
if you enhance the resolution of the graphic device after plotting e.g. by
enlarging the plot window in RStudio.
From experience,\code{reduce=max} produces the most accurate picture of peak
intensities, while \code{reduce=mean} or \code{median} provide a compromise
between intensity and chemical shift accuracy.
}
